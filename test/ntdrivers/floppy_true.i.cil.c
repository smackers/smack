#include "smack.h"

// @expect verified

extern char __VERIFIER_nondet_char(void);
extern int __VERIFIER_nondet_int(void);
extern long __VERIFIER_nondet_long(void);
extern void *__VERIFIER_nondet_pointer(void);
/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#pragma pack(push, 8)
typedef unsigned int size_t;
typedef unsigned short wchar_t;
#pragma pack(pop)
#pragma pack(push, 8)
#pragma pack(pop)
typedef unsigned long ULONG_PTR;
typedef unsigned long *PULONG_PTR;
typedef ULONG_PTR SIZE_T;
typedef void *PVOID;
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
typedef wchar_t WCHAR;
typedef WCHAR *PWSTR;
typedef WCHAR const *PCWSTR;
typedef CHAR *PCHAR;
typedef LONG *PLONG;
typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef UCHAR *PUCHAR;
typedef ULONG *PULONG;
typedef void *HANDLE;
typedef HANDLE *PHANDLE;
typedef char CCHAR;
typedef short CSHORT;
typedef ULONG LCID;
typedef LONG NTSTATUS;
typedef long long LONGLONG;
struct __anonstruct____missing_field_name_1 {
  ULONG LowPart;
  LONG HighPart;
};
struct __anonstruct_u_2 {
  ULONG LowPart;
  LONG HighPart;
};
union _LARGE_INTEGER {
  struct __anonstruct____missing_field_name_1 __annonCompField1;
  struct __anonstruct_u_2 u;
  LONGLONG QuadPart;
};
typedef union _LARGE_INTEGER LARGE_INTEGER;
typedef LARGE_INTEGER *PLARGE_INTEGER;
struct _LUID {
  ULONG LowPart;
  LONG HighPart;
};
typedef struct _LUID LUID;
typedef LARGE_INTEGER PHYSICAL_ADDRESS;
enum _EVENT_TYPE { NotificationEvent = 0, SynchronizationEvent = 1 };
typedef enum _EVENT_TYPE EVENT_TYPE;
typedef char const *PCSZ;
struct _STRING {
  USHORT Length;
  USHORT MaximumLength;
  PCHAR Buffer;
};
typedef struct _STRING STRING;
typedef STRING *PSTRING;
typedef PSTRING PANSI_STRING;
struct _UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWSTR Buffer;
};
typedef struct _UNICODE_STRING UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef UCHAR BOOLEAN;
struct _LIST_ENTRY {
  struct _LIST_ENTRY *Flink;
  struct _LIST_ENTRY *Blink;
};
typedef struct _LIST_ENTRY LIST_ENTRY;
typedef struct _LIST_ENTRY *PLIST_ENTRY;
struct _OBJECT_ATTRIBUTES {
  ULONG Length;
  HANDLE RootDirectory;
  PUNICODE_STRING ObjectName;
  ULONG Attributes;
  PVOID SecurityDescriptor;
  PVOID SecurityQualityOfService;
};
typedef struct _OBJECT_ATTRIBUTES OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
struct _GUID {
  unsigned long Data1;
  unsigned short Data2;
  unsigned short Data3;
  unsigned char Data4[8];
};
typedef struct _GUID GUID;
typedef UCHAR KIRQL;
enum _NT_PRODUCT_TYPE {
  NtProductWinNt = 1,
  NtProductLanManNt = 2,
  NtProductServer = 3
};
typedef enum _NT_PRODUCT_TYPE NT_PRODUCT_TYPE;
struct _KTHREAD;
typedef struct _KTHREAD *PKTHREAD;
struct _ETHREAD;
typedef struct _ETHREAD *PETHREAD;
struct _EPROCESS;
typedef struct _EPROCESS *PEPROCESS;
struct _IO_TIMER;
typedef struct _IO_TIMER *PIO_TIMER;
struct _OBJECT_TYPE;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef CCHAR KPROCESSOR_MODE;
struct _KAPC;
struct _KAPC;
typedef void (*PKNORMAL_ROUTINE)(PVOID NormalContext, PVOID SystemArgument1,
                                 PVOID SystemArgument2);
struct _KAPC {
  CSHORT Type;
  CSHORT Size;
  ULONG Spare0;
  struct _KTHREAD *Thread;
  LIST_ENTRY ApcListEntry;
  void (*KernelRoutine)(struct _KAPC *Apc, PKNORMAL_ROUTINE *NormalRoutine,
                        PVOID *NormalContext, PVOID *SystemArgument1,
                        PVOID *SystemArgument2);
  void (*RundownRoutine)(struct _KAPC *Apc);
  void (*NormalRoutine)(PVOID NormalContext, PVOID SystemArgument1,
                        PVOID SystemArgument2);
  PVOID NormalContext;
  PVOID SystemArgument1;
  PVOID SystemArgument2;
  CCHAR ApcStateIndex;
  KPROCESSOR_MODE ApcMode;
  BOOLEAN Inserted;
};
typedef struct _KAPC KAPC;
struct _KDPC;
struct _KDPC;
struct _KDPC {
  CSHORT Type;
  UCHAR Number;
  UCHAR Importance;
  LIST_ENTRY DpcListEntry;
  void (*DeferredRoutine)(struct _KDPC *Dpc, PVOID DeferredContext,
                          PVOID SystemArgument1, PVOID SystemArgument2);
  PVOID DeferredContext;
  PVOID SystemArgument1;
  PVOID SystemArgument2;
  PULONG_PTR Lock;
};
typedef struct _KDPC KDPC;
typedef struct _KDPC *PKDPC;
struct _MDL {
  struct _MDL *Next;
  CSHORT Size;
  CSHORT MdlFlags;
  struct _EPROCESS *Process;
  PVOID MappedSystemVa;
  PVOID StartVa;
  ULONG ByteCount;
  ULONG ByteOffset;
};
typedef struct _MDL MDL;
typedef struct _MDL *PMDL;
typedef PVOID PACCESS_TOKEN;
typedef PVOID PSECURITY_DESCRIPTOR;
typedef ULONG ACCESS_MASK;
#pragma pack(push, 4)
struct _LUID_AND_ATTRIBUTES {
  LUID Luid;
  ULONG Attributes;
};
typedef struct _LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES;
#pragma pack(pop)
struct _PRIVILEGE_SET {
  ULONG PrivilegeCount;
  ULONG Control;
  LUID_AND_ATTRIBUTES Privilege[1];
};
typedef struct _PRIVILEGE_SET PRIVILEGE_SET;
enum _SECURITY_IMPERSONATION_LEVEL {
  SecurityAnonymous = 0,
  SecurityIdentification = 1,
  SecurityImpersonation = 2,
  SecurityDelegation = 3
};
typedef enum _SECURITY_IMPERSONATION_LEVEL SECURITY_IMPERSONATION_LEVEL;
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE;
struct _SECURITY_QUALITY_OF_SERVICE {
  ULONG Length;
  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
  SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
  BOOLEAN EffectiveOnly;
};
typedef struct _SECURITY_QUALITY_OF_SERVICE *PSECURITY_QUALITY_OF_SERVICE;
typedef ULONG SECURITY_INFORMATION;
typedef LONG KPRIORITY;
typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;
struct _RTL_QUERY_REGISTRY_TABLE {
  NTSTATUS(*QueryRoutine)
  (PWSTR ValueName, ULONG ValueType, PVOID ValueData, ULONG ValueLength,
   PVOID Context, PVOID EntryContext);
  ULONG Flags;
  PWSTR Name;
  PVOID EntryContext;
  ULONG DefaultType;
  PVOID DefaultData;
  ULONG DefaultLength;
};
typedef struct _RTL_QUERY_REGISTRY_TABLE RTL_QUERY_REGISTRY_TABLE;
typedef struct _RTL_QUERY_REGISTRY_TABLE *PRTL_QUERY_REGISTRY_TABLE;
union __anonunion____missing_field_name_6 {
  NTSTATUS Status;
  PVOID Pointer;
};
struct _IO_STATUS_BLOCK {
  union __anonunion____missing_field_name_6 __annonCompField4;
  ULONG_PTR Information;
};
typedef struct _IO_STATUS_BLOCK IO_STATUS_BLOCK;
typedef struct _IO_STATUS_BLOCK *PIO_STATUS_BLOCK;
enum _FILE_INFORMATION_CLASS {
  FileDirectoryInformation = 1,
  FileFullDirectoryInformation = 2,
  FileBothDirectoryInformation = 3,
  FileBasicInformation = 4,
  FileStandardInformation = 5,
  FileInternalInformation = 6,
  FileEaInformation = 7,
  FileAccessInformation = 8,
  FileNameInformation = 9,
  FileRenameInformation = 10,
  FileLinkInformation = 11,
  FileNamesInformation = 12,
  FileDispositionInformation = 13,
  FilePositionInformation = 14,
  FileFullEaInformation = 15,
  FileModeInformation = 16,
  FileAlignmentInformation = 17,
  FileAllInformation = 18,
  FileAllocationInformation = 19,
  FileEndOfFileInformation = 20,
  FileAlternateNameInformation = 21,
  FileStreamInformation = 22,
  FilePipeInformation = 23,
  FilePipeLocalInformation = 24,
  FilePipeRemoteInformation = 25,
  FileMailslotQueryInformation = 26,
  FileMailslotSetInformation = 27,
  FileCompressionInformation = 28,
  FileObjectIdInformation = 29,
  FileCompletionInformation = 30,
  FileMoveClusterInformation = 31,
  FileQuotaInformation = 32,
  FileReparsePointInformation = 33,
  FileNetworkOpenInformation = 34,
  FileAttributeTagInformation = 35,
  FileTrackingInformation = 36,
  FileMaximumInformation = 37
};
typedef enum _FILE_INFORMATION_CLASS FILE_INFORMATION_CLASS;
struct _FILE_BASIC_INFORMATION {
  LARGE_INTEGER CreationTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER ChangeTime;
  ULONG FileAttributes;
};
typedef struct _FILE_BASIC_INFORMATION *PFILE_BASIC_INFORMATION;
struct _FILE_STANDARD_INFORMATION {
  LARGE_INTEGER AllocationSize;
  LARGE_INTEGER EndOfFile;
  ULONG NumberOfLinks;
  BOOLEAN DeletePending;
  BOOLEAN Directory;
};
typedef struct _FILE_STANDARD_INFORMATION *PFILE_STANDARD_INFORMATION;
struct _FILE_NETWORK_OPEN_INFORMATION {
  LARGE_INTEGER CreationTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER ChangeTime;
  LARGE_INTEGER AllocationSize;
  LARGE_INTEGER EndOfFile;
  ULONG FileAttributes;
};
typedef struct _FILE_NETWORK_OPEN_INFORMATION *PFILE_NETWORK_OPEN_INFORMATION;
enum _FSINFOCLASS {
  FileFsVolumeInformation = 1,
  FileFsLabelInformation = 2,
  FileFsSizeInformation = 3,
  FileFsDeviceInformation = 4,
  FileFsAttributeInformation = 5,
  FileFsControlInformation = 6,
  FileFsFullSizeInformation = 7,
  FileFsObjectIdInformation = 8,
  FileFsMaximumInformation = 9
};
typedef enum _FSINFOCLASS FS_INFORMATION_CLASS;
enum _INTERFACE_TYPE {
  InterfaceTypeUndefined = -1,
  Internal = 0,
  Isa = 1,
  Eisa = 2,
  MicroChannel = 3,
  TurboChannel = 4,
  PCIBus = 5,
  VMEBus = 6,
  NuBus = 7,
  PCMCIABus = 8,
  CBus = 9,
  MPIBus = 10,
  MPSABus = 11,
  ProcessorInternal = 12,
  InternalPowerBus = 13,
  PNPISABus = 14,
  PNPBus = 15,
  MaximumInterfaceType = 16
};
typedef enum _INTERFACE_TYPE INTERFACE_TYPE;
typedef enum _INTERFACE_TYPE *PINTERFACE_TYPE;
struct _KEY_VALUE_FULL_INFORMATION {
  ULONG TitleIndex;
  ULONG Type;
  ULONG DataOffset;
  ULONG DataLength;
  ULONG NameLength;
  WCHAR Name[1];
};
typedef struct _KEY_VALUE_FULL_INFORMATION *PKEY_VALUE_FULL_INFORMATION;
struct _CLIENT_ID {
  HANDLE UniqueProcess;
  HANDLE UniqueThread;
};
typedef struct _CLIENT_ID CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;
enum _SYSTEM_POWER_STATE {
  PowerSystemUnspecified = 0,
  PowerSystemWorking = 1,
  PowerSystemSleeping1 = 2,
  PowerSystemSleeping2 = 3,
  PowerSystemSleeping3 = 4,
  PowerSystemHibernate = 5,
  PowerSystemShutdown = 6,
  PowerSystemMaximum = 7
};
typedef enum _SYSTEM_POWER_STATE SYSTEM_POWER_STATE;
enum __anonenum_POWER_ACTION_11 {
  PowerActionNone = 0,
  PowerActionReserved = 1,
  PowerActionSleep = 2,
  PowerActionHibernate = 3,
  PowerActionShutdown = 4,
  PowerActionShutdownReset = 5,
  PowerActionShutdownOff = 6,
  PowerActionWarmEject = 7
};
typedef enum __anonenum_POWER_ACTION_11 POWER_ACTION;
enum _DEVICE_POWER_STATE {
  PowerDeviceUnspecified = 0,
  PowerDeviceD0 = 1,
  PowerDeviceD1 = 2,
  PowerDeviceD2 = 3,
  PowerDeviceD3 = 4,
  PowerDeviceMaximum = 5
};
typedef enum _DEVICE_POWER_STATE DEVICE_POWER_STATE;
union _POWER_STATE {
  SYSTEM_POWER_STATE SystemState;
  DEVICE_POWER_STATE DeviceState;
};
typedef union _POWER_STATE POWER_STATE;
enum _POWER_STATE_TYPE { SystemPowerState = 0, DevicePowerState = 1 };
typedef enum _POWER_STATE_TYPE POWER_STATE_TYPE;
struct _KSYSTEM_TIME {
  ULONG LowPart;
  LONG High1Time;
  LONG High2Time;
};
typedef struct _KSYSTEM_TIME KSYSTEM_TIME;
enum _ALTERNATIVE_ARCHITECTURE_TYPE {
  StandardDesign = 0,
  NEC98x86 = 1,
  EndAlternatives = 2
};
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ALTERNATIVE_ARCHITECTURE_TYPE;
struct _KUSER_SHARED_DATA {
  ULONG volatile TickCountLow;
  ULONG TickCountMultiplier;
  KSYSTEM_TIME volatile InterruptTime;
  KSYSTEM_TIME volatile SystemTime;
  KSYSTEM_TIME volatile TimeZoneBias;
  USHORT ImageNumberLow;
  USHORT ImageNumberHigh;
  WCHAR NtSystemRoot[260];
  ULONG MaxStackTraceDepth;
  ULONG CryptoExponent;
  ULONG TimeZoneId;
  ULONG Reserved2[8];
  NT_PRODUCT_TYPE NtProductType;
  BOOLEAN ProductTypeIsValid;
  ULONG NtMajorVersion;
  ULONG NtMinorVersion;
  BOOLEAN ProcessorFeatures[64];
  ULONG Reserved1;
  ULONG Reserved3;
  ULONG volatile TimeSlip;
  ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
  LARGE_INTEGER SystemExpirationDate;
  ULONG SuiteMask;
  BOOLEAN KdDebuggerEnabled;
};
typedef struct _KUSER_SHARED_DATA KUSER_SHARED_DATA;
typedef PVOID PASSIGNED_RESOURCE;
#pragma pack(push, 4)
struct __anonstruct_Generic_16 {
  PHYSICAL_ADDRESS Start;
  ULONG Length;
};
struct __anonstruct_Port_17 {
  PHYSICAL_ADDRESS Start;
  ULONG Length;
};
struct __anonstruct_Interrupt_18 {
  ULONG Level;
  ULONG Vector;
  ULONG Affinity;
};
struct __anonstruct_Memory_19 {
  PHYSICAL_ADDRESS Start;
  ULONG Length;
};
struct __anonstruct_Dma_20 {
  ULONG Channel;
  ULONG Port;
  ULONG Reserved1;
};
struct __anonstruct_DevicePrivate_21 {
  ULONG Data[3];
};
struct __anonstruct_BusNumber_22 {
  ULONG Start;
  ULONG Length;
  ULONG Reserved;
};
struct __anonstruct_DeviceSpecificData_23 {
  ULONG DataSize;
  ULONG Reserved1;
  ULONG Reserved2;
};
union __anonunion_u_15 {
  struct __anonstruct_Generic_16 Generic;
  struct __anonstruct_Port_17 Port;
  struct __anonstruct_Interrupt_18 Interrupt;
  struct __anonstruct_Memory_19 Memory;
  struct __anonstruct_Dma_20 Dma;
  struct __anonstruct_DevicePrivate_21 DevicePrivate;
  struct __anonstruct_BusNumber_22 BusNumber;
  struct __anonstruct_DeviceSpecificData_23 DeviceSpecificData;
};
struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
  UCHAR Type;
  UCHAR ShareDisposition;
  USHORT Flags;
  union __anonunion_u_15 u;
};
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR CM_PARTIAL_RESOURCE_DESCRIPTOR;
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#pragma pack(pop)
struct _CM_PARTIAL_RESOURCE_LIST {
  USHORT Version;
  USHORT Revision;
  ULONG Count;
  CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
};
typedef struct _CM_PARTIAL_RESOURCE_LIST CM_PARTIAL_RESOURCE_LIST;
struct _CM_FULL_RESOURCE_DESCRIPTOR {
  INTERFACE_TYPE InterfaceType;
  ULONG BusNumber;
  CM_PARTIAL_RESOURCE_LIST PartialResourceList;
};
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR CM_FULL_RESOURCE_DESCRIPTOR;
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR *PCM_FULL_RESOURCE_DESCRIPTOR;
struct _CM_RESOURCE_LIST {
  ULONG Count;
  CM_FULL_RESOURCE_DESCRIPTOR List[1];
};
typedef struct _CM_RESOURCE_LIST *PCM_RESOURCE_LIST;
#pragma pack(push, 1)
#pragma pack(pop)
struct _CM_FLOPPY_DEVICE_DATA {
  USHORT Version;
  USHORT Revision;
  CHAR Size[8];
  ULONG MaxDensity;
  ULONG MountDensity;
  UCHAR StepRateHeadUnloadTime;
  UCHAR HeadLoadTime;
  UCHAR MotorOffTime;
  UCHAR SectorLengthCode;
  UCHAR SectorPerTrack;
  UCHAR ReadWriteGapLength;
  UCHAR DataTransferLength;
  UCHAR FormatGapLength;
  UCHAR FormatFillCharacter;
  UCHAR HeadSettleTime;
  UCHAR MotorSettleTime;
  UCHAR MaximumTrackValue;
  UCHAR DataTransferRate;
};
typedef struct _CM_FLOPPY_DEVICE_DATA *PCM_FLOPPY_DEVICE_DATA;
struct __anonstruct_Port_25 {
  ULONG Length;
  ULONG Alignment;
  PHYSICAL_ADDRESS MinimumAddress;
  PHYSICAL_ADDRESS MaximumAddress;
};
struct __anonstruct_Memory_26 {
  ULONG Length;
  ULONG Alignment;
  PHYSICAL_ADDRESS MinimumAddress;
  PHYSICAL_ADDRESS MaximumAddress;
};
struct __anonstruct_Interrupt_27 {
  ULONG MinimumVector;
  ULONG MaximumVector;
};
struct __anonstruct_Dma_28 {
  ULONG MinimumChannel;
  ULONG MaximumChannel;
};
struct __anonstruct_Generic_29 {
  ULONG Length;
  ULONG Alignment;
  PHYSICAL_ADDRESS MinimumAddress;
  PHYSICAL_ADDRESS MaximumAddress;
};
struct __anonstruct_DevicePrivate_30 {
  ULONG Data[3];
};
struct __anonstruct_BusNumber_31 {
  ULONG Length;
  ULONG MinBusNumber;
  ULONG MaxBusNumber;
  ULONG Reserved;
};
struct __anonstruct_AssignedResource_32 {
  PASSIGNED_RESOURCE AssignedResource;
};
struct __anonstruct_SubAllocateFrom_33 {
  UCHAR Type;
  UCHAR Reserved[3];
  PASSIGNED_RESOURCE AssignedResource;
  PHYSICAL_ADDRESS Transformation;
};
struct __anonstruct_ConfigData_34 {
  ULONG Priority;
  ULONG Reserved1;
  ULONG Reserved2;
};
union __anonunion_u_24 {
  struct __anonstruct_Port_25 Port;
  struct __anonstruct_Memory_26 Memory;
  struct __anonstruct_Interrupt_27 Interrupt;
  struct __anonstruct_Dma_28 Dma;
  struct __anonstruct_Generic_29 Generic;
  struct __anonstruct_DevicePrivate_30 DevicePrivate;
  struct __anonstruct_BusNumber_31 BusNumber;
  struct __anonstruct_AssignedResource_32 AssignedResource;
  struct __anonstruct_SubAllocateFrom_33 SubAllocateFrom;
  struct __anonstruct_ConfigData_34 ConfigData;
};
struct _IO_RESOURCE_DESCRIPTOR {
  UCHAR Option;
  UCHAR Type;
  UCHAR ShareDisposition;
  UCHAR Spare1;
  USHORT Flags;
  USHORT Spare2;
  union __anonunion_u_24 u;
};
typedef struct _IO_RESOURCE_DESCRIPTOR IO_RESOURCE_DESCRIPTOR;
struct _IO_RESOURCE_LIST {
  USHORT Version;
  USHORT Revision;
  ULONG Count;
  IO_RESOURCE_DESCRIPTOR Descriptors[1];
};
typedef struct _IO_RESOURCE_LIST IO_RESOURCE_LIST;
struct _IO_RESOURCE_REQUIREMENTS_LIST {
  ULONG ListSize;
  INTERFACE_TYPE InterfaceType;
  ULONG BusNumber;
  ULONG SlotNumber;
  ULONG Reserved[3];
  ULONG AlternativeLists;
  IO_RESOURCE_LIST List[1];
};
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST *PIO_RESOURCE_REQUIREMENTS_LIST;
enum _CONFIGURATION_TYPE {
  ArcSystem = 0,
  CentralProcessor = 1,
  FloatingPointProcessor = 2,
  PrimaryIcache = 3,
  PrimaryDcache = 4,
  SecondaryIcache = 5,
  SecondaryDcache = 6,
  SecondaryCache = 7,
  EisaAdapter = 8,
  TcAdapter = 9,
  ScsiAdapter = 10,
  DtiAdapter = 11,
  MultiFunctionAdapter = 12,
  DiskController = 13,
  TapeController = 14,
  CdromController = 15,
  WormController = 16,
  SerialController = 17,
  NetworkController = 18,
  DisplayController = 19,
  ParallelController = 20,
  PointerController = 21,
  KeyboardController = 22,
  AudioController = 23,
  OtherController = 24,
  DiskPeripheral = 25,
  FloppyDiskPeripheral = 26,
  TapePeripheral = 27,
  ModemPeripheral = 28,
  MonitorPeripheral = 29,
  PrinterPeripheral = 30,
  PointerPeripheral = 31,
  KeyboardPeripheral = 32,
  TerminalPeripheral = 33,
  OtherPeripheral = 34,
  LinePeripheral = 35,
  NetworkPeripheral = 36,
  SystemMemory = 37,
  DockingInformation = 38,
  RealModeIrqRoutingTable = 39,
  MaximumType = 40
};
typedef enum _CONFIGURATION_TYPE CONFIGURATION_TYPE;
typedef enum _CONFIGURATION_TYPE *PCONFIGURATION_TYPE;
enum _KWAIT_REASON {
  Executive = 0,
  FreePage = 1,
  PageIn = 2,
  PoolAllocation = 3,
  DelayExecution = 4,
  Suspended = 5,
  UserRequest = 6,
  WrExecutive = 7,
  WrFreePage = 8,
  WrPageIn = 9,
  WrPoolAllocation = 10,
  WrDelayExecution = 11,
  WrSuspended = 12,
  WrUserRequest = 13,
  WrEventPair = 14,
  WrQueue = 15,
  WrLpcReceive = 16,
  WrLpcReply = 17,
  WrVirtualMemory = 18,
  WrPageOut = 19,
  WrRendezvous = 20,
  Spare2 = 21,
  Spare3 = 22,
  Spare4 = 23,
  Spare5 = 24,
  Spare6 = 25,
  WrKernel = 26,
  MaximumWaitReason = 27
};
typedef enum _KWAIT_REASON KWAIT_REASON;
struct _DISPATCHER_HEADER {
  UCHAR Type;
  UCHAR Absolute;
  UCHAR Size;
  UCHAR Inserted;
  LONG SignalState;
  LIST_ENTRY WaitListHead;
};
typedef struct _DISPATCHER_HEADER DISPATCHER_HEADER;
struct _KDEVICE_QUEUE {
  CSHORT Type;
  CSHORT Size;
  LIST_ENTRY DeviceListHead;
  KSPIN_LOCK Lock;
  BOOLEAN Busy;
};
typedef struct _KDEVICE_QUEUE KDEVICE_QUEUE;
struct _KDEVICE_QUEUE_ENTRY {
  LIST_ENTRY DeviceListEntry;
  ULONG SortKey;
  BOOLEAN Inserted;
};
typedef struct _KDEVICE_QUEUE_ENTRY KDEVICE_QUEUE_ENTRY;
struct _KEVENT {
  DISPATCHER_HEADER Header;
};
typedef struct _KEVENT KEVENT;
typedef struct _KEVENT *PKEVENT;
typedef struct _KEVENT *PRKEVENT;
struct _KSEMAPHORE {
  DISPATCHER_HEADER Header;
  LONG Limit;
};
typedef struct _KSEMAPHORE KSEMAPHORE;
typedef struct _KSEMAPHORE *PKSEMAPHORE;
typedef struct _KSEMAPHORE *PRKSEMAPHORE;
enum _MEMORY_CACHING_TYPE {
  MmNonCached = 0,
  MmCached = 1,
  MmWriteCombined = 2,
  MmHardwareCoherentCached = 3,
  MmNonCachedUnordered = 4,
  MmUSWCCached = 5,
  MmMaximumCacheType = 6
};
typedef enum _MEMORY_CACHING_TYPE MEMORY_CACHING_TYPE;
enum _POOL_TYPE {
  NonPagedPool = 0,
  PagedPool = 1,
  NonPagedPoolMustSucceed = 2,
  DontUseThisType = 3,
  NonPagedPoolCacheAligned = 4,
  PagedPoolCacheAligned = 5,
  NonPagedPoolCacheAlignedMustS = 6,
  MaxPoolType = 7,
  NonPagedPoolSession = 32,
  PagedPoolSession = 33,
  NonPagedPoolMustSucceedSession = 34,
  DontUseThisTypeSession = 35,
  NonPagedPoolCacheAlignedSession = 36,
  PagedPoolCacheAlignedSession = 37,
  NonPagedPoolCacheAlignedMustSSession = 38
};
typedef enum _POOL_TYPE POOL_TYPE;
struct _FAST_MUTEX {
  LONG Count;
  PKTHREAD Owner;
  ULONG Contention;
  KEVENT Event;
  ULONG OldIrql;
};
typedef struct _FAST_MUTEX FAST_MUTEX;
typedef struct _FAST_MUTEX *PFAST_MUTEX;
typedef ULONG_PTR ERESOURCE_THREAD;
union __anonunion____missing_field_name_38 {
  LONG OwnerCount;
  ULONG TableSize;
};
struct _OWNER_ENTRY {
  ERESOURCE_THREAD OwnerThread;
  union __anonunion____missing_field_name_38 __annonCompField10;
};
typedef struct _OWNER_ENTRY OWNER_ENTRY;
typedef struct _OWNER_ENTRY *POWNER_ENTRY;
union __anonunion____missing_field_name_39 {
  PVOID Address;
  ULONG_PTR CreatorBackTraceIndex;
};
struct _ERESOURCE {
  LIST_ENTRY SystemResourcesList;
  POWNER_ENTRY OwnerTable;
  SHORT ActiveCount;
  USHORT Flag;
  PKSEMAPHORE SharedWaiters;
  PKEVENT ExclusiveWaiters;
  OWNER_ENTRY OwnerThreads[2];
  ULONG ContentionCount;
  USHORT NumberOfSharedWaiters;
  USHORT NumberOfExclusiveWaiters;
  union __anonunion____missing_field_name_39 __annonCompField11;
  KSPIN_LOCK SpinLock;
};
enum _LOCK_OPERATION {
  IoReadAccess = 0,
  IoWriteAccess = 1,
  IoModifyAccess = 2
};
typedef enum _LOCK_OPERATION LOCK_OPERATION;
enum _MM_PAGE_PRIORITY {
  LowPagePriority = 0,
  NormalPagePriority = 16,
  HighPagePriority = 32
};
typedef enum _MM_PAGE_PRIORITY MM_PAGE_PRIORITY;
struct _DRIVER_OBJECT;
struct _DRIVER_OBJECT;
struct _SECURITY_SUBJECT_CONTEXT {
  PACCESS_TOKEN ClientToken;
  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
  PACCESS_TOKEN PrimaryToken;
  PVOID ProcessAuditId;
};
typedef struct _SECURITY_SUBJECT_CONTEXT SECURITY_SUBJECT_CONTEXT;
struct _INITIAL_PRIVILEGE_SET {
  ULONG PrivilegeCount;
  ULONG Control;
  LUID_AND_ATTRIBUTES Privilege[3];
};
typedef struct _INITIAL_PRIVILEGE_SET INITIAL_PRIVILEGE_SET;
union __anonunion_Privileges_40 {
  INITIAL_PRIVILEGE_SET InitialPrivilegeSet;
  PRIVILEGE_SET PrivilegeSet;
};
struct _ACCESS_STATE {
  LUID OperationID;
  BOOLEAN SecurityEvaluated;
  BOOLEAN GenerateAudit;
  BOOLEAN GenerateOnClose;
  BOOLEAN PrivilegesAllocated;
  ULONG Flags;
  ACCESS_MASK RemainingDesiredAccess;
  ACCESS_MASK PreviouslyGrantedAccess;
  ACCESS_MASK OriginalDesiredAccess;
  SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
  PSECURITY_DESCRIPTOR SecurityDescriptor;
  PVOID AuxData;
  union __anonunion_Privileges_40 Privileges;
  BOOLEAN AuditPrivileges;
  UNICODE_STRING ObjectName;
  UNICODE_STRING ObjectTypeName;
};
typedef struct _ACCESS_STATE *PACCESS_STATE;
struct _DEVICE_OBJECT;
struct _DEVICE_OBJECT;
struct _DRIVER_OBJECT;
struct _FILE_OBJECT;
struct _FILE_OBJECT;
struct _IRP;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;
struct _SCSI_REQUEST_BLOCK;
typedef NTSTATUS (*PDRIVER_DISPATCH)(struct _DEVICE_OBJECT *DeviceObject,
                                     struct _IRP *Irp);
struct _COMPRESSED_DATA_INFO;
struct _FAST_IO_DISPATCH {
  ULONG SizeOfFastIoDispatch;
  BOOLEAN(*FastIoCheckIfPossible)
  (struct _FILE_OBJECT *FileObject, PLARGE_INTEGER FileOffset, ULONG Length,
   BOOLEAN Wait, ULONG LockKey, BOOLEAN CheckForReadOperation,
   PIO_STATUS_BLOCK IoStatus, struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*FastIoRead)
  (struct _FILE_OBJECT *FileObject, PLARGE_INTEGER FileOffset, ULONG Length,
   BOOLEAN Wait, ULONG LockKey, PVOID Buffer, PIO_STATUS_BLOCK IoStatus,
   struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*FastIoWrite)
  (struct _FILE_OBJECT *FileObject, PLARGE_INTEGER FileOffset, ULONG Length,
   BOOLEAN Wait, ULONG LockKey, PVOID Buffer, PIO_STATUS_BLOCK IoStatus,
   struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*FastIoQueryBasicInfo)
  (struct _FILE_OBJECT *FileObject, BOOLEAN Wait,
   PFILE_BASIC_INFORMATION Buffer, PIO_STATUS_BLOCK IoStatus,
   struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*FastIoQueryStandardInfo)
  (struct _FILE_OBJECT *FileObject, BOOLEAN Wait,
   PFILE_STANDARD_INFORMATION Buffer, PIO_STATUS_BLOCK IoStatus,
   struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*FastIoLock)
  (struct _FILE_OBJECT *FileObject, PLARGE_INTEGER FileOffset,
   PLARGE_INTEGER Length, PEPROCESS ProcessId, ULONG Key,
   BOOLEAN FailImmediately, BOOLEAN ExclusiveLock, PIO_STATUS_BLOCK IoStatus,
   struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*FastIoUnlockSingle)
  (struct _FILE_OBJECT *FileObject, PLARGE_INTEGER FileOffset,
   PLARGE_INTEGER Length, PEPROCESS ProcessId, ULONG Key,
   PIO_STATUS_BLOCK IoStatus, struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*FastIoUnlockAll)
  (struct _FILE_OBJECT *FileObject, PEPROCESS ProcessId,
   PIO_STATUS_BLOCK IoStatus, struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*FastIoUnlockAllByKey)
  (struct _FILE_OBJECT *FileObject, PVOID ProcessId, ULONG Key,
   PIO_STATUS_BLOCK IoStatus, struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*FastIoDeviceControl)
  (struct _FILE_OBJECT *FileObject, BOOLEAN Wait, PVOID InputBuffer,
   ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength,
   ULONG IoControlCode, PIO_STATUS_BLOCK IoStatus,
   struct _DEVICE_OBJECT *DeviceObject);
  void (*AcquireFileForNtCreateSection)(struct _FILE_OBJECT *FileObject);
  void (*ReleaseFileForNtCreateSection)(struct _FILE_OBJECT *FileObject);
  void (*FastIoDetachDevice)(struct _DEVICE_OBJECT *SourceDevice,
                             struct _DEVICE_OBJECT *TargetDevice);
  BOOLEAN(*FastIoQueryNetworkOpenInfo)
  (struct _FILE_OBJECT *FileObject, BOOLEAN Wait,
   struct _FILE_NETWORK_OPEN_INFORMATION *Buffer,
   struct _IO_STATUS_BLOCK *IoStatus, struct _DEVICE_OBJECT *DeviceObject);
  NTSTATUS(*AcquireForModWrite)
  (struct _FILE_OBJECT *FileObject, PLARGE_INTEGER EndingOffset,
   struct _ERESOURCE **ResourceToRelease, struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*MdlRead)
  (struct _FILE_OBJECT *FileObject, PLARGE_INTEGER FileOffset, ULONG Length,
   ULONG LockKey, PMDL *MdlChain, PIO_STATUS_BLOCK IoStatus,
   struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*MdlReadComplete)
  (struct _FILE_OBJECT *FileObject, PMDL MdlChain,
   struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*PrepareMdlWrite)
  (struct _FILE_OBJECT *FileObject, PLARGE_INTEGER FileOffset, ULONG Length,
   ULONG LockKey, PMDL *MdlChain, PIO_STATUS_BLOCK IoStatus,
   struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*MdlWriteComplete)
  (struct _FILE_OBJECT *FileObject, PLARGE_INTEGER FileOffset, PMDL MdlChain,
   struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*FastIoReadCompressed)
  (struct _FILE_OBJECT *FileObject, PLARGE_INTEGER FileOffset, ULONG Length,
   ULONG LockKey, PVOID Buffer, PMDL *MdlChain, PIO_STATUS_BLOCK IoStatus,
   struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
   ULONG CompressedDataInfoLength, struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*FastIoWriteCompressed)
  (struct _FILE_OBJECT *FileObject, PLARGE_INTEGER FileOffset, ULONG Length,
   ULONG LockKey, PVOID Buffer, PMDL *MdlChain, PIO_STATUS_BLOCK IoStatus,
   struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
   ULONG CompressedDataInfoLength, struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*MdlReadCompleteCompressed)
  (struct _FILE_OBJECT *FileObject, PMDL MdlChain,
   struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*MdlWriteCompleteCompressed)
  (struct _FILE_OBJECT *FileObject, PLARGE_INTEGER FileOffset, PMDL MdlChain,
   struct _DEVICE_OBJECT *DeviceObject);
  BOOLEAN(*FastIoQueryOpen)
  (struct _IRP *Irp, PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
   struct _DEVICE_OBJECT *DeviceObject);
  NTSTATUS(*ReleaseForModWrite)
  (struct _FILE_OBJECT *FileObject, struct _ERESOURCE *ResourceToRelease,
   struct _DEVICE_OBJECT *DeviceObject);
  NTSTATUS(*AcquireForCcFlush)
  (struct _FILE_OBJECT *FileObject, struct _DEVICE_OBJECT *DeviceObject);
  NTSTATUS(*ReleaseForCcFlush)
  (struct _FILE_OBJECT *FileObject, struct _DEVICE_OBJECT *DeviceObject);
};
typedef struct _FAST_IO_DISPATCH *PFAST_IO_DISPATCH;
enum _IO_ALLOCATION_ACTION {
  KeepObject = 1,
  DeallocateObject = 2,
  DeallocateObjectKeepRegisters = 3
};
typedef enum _IO_ALLOCATION_ACTION IO_ALLOCATION_ACTION;
struct _IO_SECURITY_CONTEXT {
  PSECURITY_QUALITY_OF_SERVICE SecurityQos;
  PACCESS_STATE AccessState;
  ACCESS_MASK DesiredAccess;
  ULONG FullCreateOptions;
};
typedef struct _IO_SECURITY_CONTEXT *PIO_SECURITY_CONTEXT;
struct _VPB {
  CSHORT Type;
  CSHORT Size;
  USHORT Flags;
  USHORT VolumeLabelLength;
  struct _DEVICE_OBJECT *DeviceObject;
  struct _DEVICE_OBJECT *RealDevice;
  ULONG SerialNumber;
  ULONG ReferenceCount;
  WCHAR VolumeLabel[(32U * sizeof(WCHAR)) / sizeof(WCHAR)];
};
typedef struct _VPB *PVPB;
struct _WAIT_CONTEXT_BLOCK {
  KDEVICE_QUEUE_ENTRY WaitQueueEntry;
  IO_ALLOCATION_ACTION(*DeviceRoutine)
  (struct _DEVICE_OBJECT *DeviceObject, struct _IRP *Irp, PVOID MapRegisterBase,
   PVOID Context);
  PVOID DeviceContext;
  ULONG NumberOfMapRegisters;
  PVOID DeviceObject;
  PVOID CurrentIrp;
  PKDPC BufferChainingDpc;
};
typedef struct _WAIT_CONTEXT_BLOCK WAIT_CONTEXT_BLOCK;
union __anonunion_Queue_43 {
  LIST_ENTRY ListEntry;
  WAIT_CONTEXT_BLOCK Wcb;
};
struct _DEVOBJ_EXTENSION;
struct _DEVICE_OBJECT {
  CSHORT Type;
  USHORT Size;
  LONG ReferenceCount;
  struct _DRIVER_OBJECT *DriverObject;
  struct _DEVICE_OBJECT *NextDevice;
  struct _DEVICE_OBJECT *AttachedDevice;
  struct _IRP *CurrentIrp;
  PIO_TIMER Timer;
  ULONG Flags;
  ULONG Characteristics;
  PVPB Vpb;
  PVOID DeviceExtension;
  ULONG DeviceType;
  CCHAR StackSize;
  union __anonunion_Queue_43 Queue;
  ULONG AlignmentRequirement;
  KDEVICE_QUEUE DeviceQueue;
  KDPC Dpc;
  ULONG ActiveThreadCount;
  PSECURITY_DESCRIPTOR SecurityDescriptor;
  KEVENT DeviceLock;
  USHORT SectorSize;
  USHORT Spare1;
  struct _DEVOBJ_EXTENSION *DeviceObjectExtension;
  PVOID Reserved;
};
typedef struct _DEVICE_OBJECT DEVICE_OBJECT;
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT;
struct _DEVOBJ_EXTENSION {
  CSHORT Type;
  USHORT Size;
  PDEVICE_OBJECT DeviceObject;
};
struct _DRIVER_EXTENSION {
  struct _DRIVER_OBJECT *DriverObject;
  NTSTATUS(*AddDevice)
  (struct _DRIVER_OBJECT *DriverObject,
   struct _DEVICE_OBJECT *PhysicalDeviceObject);
  ULONG Count;
  UNICODE_STRING ServiceKeyName;
};
typedef struct _DRIVER_EXTENSION *PDRIVER_EXTENSION;
struct _DRIVER_OBJECT {
  CSHORT Type;
  CSHORT Size;
  PDEVICE_OBJECT DeviceObject;
  ULONG Flags;
  PVOID DriverStart;
  ULONG DriverSize;
  PVOID DriverSection;
  PDRIVER_EXTENSION DriverExtension;
  UNICODE_STRING DriverName;
  PUNICODE_STRING HardwareDatabase;
  PFAST_IO_DISPATCH FastIoDispatch;
  NTSTATUS(*DriverInit)
  (struct _DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath);
  void (*DriverStartIo)(struct _DEVICE_OBJECT *DeviceObject, struct _IRP *Irp);
  void (*DriverUnload)(struct _DRIVER_OBJECT *DriverObject);
  PDRIVER_DISPATCH MajorFunction[28];
};
typedef struct _DRIVER_OBJECT DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;
struct _SECTION_OBJECT_POINTERS {
  PVOID DataSectionObject;
  PVOID SharedCacheMap;
  PVOID ImageSectionObject;
};
typedef struct _SECTION_OBJECT_POINTERS SECTION_OBJECT_POINTERS;
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;
struct _IO_COMPLETION_CONTEXT {
  PVOID Port;
  PVOID Key;
};
typedef struct _IO_COMPLETION_CONTEXT *PIO_COMPLETION_CONTEXT;
struct _FILE_OBJECT {
  CSHORT Type;
  CSHORT Size;
  PDEVICE_OBJECT DeviceObject;
  PVPB Vpb;
  PVOID FsContext;
  PVOID FsContext2;
  PSECTION_OBJECT_POINTERS SectionObjectPointer;
  PVOID PrivateCacheMap;
  NTSTATUS FinalStatus;
  struct _FILE_OBJECT *RelatedFileObject;
  BOOLEAN LockOperation;
  BOOLEAN DeletePending;
  BOOLEAN ReadAccess;
  BOOLEAN WriteAccess;
  BOOLEAN DeleteAccess;
  BOOLEAN SharedRead;
  BOOLEAN SharedWrite;
  BOOLEAN SharedDelete;
  ULONG Flags;
  UNICODE_STRING FileName;
  LARGE_INTEGER CurrentByteOffset;
  ULONG Waiters;
  ULONG Busy;
  PVOID LastLock;
  KEVENT Lock;
  KEVENT Event;
  PIO_COMPLETION_CONTEXT CompletionContext;
};
typedef struct _FILE_OBJECT *PFILE_OBJECT;
union __anonunion_AssociatedIrp_44 {
  struct _IRP *MasterIrp;
  LONG IrpCount;
  PVOID SystemBuffer;
};
struct __anonstruct_AsynchronousParameters_46 {
  void (*UserApcRoutine)(PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock,
                         ULONG Reserved);
  PVOID UserApcContext;
};
union __anonunion_Overlay_45 {
  struct __anonstruct_AsynchronousParameters_46 AsynchronousParameters;
  LARGE_INTEGER AllocationSize;
};
struct __anonstruct____missing_field_name_50 {
  PVOID DriverContext[4];
};
union __anonunion____missing_field_name_49 {
  KDEVICE_QUEUE_ENTRY DeviceQueueEntry;
  struct __anonstruct____missing_field_name_50 __annonCompField14;
};
struct _IO_STACK_LOCATION;
union __anonunion____missing_field_name_52 {
  struct _IO_STACK_LOCATION *CurrentStackLocation;
  ULONG PacketType;
};
struct __anonstruct____missing_field_name_51 {
  LIST_ENTRY ListEntry;
  union __anonunion____missing_field_name_52 __annonCompField16;
};
struct __anonstruct_Overlay_48 {
  union __anonunion____missing_field_name_49 __annonCompField15;
  PETHREAD Thread;
  PCHAR AuxiliaryBuffer;
  struct __anonstruct____missing_field_name_51 __annonCompField17;
  PFILE_OBJECT OriginalFileObject;
};
union __anonunion_Tail_47 {
  struct __anonstruct_Overlay_48 Overlay;
  KAPC Apc;
  PVOID CompletionKey;
};
struct _IRP {
  CSHORT Type;
  USHORT Size;
  PMDL MdlAddress;
  ULONG Flags;
  union __anonunion_AssociatedIrp_44 AssociatedIrp;
  LIST_ENTRY ThreadListEntry;
  IO_STATUS_BLOCK IoStatus;
  KPROCESSOR_MODE RequestorMode;
  BOOLEAN PendingReturned;
  CHAR StackCount;
  CHAR CurrentLocation;
  BOOLEAN Cancel;
  KIRQL CancelIrql;
  CCHAR ApcEnvironment;
  UCHAR AllocationFlags;
  PIO_STATUS_BLOCK UserIosb;
  PKEVENT UserEvent;
  union __anonunion_Overlay_45 Overlay;
  void (*CancelRoutine)(struct _DEVICE_OBJECT *DeviceObject, struct _IRP *Irp);
  PVOID UserBuffer;
  union __anonunion_Tail_47 Tail;
};
typedef struct _IRP IRP;
typedef struct _IRP *PIRP;
enum _DEVICE_RELATION_TYPE {
  BusRelations = 0,
  EjectionRelations = 1,
  PowerRelations = 2,
  RemovalRelations = 3,
  TargetDeviceRelation = 4
};
typedef enum _DEVICE_RELATION_TYPE DEVICE_RELATION_TYPE;
enum _DEVICE_USAGE_NOTIFICATION_TYPE {
  DeviceUsageTypeUndefined = 0,
  DeviceUsageTypePaging = 1,
  DeviceUsageTypeHibernation = 2,
  DeviceUsageTypeDumpFile = 3
};
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE DEVICE_USAGE_NOTIFICATION_TYPE;
struct _INTERFACE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  void (*InterfaceReference)(PVOID Context);
  void (*InterfaceDereference)(PVOID Context);
};
typedef struct _INTERFACE *PINTERFACE;
struct _DEVICE_CAPABILITIES {
  USHORT Size;
  USHORT Version;
  ULONG DeviceD1 : 1;
  ULONG DeviceD2 : 1;
  ULONG LockSupported : 1;
  ULONG EjectSupported : 1;
  ULONG Removable : 1;
  ULONG DockDevice : 1;
  ULONG UniqueID : 1;
  ULONG SilentInstall : 1;
  ULONG RawDeviceOK : 1;
  ULONG SurpriseRemovalOK : 1;
  ULONG WakeFromD0 : 1;
  ULONG WakeFromD1 : 1;
  ULONG WakeFromD2 : 1;
  ULONG WakeFromD3 : 1;
  ULONG HardwareDisabled : 1;
  ULONG NonDynamic : 1;
  ULONG WarmEjectSupported : 1;
  ULONG Reserved : 15;
  ULONG Address;
  ULONG UINumber;
  DEVICE_POWER_STATE DeviceState[7];
  SYSTEM_POWER_STATE SystemWake;
  DEVICE_POWER_STATE DeviceWake;
  ULONG D1Latency;
  ULONG D2Latency;
  ULONG D3Latency;
};
typedef struct _DEVICE_CAPABILITIES *PDEVICE_CAPABILITIES;
struct _POWER_SEQUENCE {
  ULONG SequenceD1;
  ULONG SequenceD2;
  ULONG SequenceD3;
};
typedef struct _POWER_SEQUENCE *PPOWER_SEQUENCE;
enum __anonenum_BUS_QUERY_ID_TYPE_53 {
  BusQueryDeviceID = 0,
  BusQueryHardwareIDs = 1,
  BusQueryCompatibleIDs = 2,
  BusQueryInstanceID = 3,
  BusQueryDeviceSerialNumber = 4
};
typedef enum __anonenum_BUS_QUERY_ID_TYPE_53 BUS_QUERY_ID_TYPE;
enum __anonenum_DEVICE_TEXT_TYPE_54 {
  DeviceTextDescription = 0,
  DeviceTextLocationInformation = 1
};
typedef enum __anonenum_DEVICE_TEXT_TYPE_54 DEVICE_TEXT_TYPE;
#pragma pack(push, 4)
struct __anonstruct_Create_56 {
  PIO_SECURITY_CONTEXT SecurityContext;
  ULONG Options;
  USHORT FileAttributes;
  USHORT ShareAccess;
  ULONG EaLength;
};
struct __anonstruct_Read_57 {
  ULONG Length;
  ULONG Key;
  LARGE_INTEGER ByteOffset;
};
struct __anonstruct_Write_58 {
  ULONG Length;
  ULONG Key;
  LARGE_INTEGER ByteOffset;
};
struct __anonstruct_QueryFile_59 {
  ULONG Length;
  FILE_INFORMATION_CLASS FileInformationClass;
};
struct __anonstruct____missing_field_name_62 {
  BOOLEAN ReplaceIfExists;
  BOOLEAN AdvanceOnly;
};
union __anonunion____missing_field_name_61 {
  struct __anonstruct____missing_field_name_62 __annonCompField18;
  ULONG ClusterCount;
  HANDLE DeleteHandle;
};
struct __anonstruct_SetFile_60 {
  ULONG Length;
  FILE_INFORMATION_CLASS FileInformationClass;
  PFILE_OBJECT FileObject;
  union __anonunion____missing_field_name_61 __annonCompField19;
};
struct __anonstruct_QueryVolume_63 {
  ULONG Length;
  FS_INFORMATION_CLASS FsInformationClass;
};
struct __anonstruct_DeviceIoControl_64 {
  ULONG OutputBufferLength;
  ULONG InputBufferLength;
  ULONG IoControlCode;
  PVOID Type3InputBuffer;
};
struct __anonstruct_QuerySecurity_65 {
  SECURITY_INFORMATION SecurityInformation;
  ULONG Length;
};
struct __anonstruct_SetSecurity_66 {
  SECURITY_INFORMATION SecurityInformation;
  PSECURITY_DESCRIPTOR SecurityDescriptor;
};
struct __anonstruct_MountVolume_67 {
  PVPB Vpb;
  PDEVICE_OBJECT DeviceObject;
};
struct __anonstruct_VerifyVolume_68 {
  PVPB Vpb;
  PDEVICE_OBJECT DeviceObject;
};
struct __anonstruct_Scsi_69 {
  struct _SCSI_REQUEST_BLOCK *Srb;
};
struct __anonstruct_QueryDeviceRelations_70 {
  DEVICE_RELATION_TYPE Type;
};
struct __anonstruct_QueryInterface_71 {
  GUID const *InterfaceType;
  USHORT Size;
  USHORT Version;
  PINTERFACE Interface;
  PVOID InterfaceSpecificData;
};
struct __anonstruct_DeviceCapabilities_72 {
  PDEVICE_CAPABILITIES Capabilities;
};
struct __anonstruct_FilterResourceRequirements_73 {
  PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;
};
struct __anonstruct_ReadWriteConfig_74 {
  ULONG WhichSpace;
  PVOID Buffer;
  ULONG Offset;
  ULONG Length;
};
struct __anonstruct_SetLock_75 {
  BOOLEAN Lock;
};
struct __anonstruct_QueryId_76 {
  BUS_QUERY_ID_TYPE IdType;
};
struct __anonstruct_QueryDeviceText_77 {
  DEVICE_TEXT_TYPE DeviceTextType;
  LCID LocaleId;
};
struct __anonstruct_UsageNotification_78 {
  BOOLEAN InPath;
  BOOLEAN Reserved[3];
  DEVICE_USAGE_NOTIFICATION_TYPE Type;
};
struct __anonstruct_WaitWake_79 {
  SYSTEM_POWER_STATE PowerState;
};
struct __anonstruct_PowerSequence_80 {
  PPOWER_SEQUENCE PowerSequence;
};
struct __anonstruct_Power_81 {
  ULONG SystemContext;
  POWER_STATE_TYPE Type;
  POWER_STATE State;
  POWER_ACTION ShutdownType;
};
struct __anonstruct_StartDevice_82 {
  PCM_RESOURCE_LIST AllocatedResources;
  PCM_RESOURCE_LIST AllocatedResourcesTranslated;
};
struct __anonstruct_WMI_83 {
  ULONG_PTR ProviderId;
  PVOID DataPath;
  ULONG BufferSize;
  PVOID Buffer;
};
struct __anonstruct_Others_84 {
  PVOID Argument1;
  PVOID Argument2;
  PVOID Argument3;
  PVOID Argument4;
};
union __anonunion_Parameters_55 {
  struct __anonstruct_Create_56 Create;
  struct __anonstruct_Read_57 Read;
  struct __anonstruct_Write_58 Write;
  struct __anonstruct_QueryFile_59 QueryFile;
  struct __anonstruct_SetFile_60 SetFile;
  struct __anonstruct_QueryVolume_63 QueryVolume;
  struct __anonstruct_DeviceIoControl_64 DeviceIoControl;
  struct __anonstruct_QuerySecurity_65 QuerySecurity;
  struct __anonstruct_SetSecurity_66 SetSecurity;
  struct __anonstruct_MountVolume_67 MountVolume;
  struct __anonstruct_VerifyVolume_68 VerifyVolume;
  struct __anonstruct_Scsi_69 Scsi;
  struct __anonstruct_QueryDeviceRelations_70 QueryDeviceRelations;
  struct __anonstruct_QueryInterface_71 QueryInterface;
  struct __anonstruct_DeviceCapabilities_72 DeviceCapabilities;
  struct __anonstruct_FilterResourceRequirements_73 FilterResourceRequirements;
  struct __anonstruct_ReadWriteConfig_74 ReadWriteConfig;
  struct __anonstruct_SetLock_75 SetLock;
  struct __anonstruct_QueryId_76 QueryId;
  struct __anonstruct_QueryDeviceText_77 QueryDeviceText;
  struct __anonstruct_UsageNotification_78 UsageNotification;
  struct __anonstruct_WaitWake_79 WaitWake;
  struct __anonstruct_PowerSequence_80 PowerSequence;
  struct __anonstruct_Power_81 Power;
  struct __anonstruct_StartDevice_82 StartDevice;
  struct __anonstruct_WMI_83 WMI;
  struct __anonstruct_Others_84 Others;
};
struct _IO_STACK_LOCATION {
  UCHAR MajorFunction;
  UCHAR MinorFunction;
  UCHAR Flags;
  UCHAR Control;
  union __anonunion_Parameters_55 Parameters;
  PDEVICE_OBJECT DeviceObject;
  PFILE_OBJECT FileObject;
  NTSTATUS(*CompletionRoutine)
  (PDEVICE_OBJECT DeviceObject, PIRP Irp, PVOID Context);
  PVOID Context;
};
typedef struct _IO_STACK_LOCATION IO_STACK_LOCATION;
typedef struct _IO_STACK_LOCATION *PIO_STACK_LOCATION;
#pragma pack(pop)
struct _CONFIGURATION_INFORMATION {
  ULONG DiskCount;
  ULONG FloppyCount;
  ULONG CdRomCount;
  ULONG TapeCount;
  ULONG ScsiPortCount;
  ULONG SerialCount;
  ULONG ParallelCount;
  BOOLEAN AtDiskPrimaryAddressClaimed;
  BOOLEAN AtDiskSecondaryAddressClaimed;
  ULONG Version;
  ULONG MediumChangerCount;
};
typedef struct _CONFIGURATION_INFORMATION CONFIGURATION_INFORMATION;
typedef struct _CONFIGURATION_INFORMATION *PCONFIGURATION_INFORMATION;
struct _OBJECT_HANDLE_INFORMATION {
  ULONG HandleAttributes;
  ACCESS_MASK GrantedAccess;
};
typedef struct _OBJECT_HANDLE_INFORMATION *POBJECT_HANDLE_INFORMATION;
enum _MEDIA_TYPE {
  Unknown = 0,
  F5_1Pt2_512 = 1,
  F3_1Pt44_512 = 2,
  F3_2Pt88_512 = 3,
  F3_20Pt8_512 = 4,
  F3_720_512 = 5,
  F5_360_512 = 6,
  F5_320_512 = 7,
  F5_320_1024 = 8,
  F5_180_512 = 9,
  F5_160_512 = 10,
  RemovableMedia = 11,
  FixedMedia = 12,
  F3_120M_512 = 13,
  F3_640_512 = 14,
  F5_640_512 = 15,
  F5_720_512 = 16,
  F3_1Pt2_512 = 17,
  F3_1Pt23_1024 = 18,
  F5_1Pt23_1024 = 19,
  F3_128Mb_512 = 20,
  F3_230Mb_512 = 21,
  F8_256_128 = 22
};
typedef enum _MEDIA_TYPE MEDIA_TYPE;
struct _FORMAT_PARAMETERS {
  MEDIA_TYPE MediaType;
  ULONG StartCylinderNumber;
  ULONG EndCylinderNumber;
  ULONG StartHeadNumber;
  ULONG EndHeadNumber;
};
typedef struct _FORMAT_PARAMETERS FORMAT_PARAMETERS;
typedef struct _FORMAT_PARAMETERS *PFORMAT_PARAMETERS;
typedef USHORT BAD_TRACK_NUMBER;
typedef USHORT *PBAD_TRACK_NUMBER;
struct _FORMAT_EX_PARAMETERS {
  MEDIA_TYPE MediaType;
  ULONG StartCylinderNumber;
  ULONG EndCylinderNumber;
  ULONG StartHeadNumber;
  ULONG EndHeadNumber;
  USHORT FormatGapLength;
  USHORT SectorsPerTrack;
  USHORT SectorNumber[1];
};
typedef struct _FORMAT_EX_PARAMETERS FORMAT_EX_PARAMETERS;
typedef struct _FORMAT_EX_PARAMETERS *PFORMAT_EX_PARAMETERS;
struct _DISK_GEOMETRY {
  LARGE_INTEGER Cylinders;
  MEDIA_TYPE MediaType;
  ULONG TracksPerCylinder;
  ULONG SectorsPerTrack;
  ULONG BytesPerSector;
};
typedef struct _DISK_GEOMETRY DISK_GEOMETRY;
typedef struct _DISK_GEOMETRY *PDISK_GEOMETRY;
#pragma pack(push, 1)
#pragma pack(pop)
#pragma pack(push, 1)
#pragma pack(pop)
#pragma pack(push, 1)
#pragma pack(pop)
#pragma pack(push, 1)
#pragma pack(pop)
#pragma pack(push, 1)
#pragma pack(pop)
struct _TRANSFER_BUFFER {
  PHYSICAL_ADDRESS Logical;
  PVOID Virtual;
};
typedef struct _TRANSFER_BUFFER TRANSFER_BUFFER;
struct _ACPI_FDI_DATA {
  ULONG DriveNumber;
  ULONG DeviceType;
  ULONG MaxCylinderNumber;
  ULONG MaxSectorNumber;
  ULONG MaxHeadNumber;
  ULONG StepRateHeadUnloadTime;
  ULONG HeadLoadTime;
  ULONG MotorOffTime;
  ULONG SectorLengthCode;
  ULONG SectorPerTrack;
  ULONG ReadWriteGapLength;
  ULONG DataTransferLength;
  ULONG FormatGapLength;
  ULONG FormatFillCharacter;
  ULONG HeadSettleTime;
  ULONG MotorSettleTime;
};
typedef struct _ACPI_FDI_DATA ACPI_FDI_DATA;
enum _ACPI_FDI_DEVICE_TYPE {
  CmosProblem = 0,
  Form525Capacity360 = 1,
  Form525Capacity1200 = 2,
  Form35Capacity720 = 3,
  Form35Capacity1440 = 4,
  Form35Capacity2880 = 5
};
struct _FDC_INFO {
  UCHAR FloppyControllerType;
  UCHAR SpeedsAvailable;
  ULONG AdapterBufferSize;
  INTERFACE_TYPE BusType;
  ULONG BusNumber;
  ULONG ControllerNumber;
  ULONG PeripheralNumber;
  ULONG UnitNumber;
  ULONG MaxTransferSize;
  BOOLEAN AcpiBios;
  BOOLEAN AcpiFdiSupported;
  ACPI_FDI_DATA AcpiFdiData;
  ULONG BufferCount;
  ULONG BufferSize;
  TRANSFER_BUFFER BufferAddress[];
};
typedef struct _FDC_INFO FDC_INFO;
typedef struct _FDC_INFO *PFDC_INFO;
struct _FDC_ENABLE_PARMS {
  UCHAR DriveOnValue;
  USHORT TimeToWait;
  BOOLEAN MotorStarted;
};
typedef struct _FDC_ENABLE_PARMS FDC_ENABLE_PARMS;
struct _FDC_DISK_CHANGE_PARMS {
  UCHAR DriveStatus;
  UCHAR DriveOnValue;
};
typedef struct _FDC_DISK_CHANGE_PARMS FDC_DISK_CHANGE_PARMS;
struct _ISSUE_FDC_COMMAND_PARMS {
  PUCHAR FifoInBuffer;
  PUCHAR FifoOutBuffer;
  PVOID IoHandle;
  ULONG IoOffset;
  ULONG TransferBytes;
  ULONG TimeOut;
};
typedef struct _ISSUE_FDC_COMMAND_PARMS ISSUE_FDC_COMMAND_PARMS;
struct _SET_HD_BIT_PARMS {
  BOOLEAN DriveType144MB;
  BOOLEAN Media144MB;
  BOOLEAN More120MB;
  UCHAR DeviceUnit;
  BOOLEAN ChangedHdBit;
};
typedef struct _SET_HD_BIT_PARMS SET_HD_BIT_PARMS;
struct _MOUNTDEV_NAME {
  USHORT NameLength;
  WCHAR Name[1];
};
typedef struct _MOUNTDEV_NAME MOUNTDEV_NAME;
typedef struct _MOUNTDEV_NAME *PMOUNTDEV_NAME;
struct _MOUNTDEV_UNIQUE_ID {
  USHORT UniqueIdLength;
  UCHAR UniqueId[1];
};
typedef struct _MOUNTDEV_UNIQUE_ID MOUNTDEV_UNIQUE_ID;
typedef struct _MOUNTDEV_UNIQUE_ID *PMOUNTDEV_UNIQUE_ID;
struct _MOUNTDEV_SUGGESTED_LINK_NAME {
  BOOLEAN UseOnlyIfThereAreNoOtherLinks;
  USHORT NameLength;
  WCHAR Name[1];
};
typedef struct _MOUNTDEV_SUGGESTED_LINK_NAME MOUNTDEV_SUGGESTED_LINK_NAME;
typedef struct _MOUNTDEV_SUGGESTED_LINK_NAME *PMOUNTDEV_SUGGESTED_LINK_NAME;
struct _BOOT_SECTOR_INFO {
  UCHAR JumpByte[1];
  UCHAR Ignore1[2];
  UCHAR OemData[8];
  UCHAR BytesPerSector[2];
  UCHAR Ignore2[6];
  UCHAR NumberOfSectors[2];
  UCHAR MediaByte[1];
  UCHAR Ignore3[2];
  UCHAR SectorsPerTrack[2];
  UCHAR NumberOfHeads[2];
};
typedef struct _BOOT_SECTOR_INFO *PBOOT_SECTOR_INFO;
enum _DRIVE_MEDIA_TYPE {
  Drive360Media160 = 0,
  Drive360Media180 = 1,
  Drive360Media320 = 2,
  Drive360Media32X = 3,
  Drive360Media360 = 4,
  Drive720Media720 = 5,
  Drive120Media160 = 6,
  Drive120Media180 = 7,
  Drive120Media320 = 8,
  Drive120Media32X = 9,
  Drive120Media360 = 10,
  Drive120Media120 = 11,
  Drive144Media720 = 12,
  Drive144Media144 = 13,
  Drive288Media720 = 14,
  Drive288Media144 = 15,
  Drive288Media288 = 16
};
typedef enum _DRIVE_MEDIA_TYPE DRIVE_MEDIA_TYPE;
enum _DRIVE_MEDIA_TYPE_NEC98 {
  Drive360Media160Nec98 = 0,
  Drive360Media180Nec98 = 1,
  Drive360Media320Nec98 = 2,
  Drive360Media32XNec98 = 3,
  Drive360Media360Nec98 = 4,
  Drive120Media160Nec98 = 5,
  Drive120Media180Nec98 = 6,
  Drive120Media320Nec98 = 7,
  Drive120Media32XNec98 = 8,
  Drive120Media360Nec98 = 9,
  Drive120Media640Nec98 = 10,
  Drive120Media720Nec98 = 11,
  Drive120Media120Nec98 = 12,
  Drive120Media123Nec98 = 13,
  Drive144Media640Nec98 = 14,
  Drive144Media720Nec98 = 15,
  Drive144Media120Nec98 = 16,
  Drive144Media123Nec98 = 17,
  Drive144Media144Nec98 = 18,
  Drive12EMedia120Nec98 = 19,
  Drive12EMedia123Nec98 = 20
};
typedef enum _DRIVE_MEDIA_TYPE_NEC98 DRIVE_MEDIA_TYPE_NEC98;
struct _DRIVE_MEDIA_LIMITS {
  DRIVE_MEDIA_TYPE HighestDriveMediaType;
  DRIVE_MEDIA_TYPE LowestDriveMediaType;
};
typedef struct _DRIVE_MEDIA_LIMITS DRIVE_MEDIA_LIMITS;
typedef struct _DRIVE_MEDIA_LIMITS *PDRIVE_MEDIA_LIMITS;
struct _DRIVE_MEDIA_LIMITS_NEC98 {
  DRIVE_MEDIA_TYPE_NEC98 HighestDriveMediaType;
  DRIVE_MEDIA_TYPE_NEC98 LowestDriveMediaType;
};
typedef struct _DRIVE_MEDIA_LIMITS_NEC98 DRIVE_MEDIA_LIMITS_NEC98;
struct _DRIVE_MEDIA_CONSTANTS {
  MEDIA_TYPE MediaType;
  UCHAR StepRateHeadUnloadTime;
  UCHAR HeadLoadTime;
  UCHAR MotorOffTime;
  UCHAR SectorLengthCode;
  USHORT BytesPerSector;
  UCHAR SectorsPerTrack;
  UCHAR ReadWriteGapLength;
  UCHAR FormatGapLength;
  UCHAR FormatFillCharacter;
  UCHAR HeadSettleTime;
  USHORT MotorSettleTimeRead;
  USHORT MotorSettleTimeWrite;
  UCHAR MaximumTrack;
  UCHAR CylinderShift;
  UCHAR DataTransferRate;
  UCHAR NumberOfHeads;
  UCHAR DataLength;
  UCHAR MediaByte;
  UCHAR SkewDelta;
};
typedef struct _DRIVE_MEDIA_CONSTANTS DRIVE_MEDIA_CONSTANTS;
typedef struct _DRIVE_MEDIA_CONSTANTS *PDRIVE_MEDIA_CONSTANTS;
struct _DISKETTE_EXTENSION {
  KSPIN_LOCK FlCancelSpinLock;
  PDEVICE_OBJECT UnderlyingPDO;
  PDEVICE_OBJECT TargetObject;
  BOOLEAN IsStarted;
  BOOLEAN IsRemoved;
  BOOLEAN HoldNewRequests;
  LIST_ENTRY NewRequestQueue;
  KSPIN_LOCK NewRequestQueueSpinLock;
  PDEVICE_OBJECT DeviceObject;
  KSEMAPHORE RequestSemaphore;
  KSPIN_LOCK ListSpinLock;
  FAST_MUTEX ThreadReferenceMutex;
  LONG ThreadReferenceCount;
  PKTHREAD FloppyThread;
  LIST_ENTRY ListEntry;
  BOOLEAN HardwareFailed;
  UCHAR HardwareFailCount;
  ULONG MaxTransferSize;
  UCHAR FifoBuffer[10];
  PUCHAR IoBuffer;
  PMDL IoBufferMdl;
  ULONG IoBufferSize;
  PDRIVER_OBJECT DriverObject;
  DRIVE_MEDIA_TYPE LastDriveMediaType;
  BOOLEAN FloppyControllerAllocated;
  BOOLEAN ACPI_BIOS;
  UCHAR DriveType;
  ULONG BytesPerSector;
  ULONG ByteCapacity;
  MEDIA_TYPE MediaType;
  DRIVE_MEDIA_TYPE DriveMediaType;
  UCHAR DeviceUnit;
  UCHAR DriveOnValue;
  BOOLEAN IsReadOnly;
  DRIVE_MEDIA_CONSTANTS BiosDriveMediaConstants;
  DRIVE_MEDIA_CONSTANTS DriveMediaConstants;
  UCHAR PerpendicularMode;
  BOOLEAN ControllerConfigurable;
  UNICODE_STRING DeviceName;
  UNICODE_STRING InterfaceString;
  UNICODE_STRING ArcName;
  BOOLEAN ReleaseFdcWithMotorRunning;
  BOOLEAN PoweringDown;
  FAST_MUTEX PowerDownMutex;
  FAST_MUTEX HoldNewReqMutex;
};
typedef struct _DISKETTE_EXTENSION DISKETTE_EXTENSION;
typedef DISKETTE_EXTENSION *PDISKETTE_EXTENSION;
struct _SENSE_DEVISE_STATUS_PTOS {
  UCHAR ST3_PTOS;
};
typedef struct _SENSE_DEVISE_STATUS_PTOS SENSE_DEVISE_STATUS_PTOS;
typedef struct _SENSE_DEVISE_STATUS_PTOS *PSENSE_DEVISE_STATUS_PTOS;
#pragma pack(push, 8)
#pragma pack(pop)
struct _KAPC;
struct _KDPC;
#pragma pack(push, 4)
#pragma pack(pop)
#pragma pack(push, 4)
#pragma pack(pop)
#pragma pack(push, 1)
#pragma pack(pop)
struct _DRIVER_OBJECT;
struct _DEVICE_OBJECT;
struct _DRIVER_OBJECT;
struct _FILE_OBJECT;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;
#pragma pack(push, 4)
#pragma pack(pop)
#pragma once
extern int sprintf(char *, char const *, ...);
extern int swprintf(wchar_t *, wchar_t const *, ...);
#pragma once
#pragma once
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4035)
#pragma warning(pop)
#pragma once
extern void *memcpy(void *, void const *, size_t);
extern void *memset(void *, int, size_t);
extern void *memmove(void *, void const *, size_t);
extern PKTHREAD KeGetCurrentThread();
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo, PCWSTR Path,
                                PRTL_QUERY_REGISTRY_TABLE QueryTable,
                                PVOID Context, PVOID Environment);
NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo, PCWSTR Path,
                                PCWSTR ValueName);
void RtlInitString(PSTRING DestinationString, PCSZ SourceString);
void RtlInitUnicodeString(PUNICODE_STRING DestinationString,
                          PCWSTR SourceString);
NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString,
                                      PANSI_STRING SourceString,
                                      BOOLEAN AllocateDestinationString);
void RtlCopyUnicodeString(PUNICODE_STRING DestinationString,
                          PUNICODE_STRING SourceString);
void RtlFreeUnicodeString(PUNICODE_STRING UnicodeString);
SIZE_T RtlCompareMemory(void const *Source1, void const *Source2,
                        SIZE_T Length);
#pragma warning(push)
#pragma warning(disable : 4035)
#pragma warning(pop)
extern LONG InterlockedExchange(PLONG Target, LONG Value);
#pragma warning(disable : 4035)
#pragma warning(push)
#pragma warning(disable : 4164)
#pragma function(_enable)
#pragma function(_disable)
#pragma warning(pop)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
void KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
LONG KeSetEvent(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
void KeInitializeSemaphore(PRKSEMAPHORE Semaphore, LONG Count, LONG Limit);
LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore, KPRIORITY Increment,
                        LONG Adjustment, BOOLEAN Wait);
NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable,
                                PLARGE_INTEGER Interval);
extern KPRIORITY KeSetPriorityThread(PKTHREAD Thread, KPRIORITY Priority);
NTSTATUS KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason,
                               KPROCESSOR_MODE WaitMode, BOOLEAN Alertable,
                               PLARGE_INTEGER Timeout);
void KeInitializeSpinLock(PKSPIN_LOCK SpinLock);
extern KIRQL KfAcquireSpinLock(PKSPIN_LOCK SpinLock);
void KfReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes,
                            ULONG Tag);
void ExFreePool(PVOID P);
void ExAcquireFastMutex(PFAST_MUTEX FastMutex);
void ExReleaseFastMutex(PFAST_MUTEX FastMutex);
PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead,
                                         PLIST_ENTRY ListEntry,
                                         PKSPIN_LOCK Lock);
PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead,
                                         PLIST_ENTRY ListEntry,
                                         PKSPIN_LOCK Lock);
PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead,
                                         PKSPIN_LOCK Lock);
extern void MmProbeAndLockPages(PMDL MemoryDescriptorList,
                                KPROCESSOR_MODE AccessMode,
                                LOCK_OPERATION Operation);
void MmUnlockPages(PMDL MemoryDescriptorList);
PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList,
                                   KPROCESSOR_MODE AccessMode,
                                   MEMORY_CACHING_TYPE CacheType,
                                   PVOID BaseAddress, ULONG BugCheckOnFailure,
                                   MM_PAGE_PRIORITY Priority);
PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes,
                                 PHYSICAL_ADDRESS HighestAcceptableAddress);
void MmFreeContiguousMemory(PVOID BaseAddress);
void MmResetDriverPaging(PVOID AddressWithinSection);
PVOID MmPageEntireDriver(PVOID AddressWithinSection);
NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle, ULONG DesiredAccess,
                              POBJECT_ATTRIBUTES ObjectAttributes,
                              HANDLE ProcessHandle, PCLIENT_ID ClientId,
                              void (*StartRoutine)(PVOID StartContext),
                              PVOID StartContext);
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus);
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
PMDL IoAllocateMdl(PVOID VirtualAddress, ULONG Length, BOOLEAN SecondaryBuffer,
                   BOOLEAN ChargeQuota, PIRP Irp);
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice,
                                           PDEVICE_OBJECT TargetDevice);
PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction,
                                   PDEVICE_OBJECT DeviceObject, PVOID Buffer,
                                   ULONG Length, PLARGE_INTEGER StartingOffset,
                                   PIO_STATUS_BLOCK IoStatusBlock);
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode,
                                   PDEVICE_OBJECT DeviceObject,
                                   PVOID InputBuffer, ULONG InputBufferLength,
                                   PVOID OutputBuffer, ULONG OutputBufferLength,
                                   BOOLEAN InternalDeviceIoControl,
                                   PKEVENT Event,
                                   PIO_STATUS_BLOCK IoStatusBlock);
NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
void IofCompleteRequest(PIRP Irp, CCHAR PriorityBoost);
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize,
                        PUNICODE_STRING DeviceName, ULONG DeviceType,
                        ULONG DeviceCharacteristics, BOOLEAN Exclusive,
                        PDEVICE_OBJECT *DeviceObject);
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName,
                              PUNICODE_STRING DeviceName);
void IoDeleteDevice(PDEVICE_OBJECT DeviceObject);
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName);
void IoDetachDevice(PDEVICE_OBJECT TargetDevice);
void IoFreeIrp(PIRP Irp);
void IoFreeMdl(PMDL Mdl);
PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void);
NTSTATUS IoQueryDeviceDescription(
    PINTERFACE_TYPE BusType, PULONG BusNumber,
    PCONFIGURATION_TYPE ControllerType, PULONG ControllerNumber,
    PCONFIGURATION_TYPE PeripheralType, PULONG PeripheralNumber,
    NTSTATUS (*CalloutRoutine)(
        PVOID Context, PUNICODE_STRING PathName, INTERFACE_TYPE BusType,
        ULONG BusNumber, PKEY_VALUE_FULL_INFORMATION *BusInformation,
        CONFIGURATION_TYPE ControllerType, ULONG ControllerNumber,
        PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
        CONFIGURATION_TYPE PeripheralType, ULONG PeripheralNumber,
        PKEY_VALUE_FULL_INFORMATION *PeripheralInformation),
    PVOID Context);
void IoReleaseCancelSpinLock(KIRQL Irql);
void IoSetHardErrorOrVerifyDevice(PIRP Irp, PDEVICE_OBJECT DeviceObject);
NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject,
                                   GUID const *InterfaceClassGuid,
                                   PUNICODE_STRING ReferenceString,
                                   PUNICODE_STRING SymbolicLinkName);
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName,
                                   BOOLEAN Enable);
#pragma warning(disable : 4200)
#pragma warning(default : 4200)
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
void PoStartNextPowerIrp(PIRP Irp);
NTSTATUS
ObReferenceObjectByHandle(HANDLE Handle, ACCESS_MASK DesiredAccess,
                          POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode,
                          PVOID *Object,
                          POBJECT_HANDLE_INFORMATION HandleInformation);
void ObfDereferenceObject(PVOID Object);
NTSTATUS ZwClose(HANDLE Handle);
#pragma once
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma once
#pragma once
struct _GUID const MOUNTDEV_MOUNTED_DEVICE_GUID = {
    1408590605, 46783, 4560, {148, 242, 0, 160, 201, 30, 251, 139}};
#pragma once
DRIVE_MEDIA_LIMITS _DriveMediaLimits[5] = {
    {4, 0}, {11, 6}, {5, 5}, {13, 12}, {16, 14}};
DRIVE_MEDIA_LIMITS_NEC98 _DriveMediaLimits_NEC98[6] = {
    {4, 0}, {13, 5}, {11, 5}, {18, 14}, {18, 14}, {20, 19}};
PDRIVE_MEDIA_LIMITS DriveMediaLimits;
DRIVE_MEDIA_CONSTANTS _DriveMediaConstants[17] = {
    {10, 223,  2,    37, 2, 512, 8, 42,  80,  246,
     15, 1000, 1000, 39, 0, 2,   1, 255, 254, 0},
    {9,  223,  2,    37, 2, 512, 9, 42,  80,  246,
     15, 1000, 1000, 39, 0, 2,   1, 255, 252, 0},
    {7,  223,  2,    37, 2, 512, 8, 42,  80,  246,
     15, 1000, 1000, 39, 0, 2,   2, 255, 255, 0},
    {8,  223,  2,    37, 3, 1024, 4, 128, 240, 246,
     15, 1000, 1000, 39, 0, 2,    2, 255, 255, 0},
    {6,  223, 2,    37, 2, 512, 9, 42,  80,  246,
     15, 250, 1000, 39, 0, 2,   2, 255, 253, 0},
    {5,  223, 2,    37, 2, 512, 9, 42,  80,  246,
     15, 500, 1000, 79, 0, 2,   2, 255, 249, 2},
    {10, 223,  2,    37, 2, 512, 8, 42,  80,  246,
     15, 1000, 1000, 39, 1, 1,   1, 255, 254, 0},
    {9,  223,  2,    37, 2, 512, 9, 42,  80,  246,
     15, 1000, 1000, 39, 1, 1,   1, 255, 252, 0},
    {7,  223,  2,    37, 2, 512, 8, 42,  80,  246,
     15, 1000, 1000, 39, 1, 1,   2, 255, 255, 0},
    {8,  223,  2,    37, 3, 1024, 4, 128, 240, 246,
     15, 1000, 1000, 39, 1, 1,    2, 255, 255, 0},
    {6,  223, 2,    37, 2, 512, 9, 42,  80,  246,
     15, 625, 1000, 39, 1, 1,   2, 255, 253, 0},
    {1,  223, 2,    37, 2, 512, 15, 27,  84,  246,
     15, 625, 1000, 79, 0, 0,   2,  255, 249, 0},
    {5,  223, 2,    37, 2, 512, 9, 42,  80,  246,
     15, 500, 1000, 79, 0, 2,   2, 255, 249, 2},
    {2,  175, 2,    37, 2, 512, 18, 27,  101, 246,
     15, 500, 1000, 79, 0, 0,   2,  255, 240, 3},
    {5,  225, 2,    37, 2, 512, 9, 42,  80,  246,
     15, 500, 1000, 79, 0, 2,   2, 255, 249, 2},
    {2,  209, 2,    37, 2, 512, 18, 27,  101, 246,
     15, 500, 1000, 79, 0, 0,   2,  255, 240, 3},
    {3,  161, 2,    37, 2, 512, 36, 56,  83,  246,
     15, 500, 1000, 79, 0, 3,   2,  255, 240, 6}};
DRIVE_MEDIA_CONSTANTS _DriveMediaConstants_NEC98[21] = {
    {10, 223,  2,    37, 2, 512, 8, 42,  80,  246,
     15, 1000, 1000, 39, 0, 2,   1, 255, 254, 0},
    {9,  223,  2,    37, 2, 512, 9, 42,  80,  246,
     15, 1000, 1000, 39, 0, 2,   1, 255, 252, 0},
    {7,  223,  2,    37, 2, 512, 8, 42,  80,  246,
     15, 1000, 1000, 39, 0, 2,   2, 255, 255, 0},
    {8,  223,  2,    37, 3, 1024, 4, 128, 240, 246,
     15, 1000, 1000, 39, 0, 2,    2, 255, 255, 0},
    {6,  223, 2,    37, 2, 512, 9, 42,  80,  246,
     15, 250, 1000, 39, 0, 2,   2, 255, 253, 0},
    {10, 223,  22,   37, 2, 512, 8, 42,  80,  229,
     15, 1000, 1000, 39, 1, 2,   1, 255, 254, 0},
    {9,  223,  22,   37, 2, 512, 9, 42,  80,  229,
     15, 1000, 1000, 39, 1, 2,   1, 255, 252, 0},
    {7,  223,  22,   37, 2, 512, 8, 42,  80,  229,
     15, 1000, 1000, 39, 1, 2,   2, 255, 255, 0},
    {8,  223,  22,   37, 3, 1024, 4, 128, 240, 229,
     15, 1000, 1000, 39, 1, 2,    2, 255, 255, 0},
    {6,  223,  22,   37, 2, 512, 9, 42,  80,  229,
     15, 1000, 1000, 39, 1, 2,   2, 255, 253, 0},
    {15, 223,  22,   37, 2, 512, 8, 42,  80,  229,
     15, 1000, 1000, 79, 0, 0,   2, 255, 251, 0},
    {16, 223,  22,   37, 2, 512, 9, 42,  80,  229,
     15, 1000, 1000, 79, 0, 0,   2, 255, 249, 2},
    {1,  207,  36,   37, 2, 512, 15, 27,  84,  229,
     15, 1000, 1000, 79, 0, 0,   2,  255, 249, 0},
    {19, 207,  36,   37, 3, 1024, 8, 53,  116, 229,
     15, 1000, 1000, 76, 0, 0,    2, 255, 254, 0},
    {14, 223,  22,   37, 2, 512, 8, 42,  80,  229,
     15, 1000, 1000, 79, 0, 0,   2, 255, 251, 0},
    {5,  223,  22,   37, 2, 512, 9, 42,  80,  229,
     15, 1000, 1000, 79, 0, 0,   2, 255, 249, 2},
    {17, 207,  36,   37, 2, 512, 15, 27,  84,  229,
     15, 1000, 1000, 79, 0, 0,   2,  255, 249, 0},
    {18, 207,  36,   37, 3, 1024, 8, 53,  116, 229,
     15, 1000, 1000, 76, 0, 0,    2, 255, 254, 0},
    {2,  223,  36,   37, 2, 512, 18, 27,  108, 229,
     15, 1000, 1000, 79, 0, 0,   2,  255, 240, 3},
    {1,  191,  50,   37, 2, 512, 15, 27,  84,  229,
     15, 1000, 1000, 79, 0, 0,   2,  255, 249, 0},
    {19, 191,  50,   37, 3, 1024, 8, 53,  116, 229,
     15, 1000, 1000, 76, 0, 0,    2, 255, 254, 0}};
PDRIVE_MEDIA_CONSTANTS DriveMediaConstants;
SENSE_DEVISE_STATUS_PTOS Result_Status3_PTOS[4];
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
void FloppyUnload(PDRIVER_OBJECT DriverObject);
NTSTATUS FlConfigCallBack(PVOID Context, PUNICODE_STRING PathName,
                          INTERFACE_TYPE BusType, ULONG BusNumber,
                          PKEY_VALUE_FULL_INFORMATION *BusInformation,
                          CONFIGURATION_TYPE ControllerType,
                          ULONG ControllerNumber,
                          PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
                          CONFIGURATION_TYPE PeripheralType,
                          ULONG PeripheralNumber,
                          PKEY_VALUE_FULL_INFORMATION *PeripheralInformation);
NTSTATUS FlInitializeControllerHardware(PDISKETTE_EXTENSION DisketteExtension);
NTSTATUS FloppyCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS FloppyDeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS FloppyReadWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS FlRecalibrateDrive(PDISKETTE_EXTENSION DisketteExtension);
NTSTATUS FlDatarateSpecifyConfigure(PDISKETTE_EXTENSION DisketteExtension);
NTSTATUS FlStartDrive(PDISKETTE_EXTENSION DisketteExtension, PIRP Irp,
                      BOOLEAN WriteOperation, BOOLEAN SetUpMedia,
                      BOOLEAN IgnoreChange);
void FlFinishOperation(PIRP Irp, PDISKETTE_EXTENSION DisketteExtension);
NTSTATUS FlDetermineMediaType(PDISKETTE_EXTENSION DisketteExtension);
void FloppyThread(PVOID Context);
NTSTATUS FlReadWrite(PDISKETTE_EXTENSION DisketteExtension, PIRP Irp,
                     BOOLEAN DriveStarted);
NTSTATUS FlFormat(PDISKETTE_EXTENSION DisketteExtension, PIRP Irp);
NTSTATUS FlIssueCommand(PDISKETTE_EXTENSION DisketteExtension,
                        PUCHAR FifoInBuffer, PUCHAR FifoOutBuffer, PMDL IoMdl,
                        ULONG IoOffset, ULONG TransferBytes);
BOOLEAN FlCheckFormatParameters(PDISKETTE_EXTENSION DisketteExtension,
                                PFORMAT_PARAMETERS FormatParameters);
NTSTATUS FlQueueIrpToThread(PIRP Irp, PDISKETTE_EXTENSION DisketteExtension);
NTSTATUS FlInterpretError(UCHAR StatusRegister1, UCHAR StatusRegister2);
void FlAllocateIoBuffer(PDISKETTE_EXTENSION DisketteExtension,
                        ULONG BufferSize);
void FlFreeIoBuffer(PDISKETTE_EXTENSION DisketteExtension);
void FlConsolidateMediaTypeWithBootSector(PDISKETTE_EXTENSION DisketteExtension,
                                          PBOOT_SECTOR_INFO BootSector);
void FlCheckBootSector(PDISKETTE_EXTENSION DisketteExtension);
NTSTATUS FlReadWriteTrack(PDISKETTE_EXTENSION DisketteExtension, PMDL IoMdl,
                          ULONG IoOffset, BOOLEAN WriteOperation,
                          UCHAR Cylinder, UCHAR Head, UCHAR Sector,
                          UCHAR NumberOfSectors, BOOLEAN NeedSeek);
NTSTATUS FlFdcDeviceIo(PDEVICE_OBJECT DeviceObject, ULONG Ioctl, PVOID Data);
NTSTATUS FloppyAddDevice(PDRIVER_OBJECT DriverObject,
                         PDEVICE_OBJECT PhysicalDeviceObject);
NTSTATUS FloppyPnp(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS FloppyPower(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS FloppyPnpComplete(PDEVICE_OBJECT DeviceObject, PIRP Irp,
                           PVOID Context);
NTSTATUS FloppyQueueRequest(PDISKETTE_EXTENSION DisketteExtension, PIRP Irp);
NTSTATUS FloppyStartDevice(PDEVICE_OBJECT DeviceObject, PIRP Irp);
void FloppyProcessQueuedRequests(PDISKETTE_EXTENSION DisketteExtension);
void FloppyCancelQueuedRequest(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS FlAcpiConfigureFloppy(PDISKETTE_EXTENSION DisketteExtension,
                               PFDC_INFO FdcInfo);
NTSTATUS FlHdbit(PDISKETTE_EXTENSION DisketteExtension);
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, FloppyAddDevice)
#pragma alloc_text(PAGE, FloppyPnp)
#pragma alloc_text(PAGE, FloppyPower)
#pragma alloc_text(PAGE, FlConfigCallBack)
#pragma alloc_text(PAGE, FlInitializeControllerHardware)
#pragma alloc_text(PAGE, FlInterpretError)
#pragma alloc_text(PAGE, FlDatarateSpecifyConfigure)
#pragma alloc_text(PAGE, FlRecalibrateDrive)
#pragma alloc_text(PAGE, FlDetermineMediaType)
#pragma alloc_text(PAGE, FlCheckBootSector)
#pragma alloc_text(PAGE, FlConsolidateMediaTypeWithBootSector)
#pragma alloc_text(PAGE, FlIssueCommand)
#pragma alloc_text(PAGE, FlReadWriteTrack)
#pragma alloc_text(PAGE, FlReadWrite)
#pragma alloc_text(PAGE, FlFormat)
#pragma alloc_text(PAGE, FlFinishOperation)
#pragma alloc_text(PAGE, FlStartDrive)
#pragma alloc_text(PAGE, FloppyThread)
#pragma alloc_text(PAGE, FlAllocateIoBuffer)
#pragma alloc_text(PAGE, FlFreeIoBuffer)
#pragma alloc_text(PAGE, FloppyCreateClose)
#pragma alloc_text(PAGE, FloppyDeviceControl)
#pragma alloc_text(PAGE, FloppyReadWrite)
#pragma alloc_text(PAGE, FlCheckFormatParameters)
#pragma alloc_text(PAGE, FlFdcDeviceIo)
#pragma alloc_text(PAGE, FlHdbit)
void errorFn(void) {

  {
  ERROR:
    assert(0);
    goto ERROR;
  }
}
NTSTATUS myStatus;
int s;
int UNLOADED;
int NP;
int DC;
int SKIP1;
int SKIP2;
int MPR1;
int MPR3;
int IPC;
int pended;
NTSTATUS (*compFptr)(PDEVICE_OBJECT DeviceObject, PIRP Irp, PVOID Context);
int compRegistered;
int lowerDriverReturn;
int setEventCalled;
int customIrp;
void _BLAST_init(void) {

  {
    UNLOADED = 0;
    NP = 1;
    DC = 2;
    SKIP1 = 3;
    SKIP2 = 4;
    MPR1 = 5;
    MPR3 = 6;
    IPC = 7;
    s = UNLOADED;
    pended = 0;
    compFptr = 0;
    compRegistered = 0;
    lowerDriverReturn = 0;
    setEventCalled = 0;
    customIrp = 0;
    return;
  }
}
ULONG PagingReferenceCount = 0;
PFAST_MUTEX PagingMutex = (void *)0;
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject,
                     PUNICODE_STRING RegistryPath) {
  NTSTATUS ntStatus;
  PVOID tmp;

  {
    ntStatus = 0L;
    {} {
      DriverObject->MajorFunction[0] = &FloppyCreateClose;
      DriverObject->MajorFunction[2] = &FloppyCreateClose;
      DriverObject->MajorFunction[3] = &FloppyReadWrite;
      DriverObject->MajorFunction[4] = &FloppyReadWrite;
      DriverObject->MajorFunction[14] = &FloppyDeviceControl;
      DriverObject->MajorFunction[27] = &FloppyPnp;
      DriverObject->MajorFunction[22] = &FloppyPower;
      DriverObject->DriverUnload = &FloppyUnload;
      (DriverObject->DriverExtension)->AddDevice = &FloppyAddDevice;
      tmp = ExAllocatePoolWithTag(0, sizeof(FAST_MUTEX), 1886350406UL);
      PagingMutex = tmp;
    }
    if ((unsigned int)PagingMutex == (unsigned int)((void *)0)) {
      return (-1073741670L);
    } else {
    }
    {
      PagingMutex->Count = 1;
      PagingMutex->Contention = 0;
      /*   KeInitializeEvent(& PagingMutex->Event, 1, 0); */ /* INLINED */
      /* MmPageEntireDriver(& DriverEntry); */               /* INLINED */
    }
    if ((int)((KUSER_SHARED_DATA * const)4292804608U)
            ->AlternativeArchitecture == 1) {
      DriveMediaLimits =
          (struct _DRIVE_MEDIA_LIMITS *)(_DriveMediaLimits_NEC98);
    } else {
      DriveMediaLimits = _DriveMediaLimits;
    }
    if ((int)((KUSER_SHARED_DATA * const)4292804608U)
            ->AlternativeArchitecture == 1) {
      DriveMediaConstants = _DriveMediaConstants_NEC98;
    } else {
      DriveMediaConstants = _DriveMediaConstants;
    }
    return (ntStatus);
  }
}
void FloppyUnload(PDRIVER_OBJECT DriverObject) {

  {
    {} { /*   ExFreePool(PagingMutex); */ /* INLINED */
    }
    return;
  }
}
NTSTATUS FloppyAddDevice(PDRIVER_OBJECT DriverObject,
                         PDEVICE_OBJECT PhysicalDeviceObject) {
  NTSTATUS ntStatus;
  PDEVICE_OBJECT deviceObject;
  PDISKETTE_EXTENSION disketteExtension;
  FDC_INFO fdcInfo;
  UCHAR arcNameBuffer[256];
  STRING arcNameString;
  WCHAR deviceNameBuffer[20];
  UNICODE_STRING deviceName;
  USHORT i;
  USHORT tmp;
  PVOID tmp___0;
  PCONFIGURATION_INFORMATION tmp___1;

  {
    ntStatus = 0L;
    {} {
      fdcInfo.BufferCount = 0;
      fdcInfo.BufferSize = 0;
      ntStatus = FlFdcDeviceIo(PhysicalDeviceObject,
                               ((7 << 16) | (770 << 2)) | 3, &fdcInfo);
    }
    if (ntStatus >= 0L) {
      i = 0;
      {
        while (1) {
        while_3_continue: /* CIL Label */;
          {
            tmp = i;
            i = (USHORT)((int)i + 1);
            swprintf(deviceNameBuffer, "\\\000D\000e\000v\000i\000c\000e\000\\"
                                       "\000F\000l\000o\000p\000p\000y\000%"
                                       "\000d\000",
                     tmp);
            /*       RtlInitUnicodeString(& deviceName, deviceNameBuffer); */ /* INLINED */
            ntStatus = IoCreateDevice(DriverObject, sizeof(DISKETTE_EXTENSION),
                                      &deviceName, 7, 261, 0, &deviceObject);
          }
          if (ntStatus == -1073741771L) {

          } else {
            goto while_3_break;
          }
        }
      while_3_break: /* CIL Label */;
      }
      if (ntStatus >= 0L) {
        disketteExtension = (DISKETTE_EXTENSION *)deviceObject->DeviceExtension;
        {} {
          tmp___0 = ExAllocatePoolWithTag(1, deviceName.Length, 1886350406UL);
          disketteExtension->DeviceName.Buffer = tmp___0;
        }
        if ((unsigned int)disketteExtension->DeviceName.Buffer ==
            (unsigned int)((void *)0)) {
          { /*         IoDeleteDevice(deviceObject); */ /* INLINED */
          }
          return (-1073741670L);
        } else {
        }
        {
          disketteExtension->DeviceName.Length = 0;
          disketteExtension->DeviceName.MaximumLength = deviceName.Length;
          /*       RtlCopyUnicodeString(& disketteExtension->DeviceName, & deviceName); */ /* INLINED */
          tmp___1 = IoGetConfigurationInformation();
          tmp___1->FloppyCount += 1UL;
          sprintf(arcNameBuffer, "%s(%d)disk(%d)fdisk(%d)", "\\ArcName\\multi",
                  fdcInfo.BusNumber, fdcInfo.ControllerNumber,
                  fdcInfo.PeripheralNumber);
          /*       RtlInitString(& arcNameString, arcNameBuffer); */ /* INLINED
                                                                        */
          ntStatus = RtlAnsiStringToUnicodeString(&disketteExtension->ArcName,
                                                  &arcNameString, 1);
        }
        if (ntStatus >= 0L) {
          { IoCreateSymbolicLink(&disketteExtension->ArcName, &deviceName); }
        } else {
        }
        deviceObject->Flags |= 8208UL;
        if (deviceObject->AlignmentRequirement < 1UL) {
          deviceObject->AlignmentRequirement = 1;
        } else {
        }
        deviceObject->Flags &= 4294967167UL;
        disketteExtension->DriverObject = DriverObject;
        disketteExtension->UnderlyingPDO = PhysicalDeviceObject;
        {} {
          disketteExtension->TargetObject =
              IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
        }
        {} {
          /*       KeInitializeSemaphore(& disketteExtension->RequestSemaphore, 0L, 2147483647); */ /* INLINED */
          disketteExtension->PowerDownMutex.Count = 1;
          disketteExtension->PowerDownMutex.Contention = 0;
          /*       KeInitializeEvent(& disketteExtension->PowerDownMutex.Event, 1, 0); */ /* INLINED */
          /*       KeInitializeSpinLock(& disketteExtension->ListSpinLock); */ /* INLINED */
          disketteExtension->ThreadReferenceMutex.Count = 1;
          disketteExtension->ThreadReferenceMutex.Contention = 0;
          /*       KeInitializeEvent(& disketteExtension->ThreadReferenceMutex.Event, 1, 0); */ /* INLINED */
          disketteExtension->HoldNewReqMutex.Count = 1;
          disketteExtension->HoldNewReqMutex.Contention = 0;
          /*       KeInitializeEvent(& disketteExtension->HoldNewReqMutex.Event, 1, 0); */ /* INLINED */
          disketteExtension->ListEntry.Blink = &disketteExtension->ListEntry;
          disketteExtension->ListEntry.Flink =
              disketteExtension->ListEntry.Blink;
          disketteExtension->ThreadReferenceCount = -1;
          disketteExtension->IsStarted = 0;
          disketteExtension->IsRemoved = 0;
          disketteExtension->HoldNewRequests = 0;
          disketteExtension->NewRequestQueue.Blink =
              &disketteExtension->NewRequestQueue;
          disketteExtension->NewRequestQueue.Flink =
              disketteExtension->NewRequestQueue.Blink;
          /*       KeInitializeSpinLock(& disketteExtension->NewRequestQueueSpinLock); */ /* INLINED */
          /*       KeInitializeSpinLock(& disketteExtension->FlCancelSpinLock); */ /* INLINED */
          disketteExtension->FloppyControllerAllocated = 0;
          disketteExtension->ReleaseFdcWithMotorRunning = 0;
          disketteExtension->DeviceObject = deviceObject;
          disketteExtension->IsReadOnly = 0;
          disketteExtension->MediaType = -1;
        }
        if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                ->AlternativeArchitecture == 1) {
          disketteExtension->ControllerConfigurable = 0;
        } else {
          disketteExtension->ControllerConfigurable = 1;
        }
      } else {
      }
    } else {
    }
    return (ntStatus);
  }
}
NTSTATUS FlConfigCallBack(PVOID Context, PUNICODE_STRING PathName,
                          INTERFACE_TYPE BusType, ULONG BusNumber,
                          PKEY_VALUE_FULL_INFORMATION *BusInformation,
                          CONFIGURATION_TYPE ControllerType,
                          ULONG ControllerNumber,
                          PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
                          CONFIGURATION_TYPE PeripheralType,
                          ULONG PeripheralNumber,
                          PKEY_VALUE_FULL_INFORMATION *PeripheralInformation) {
  PDISKETTE_EXTENSION disketteExtension;
  ULONG i;
  PCM_FULL_RESOURCE_DESCRIPTOR peripheralData;
  PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
  PCM_FLOPPY_DEVICE_DATA fDeviceData;
  UCHAR driveType;
  PDRIVE_MEDIA_CONSTANTS biosDriveMediaConstants;

  {
    disketteExtension = Context;
    if (!((UCHAR *)*(PeripheralInformation + 1) +
          (*(PeripheralInformation + 1))->DataLength)) {
      return (-1073741811L);
    } else {
    }
    peripheralData = (struct _CM_FULL_RESOURCE_DESCRIPTOR
                          *)((UCHAR *)*(PeripheralInformation + 1) +
                             (*(PeripheralInformation + 1))->DataOffset);
    i = 0;
    {
      while (1) {
      while_7_continue: /* CIL Label */;
        if (i < peripheralData->PartialResourceList.Count) {

        } else {
          goto while_7_break;
        }
        partial = &peripheralData->PartialResourceList.PartialDescriptors[i];
        if ((int)partial->Type == 5) {
          biosDriveMediaConstants = &disketteExtension->BiosDriveMediaConstants;
          fDeviceData = (struct _CM_FLOPPY_DEVICE_DATA *)(partial + 1);
          if (fDeviceData->MaxDensity == 360) {
            goto switch_8_360;
          } else {
            if (fDeviceData->MaxDensity == 1200) {
              goto switch_8_1200;
            } else {
              if (fDeviceData->MaxDensity == 1185) {
                goto switch_8_1185;
              } else {
                if (fDeviceData->MaxDensity == 1423) {
                  goto switch_8_1423;
                } else {
                  if (fDeviceData->MaxDensity == 1440) {
                    goto switch_8_1440;
                  } else {
                    if (fDeviceData->MaxDensity == 2880) {
                      goto switch_8_2880;
                    } else {
                      if (fDeviceData->MaxDensity == 1201) {
                        goto switch_8_1201;
                      } else {
                        {
                          goto switch_8_default;
                          if (0) {
                          switch_8_360: /* CIL Label */
                            driveType = 0;
                            goto switch_8_break;
                          switch_8_1200: /* CIL Label */
                            driveType = 1;
                            goto switch_8_break;
                          switch_8_1185: /* CIL Label */
                            driveType = 1;
                            goto switch_8_break;
                          switch_8_1423: /* CIL Label */
                            driveType = 3;
                            goto switch_8_break;
                          switch_8_1440: /* CIL Label */
                            driveType = 3;
                            goto switch_8_break;
                          switch_8_2880: /* CIL Label */
                            driveType = 4;
                            goto switch_8_break;
                          switch_8_1201: /* CIL Label */;
                            if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                                    ->AlternativeArchitecture == 1) {
                              driveType = 5;
                              goto switch_8_break;
                            } else {
                            }
                          switch_8_default: /* CIL Label */;
                            {}
                            driveType = 1;
                            {}
                            goto switch_8_break;
                          } else {
                          switch_8_break: /* CIL Label */;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          disketteExtension->DriveType = driveType;
          *biosDriveMediaConstants =
              *(DriveMediaConstants +
                (DriveMediaLimits + driveType)->HighestDriveMediaType);
          if ((int)fDeviceData->Version >= 2) {
            biosDriveMediaConstants->StepRateHeadUnloadTime =
                fDeviceData->StepRateHeadUnloadTime;
            biosDriveMediaConstants->HeadLoadTime = fDeviceData->HeadLoadTime;
            biosDriveMediaConstants->MotorOffTime = fDeviceData->MotorOffTime;
            biosDriveMediaConstants->SectorLengthCode =
                fDeviceData->SectorLengthCode;
            if ((int)fDeviceData->SectorPerTrack == 0) {
              return (0L);
            } else {
            }
            if (fDeviceData->MaxDensity == 0UL) {
              return (0L);
            } else {
            }
            biosDriveMediaConstants->SectorsPerTrack =
                fDeviceData->SectorPerTrack;
            biosDriveMediaConstants->ReadWriteGapLength =
                fDeviceData->ReadWriteGapLength;
            biosDriveMediaConstants->FormatGapLength =
                fDeviceData->FormatGapLength;
            biosDriveMediaConstants->FormatFillCharacter =
                fDeviceData->FormatFillCharacter;
            biosDriveMediaConstants->HeadSettleTime =
                fDeviceData->HeadSettleTime;
            biosDriveMediaConstants->MotorSettleTimeRead =
                ((int)fDeviceData->MotorSettleTime * 1000) / 8;
            biosDriveMediaConstants->MotorSettleTimeWrite =
                ((int)fDeviceData->MotorSettleTime * 1000) / 8;
            if ((int)fDeviceData->MaximumTrackValue == 0) {
              return (0L);
            } else {
            }
            biosDriveMediaConstants->MaximumTrack =
                fDeviceData->MaximumTrackValue;
            biosDriveMediaConstants->DataLength =
                fDeviceData->DataTransferLength;
          } else {
          }
        } else {
        }
        i += 1UL;
      }
    while_7_break: /* CIL Label */;
    }
    return (0L);
  }
}
NTSTATUS FlAcpiConfigureFloppy(PDISKETTE_EXTENSION DisketteExtension,
                               PFDC_INFO FdcInfo) {
  UCHAR driveType;
  PDRIVE_MEDIA_CONSTANTS biosDriveMediaConstants;

  {
    biosDriveMediaConstants = &DisketteExtension->BiosDriveMediaConstants;
    if (!FdcInfo->AcpiFdiSupported) {
      return (-1073741823L);
    } else {
    }
    if ((enum _ACPI_FDI_DEVICE_TYPE)FdcInfo->AcpiFdiData.DeviceType == 1) {
      goto switch_11_1;
    } else {
      if ((enum _ACPI_FDI_DEVICE_TYPE)FdcInfo->AcpiFdiData.DeviceType == 2) {
        goto switch_11_2;
      } else {
        if ((enum _ACPI_FDI_DEVICE_TYPE)FdcInfo->AcpiFdiData.DeviceType == 3) {
          goto switch_11_3;
        } else {
          if ((enum _ACPI_FDI_DEVICE_TYPE)FdcInfo->AcpiFdiData.DeviceType ==
              4) {
            goto switch_11_4;
          } else {
            if ((enum _ACPI_FDI_DEVICE_TYPE)FdcInfo->AcpiFdiData.DeviceType ==
                5) {
              goto switch_11_5;
            } else {
              {
                goto switch_11_default;
                if (0) {
                switch_11_1: /* CIL Label */
                  driveType = 0;
                  goto switch_11_break;
                switch_11_2: /* CIL Label */
                  driveType = 1;
                  goto switch_11_break;
                switch_11_3: /* CIL Label */
                  driveType = 2;
                  goto switch_11_break;
                switch_11_4: /* CIL Label */
                  driveType = 3;
                  goto switch_11_break;
                switch_11_5: /* CIL Label */
                  driveType = 4;
                  goto switch_11_break;
                switch_11_default: /* CIL Label */
                  driveType = 1;
                  goto switch_11_break;
                } else {
                switch_11_break: /* CIL Label */;
                }
              }
            }
          }
        }
      }
    }
    DisketteExtension->DriveType = driveType;
    *biosDriveMediaConstants =
        *(DriveMediaConstants +
          (DriveMediaLimits + driveType)->HighestDriveMediaType);
    biosDriveMediaConstants->StepRateHeadUnloadTime =
        (unsigned char)FdcInfo->AcpiFdiData.StepRateHeadUnloadTime;
    biosDriveMediaConstants->HeadLoadTime =
        (unsigned char)FdcInfo->AcpiFdiData.HeadLoadTime;
    biosDriveMediaConstants->MotorOffTime =
        (unsigned char)FdcInfo->AcpiFdiData.MotorOffTime;
    biosDriveMediaConstants->SectorLengthCode =
        (unsigned char)FdcInfo->AcpiFdiData.SectorLengthCode;
    biosDriveMediaConstants->SectorsPerTrack =
        (unsigned char)FdcInfo->AcpiFdiData.SectorPerTrack;
    biosDriveMediaConstants->ReadWriteGapLength =
        (unsigned char)FdcInfo->AcpiFdiData.ReadWriteGapLength;
    biosDriveMediaConstants->FormatGapLength =
        (unsigned char)FdcInfo->AcpiFdiData.FormatGapLength;
    biosDriveMediaConstants->FormatFillCharacter =
        (unsigned char)FdcInfo->AcpiFdiData.FormatFillCharacter;
    biosDriveMediaConstants->HeadSettleTime =
        (unsigned char)FdcInfo->AcpiFdiData.HeadSettleTime;
    biosDriveMediaConstants->MotorSettleTimeRead =
        ((int)((unsigned char)FdcInfo->AcpiFdiData.MotorSettleTime) * 1000) / 8;
    biosDriveMediaConstants->MotorSettleTimeWrite =
        ((int)((unsigned short)FdcInfo->AcpiFdiData.MotorSettleTime) * 1000) /
        8;
    biosDriveMediaConstants->MaximumTrack =
        (unsigned char)FdcInfo->AcpiFdiData.MaxCylinderNumber;
    biosDriveMediaConstants->DataLength =
        (unsigned char)FdcInfo->AcpiFdiData.DataTransferLength;
    return (0L);
  }
}
NTSTATUS FlQueueIrpToThread(PIRP Irp, PDISKETTE_EXTENSION DisketteExtension) {
  NTSTATUS status;
  HANDLE threadHandle;
  PIO_STACK_LOCATION irpSp;
  OBJECT_ATTRIBUTES ObjAttributes;

  {
    {
      irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                  .CurrentStackLocation;
      /*   ExAcquireFastMutex(& DisketteExtension->PowerDownMutex); */ /* INLINED
                                                                          */
    }
    if ((int)DisketteExtension->PoweringDown == 1) {
      {
          /*     ExReleaseFastMutex(& DisketteExtension->PowerDownMutex); */ /* INLINED */
      } {}
      myStatus = -1073741101L;
      Irp->IoStatus.__annonCompField4.Status = -1073741101L;
      Irp->IoStatus.Information = 0;
      return (-1073741101L);
    } else {
    }
    {
        /*   ExReleaseFastMutex(& DisketteExtension->PowerDownMutex); */ /* INLINED
                                                                            */
    } {} {
      /*   ExAcquireFastMutex(& DisketteExtension->ThreadReferenceMutex); */ /* INLINED */
      DisketteExtension->ThreadReferenceCount += 1L;
    }
    if (DisketteExtension->ThreadReferenceCount == 0L) {
      {
        DisketteExtension->ThreadReferenceCount += 1L;
        /*     ExAcquireFastMutex(PagingMutex); */ /* INLINED */
        PagingReferenceCount += 1UL;
      }
      if (PagingReferenceCount == 1UL) {
        { /*       MmResetDriverPaging(& DriverEntry); */ /* INLINED */
        }
      } else {
      }
      {
        /*     ExReleaseFastMutex(PagingMutex); */ /* INLINED */
        ObjAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
        ObjAttributes.RootDirectory = (void *)0;
        ObjAttributes.Attributes = 512L;
        ObjAttributes.ObjectName = (void *)0;
        ObjAttributes.SecurityDescriptor = (void *)0;
        ObjAttributes.SecurityQualityOfService = (void *)0;
        status =
            PsCreateSystemThread(&threadHandle, 0UL, &ObjAttributes, (void *)0L,
                                 (void *)0, &FloppyThread, DisketteExtension);
      }
      if (!(status >= 0L)) {
        {
          DisketteExtension->ThreadReferenceCount = -1;
          /*       ExAcquireFastMutex(PagingMutex); */ /* INLINED */
          PagingReferenceCount -= 1UL;
        }
        if (PagingReferenceCount == 0UL) {
          { /* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
          }
        } else {
        }
        {
          /*       ExReleaseFastMutex(PagingMutex); */ /* INLINED */
          /*       ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex); */ /* INLINED */
        }
        return (status);
      } else {
      }
      {
        status = ObReferenceObjectByHandle(threadHandle, 1048576L, (void *)0, 0,
                                           &DisketteExtension->FloppyThread,
                                           (void *)0);
        ZwClose(threadHandle);
        /*     ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex); */ /* INLINED */
      }
      if (!(status >= 0L)) {
        return (status);
      } else {
      }
    } else {
      {
        /*     ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex); */ /* INLINED */
      }
    }
    (Irp->Tail.Overlay.__annonCompField17.__annonCompField16
         .CurrentStackLocation)
        ->Control = (int)(Irp->Tail.Overlay.__annonCompField17
                              .__annonCompField16.CurrentStackLocation)
                        ->Control |
                    1;
    if (pended == 0) {
      pended = 1;
    } else {
      { errorFn(); }
    }
    {
      ExfInterlockedInsertTailList(
          &DisketteExtension->ListEntry,
          &Irp->Tail.Overlay.__annonCompField17.ListEntry,
          &DisketteExtension->ListSpinLock);
      KeReleaseSemaphore(&DisketteExtension->RequestSemaphore, 0L, 1, 0);
    }
    return (259L);
  }
}
NTSTATUS FloppyCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) {

  {
    {} {
      myStatus = 0L;
      Irp->IoStatus.__annonCompField4.Status = 0L;
      Irp->IoStatus.Information = 1;
      IofCompleteRequest(Irp, 0);
    }
    return (0L);
  }
}
NTSTATUS FloppyDeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
  PIO_STACK_LOCATION irpSp;
  PDISKETTE_EXTENSION disketteExtension;
  PDISK_GEOMETRY outputBuffer;
  NTSTATUS ntStatus;
  ULONG outputBufferLength;
  UCHAR i;
  DRIVE_MEDIA_TYPE lowestDriveMediaType;
  DRIVE_MEDIA_TYPE highestDriveMediaType;
  ULONG formatExParametersSize;
  PFORMAT_EX_PARAMETERS formatExParameters;
  NTSTATUS tmp;
  PMOUNTDEV_NAME mountName;
  PMOUNTDEV_UNIQUE_ID uniqueId;
  BOOLEAN tmp___0;
  PMOUNTDEV_SUGGESTED_LINK_NAME suggestedName;
  WCHAR driveLetterNameBuffer[10];
  RTL_QUERY_REGISTRY_TABLE queryTable[2];
  PWSTR valueName;
  UNICODE_STRING driveLetterName;
  PVOID tmp___1;
  int tmp___2;

  {
    {} {
      disketteExtension = DeviceObject->DeviceExtension;
      irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                  .CurrentStackLocation;
      /*   ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED
                                                                           */
    }
    if (disketteExtension->HoldNewRequests) {
      if (irpSp->Parameters.DeviceIoControl.IoControlCode !=
          (ULONG)((50 << 16) | (3 << 14))) {
        {
          ntStatus = FloppyQueueRequest(disketteExtension, Irp);
          /*       ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
        }
        return (ntStatus);
      } else {
      }
    } else {
    }
    {
      /*   ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED
                                                                           */
    }
    if (disketteExtension->IsRemoved) {
      {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.__annonCompField4.Status = -1073741738L;
        myStatus = -1073741738L;
        IofCompleteRequest(Irp, 0);
      }
      return (-1073741738L);
    } else {
    }
    if (!disketteExtension->IsStarted) {
      if (s == NP) {
        s = SKIP1;
      } else {
        { errorFn(); }
      }
      {
        Irp->CurrentLocation = (CHAR)((int)Irp->CurrentLocation + 1);
        Irp->Tail.Overlay.__annonCompField17.__annonCompField16
            .CurrentStackLocation += 1;
        tmp = IofCallDriver(disketteExtension->TargetObject, Irp);
      }
      return (tmp);
    } else {
    }
    if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
        ((77UL << 16) | (unsigned long)(2 << 2))) {
      goto switch_16_exp_0;
    } else {
      if (irpSp->Parameters.DeviceIoControl.IoControlCode == 77UL << 16) {
        goto switch_16_exp_1;
      } else {
        if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
            (((7 << 16) | (3 << 14)) | (6 << 2))) {
          goto switch_16_exp_2;
        } else {
          if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
              (((7 << 16) | (3 << 14)) | (11 << 2))) {
            goto switch_16_exp_3;
          } else {
            if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                (((7 << 16) | (1 << 14)) | (512 << 2))) {
              goto switch_16_exp_4;
            } else {
              if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                  (((45 << 16) | (1 << 14)) | (512 << 2))) {
                goto switch_16_exp_5;
              } else {
                if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                    7 << 16) {
                  goto switch_16_exp_6;
                } else {
                  if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                      ((7 << 16) | (9 << 2))) {
                    goto switch_16_exp_7;
                  } else {
                    if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                        ((7 << 16) | (768 << 2))) {
                      goto switch_16_exp_8;
                    } else {
                      if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                          ((45 << 16) | (768 << 2))) {
                        goto switch_16_exp_9;
                      } else {
                        if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                            ((77UL << 16) | (unsigned long)(3 << 2))) {
                          goto switch_16_exp_10;
                        } else {
                          if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                              ((7 << 16) | (248 << 2))) {
                            goto switch_16_exp_11;
                          } else {
                            {
                              goto switch_16_default;
                              if (0) {
                              switch_16_exp_0: /* CIL Label */;
                                {}
                                if (irpSp->Parameters.DeviceIoControl
                                        .OutputBufferLength <
                                    (ULONG)sizeof(MOUNTDEV_NAME)) {
                                  ntStatus = -1073741811L;
                                  goto switch_16_break;
                                } else {
                                }
                                mountName = Irp->AssociatedIrp.SystemBuffer;
                                mountName->NameLength =
                                    disketteExtension->DeviceName.Length;
                                if (irpSp->Parameters.DeviceIoControl
                                        .OutputBufferLength <
                                    (ULONG)(
                                        sizeof(USHORT) +
                                        (unsigned int)mountName->NameLength)) {
                                  ntStatus = -2147483643L;
                                  Irp->IoStatus.Information =
                                      sizeof(MOUNTDEV_NAME);
                                  goto switch_16_break;
                                } else {
                                }
                                {
                                  memcpy(mountName->Name,
                                         disketteExtension->DeviceName.Buffer,
                                         mountName->NameLength);
                                  ntStatus = 0L;
                                  Irp->IoStatus.Information =
                                      sizeof(USHORT) +
                                      (unsigned int)mountName->NameLength;
                                }
                                goto switch_16_break;
                              switch_16_exp_1: /* CIL Label */;
                                {}
                                if (!disketteExtension->InterfaceString
                                         .Buffer) {
                                  ntStatus = -1073741811L;
                                  goto switch_16_break;
                                } else {
                                  if (irpSp->Parameters.DeviceIoControl
                                          .OutputBufferLength <
                                      (ULONG)sizeof(MOUNTDEV_UNIQUE_ID)) {
                                    ntStatus = -1073741811L;
                                    goto switch_16_break;
                                  } else {
                                  }
                                }
                                uniqueId = Irp->AssociatedIrp.SystemBuffer;
                                uniqueId->UniqueIdLength =
                                    disketteExtension->InterfaceString.Length;
                                if (irpSp->Parameters.DeviceIoControl
                                        .OutputBufferLength <
                                    (ULONG)(sizeof(USHORT) +
                                            (unsigned int)
                                                uniqueId->UniqueIdLength)) {
                                  ntStatus = -2147483643L;
                                  Irp->IoStatus.Information =
                                      sizeof(MOUNTDEV_UNIQUE_ID);
                                  goto switch_16_break;
                                } else {
                                }
                                {
                                  memcpy(
                                      uniqueId->UniqueId,
                                      disketteExtension->InterfaceString.Buffer,
                                      uniqueId->UniqueIdLength);
                                  ntStatus = 0L;
                                  Irp->IoStatus.Information =
                                      sizeof(USHORT) +
                                      (unsigned int)uniqueId->UniqueIdLength;
                                }
                                goto switch_16_break;
                              switch_16_exp_2: /* CIL Label */;
                              switch_16_exp_3: /* CIL Label */;
                                if (irpSp->Parameters.DeviceIoControl
                                        .InputBufferLength <
                                    (ULONG)sizeof(FORMAT_PARAMETERS)) {
                                  {}
                                  ntStatus = -1073741811L;
                                  goto switch_16_break;
                                } else {
                                }
                                {
                                  tmp___0 = FlCheckFormatParameters(
                                      disketteExtension,
                                      (struct _FORMAT_PARAMETERS *)
                                          Irp->AssociatedIrp.SystemBuffer);
                                }
                                if (tmp___0) {

                                } else {
                                  {}
                                  ntStatus = -1073741811L;
                                  goto switch_16_break;
                                }
                                if (irpSp->Parameters.DeviceIoControl
                                        .IoControlCode ==
                                    (ULONG)(((7 << 16) | (3 << 14)) |
                                            (11 << 2))) {
                                  if (irpSp->Parameters.DeviceIoControl
                                          .InputBufferLength <
                                      (ULONG)sizeof(FORMAT_EX_PARAMETERS)) {
                                    ntStatus = -1073741811L;
                                    goto switch_16_break;
                                  } else {
                                  }
                                  formatExParameters =
                                      (struct _FORMAT_EX_PARAMETERS *)
                                          Irp->AssociatedIrp.SystemBuffer;
                                  formatExParametersSize =
                                      (unsigned long)((
                                          long)(&((FORMAT_EX_PARAMETERS *)0)
                                                     ->SectorNumber)) +
                                      (unsigned long)((unsigned int)
                                                          formatExParameters
                                                              ->SectorsPerTrack *
                                                      sizeof(USHORT));
                                  if (irpSp->Parameters.DeviceIoControl
                                          .InputBufferLength <
                                      formatExParametersSize) {
                                    ntStatus = -1073741811L;
                                    goto switch_16_break;
                                  } else {
                                    if ((int)formatExParameters
                                            ->FormatGapLength >= 256) {
                                      ntStatus = -1073741811L;
                                      goto switch_16_break;
                                    } else {
                                      if ((int)formatExParameters
                                              ->SectorsPerTrack >= 256) {
                                        ntStatus = -1073741811L;
                                        goto switch_16_break;
                                      } else {
                                      }
                                    }
                                  }
                                } else {
                                }
                              switch_16_exp_4: /* CIL Label */;
                              switch_16_exp_5: /* CIL Label */;
                              switch_16_exp_6: /* CIL Label */;
                              switch_16_exp_7: /* CIL Label */;
                                {} {
                                  ntStatus = FlQueueIrpToThread(
                                      Irp, disketteExtension);
                                }
                                goto switch_16_break;
                              switch_16_exp_8: /* CIL Label */;
                              switch_16_exp_9: /* CIL Label */;
                                {}
                                lowestDriveMediaType =
                                    (DriveMediaLimits +
                                     disketteExtension->DriveType)
                                        ->LowestDriveMediaType;
                                highestDriveMediaType =
                                    (DriveMediaLimits +
                                     disketteExtension->DriveType)
                                        ->HighestDriveMediaType;
                                outputBufferLength =
                                    irpSp->Parameters.DeviceIoControl
                                        .OutputBufferLength;
                                if (outputBufferLength <
                                    (ULONG)sizeof(DISK_GEOMETRY)) {
                                  {}
                                  ntStatus = -1073741789L;
                                  goto switch_16_break;
                                } else {
                                }
                                ntStatus = 0L;
                                if (outputBufferLength <
                                    (ULONG)(
                                        sizeof(DISK_GEOMETRY) *
                                        (unsigned int)(((int)
                                                            highestDriveMediaType -
                                                        (int)
                                                            lowestDriveMediaType) +
                                                       1))) {
                                  {}
                                  ntStatus = -2147483643L;
                                  highestDriveMediaType =
                                      (enum _DRIVE_MEDIA_TYPE)(
                                          (ULONG)((int)lowestDriveMediaType -
                                                  1) +
                                          outputBufferLength /
                                              (ULONG)sizeof(DISK_GEOMETRY));
                                } else {
                                }
                                outputBuffer =
                                    (struct _DISK_GEOMETRY *)
                                        Irp->AssociatedIrp.SystemBuffer;
                                i = (unsigned char)lowestDriveMediaType;
                                {
                                  while (1) {
                                  while_25_continue: /* CIL Label */;
                                    if ((int)i <=
                                        (int)((unsigned char)
                                                  highestDriveMediaType)) {

                                    } else {
                                      goto while_25_break;
                                    }
                                    outputBuffer->MediaType =
                                        (DriveMediaConstants + i)->MediaType;
                                    outputBuffer->Cylinders.__annonCompField1
                                        .LowPart =
                                        (int)(DriveMediaConstants + i)
                                            ->MaximumTrack +
                                        1;
                                    outputBuffer->Cylinders.__annonCompField1
                                        .HighPart = 0;
                                    outputBuffer->TracksPerCylinder =
                                        (DriveMediaConstants +
                                         i)->NumberOfHeads;
                                    outputBuffer->SectorsPerTrack =
                                        (DriveMediaConstants +
                                         i)->SectorsPerTrack;
                                    outputBuffer->BytesPerSector =
                                        (DriveMediaConstants +
                                         i)->BytesPerSector;
                                    {}
                                    outputBuffer += 1;
                                    Irp->IoStatus.Information +=
                                        (ULONG_PTR)sizeof(DISK_GEOMETRY);
                                    i = (UCHAR)((int)i + 1);
                                  }
                                while_25_break: /* CIL Label */;
                                }
                                goto switch_16_break;
                              switch_16_exp_10: /* CIL Label */;
                                if ((int)((KUSER_SHARED_DATA *
                                           const)4292804608U)
                                        ->AlternativeArchitecture == 1) {
                                  {}
                                  if (!(DeviceObject->Characteristics & 1UL)) {
                                    ntStatus = -1073741275L;
                                    goto switch_16_break;
                                  } else {
                                  }
                                  if (irpSp->Parameters.DeviceIoControl
                                          .OutputBufferLength <
                                      (ULONG)sizeof(
                                          MOUNTDEV_SUGGESTED_LINK_NAME)) {
                                    ntStatus = -1073741811L;
                                    goto switch_16_break;
                                  } else {
                                  }
                                  {
                                    tmp___1 = ExAllocatePoolWithTag(
                                        1, sizeof(WCHAR) * 64U, 1886350406UL);
                                    valueName = tmp___1;
                                  }
                                  if (!valueName) {
                                    ntStatus = -1073741670L;
                                    goto switch_16_break;
                                  } else {
                                  }
                                  {
                                    memset(valueName, 0, sizeof(WCHAR) * 64U);
                                    memcpy(
                                        valueName,
                                        disketteExtension->DeviceName.Buffer,
                                        disketteExtension->DeviceName.Length);
                                    driveLetterName.Buffer =
                                        driveLetterNameBuffer;
                                    driveLetterName.MaximumLength = 20;
                                    driveLetterName.Length = 0;
                                    memset(
                                        queryTable, 0,
                                        2U * sizeof(RTL_QUERY_REGISTRY_TABLE));
                                    queryTable[0].Flags = 36;
                                    queryTable[0].Name = valueName;
                                    queryTable[0].EntryContext =
                                        &driveLetterName;
                                    ntStatus = RtlQueryRegistryValues(
                                        0, "\\\000R\000e\000g\000i\000s\000t"
                                           "\000r\000y\000\\\000M\000a\000c\000"
                                           "h\000i\000n\000e\000\\\000S\000y"
                                           "\000s\000t\000e\000m\000\\\000D\000"
                                           "I\000S\000K\000",
                                        queryTable, (void *)0, (void *)0);
                                  }
                                  if (!(ntStatus >= 0L)) {
                                    {
                                      /*                                 ExFreePool(valueName); */ /* INLINED */
                                    }
                                    goto switch_16_break;
                                  } else {
                                  }
                                  if ((int)driveLetterName.Length != 4) {
                                    {
                                      ntStatus = -1073741275L;
                                      /*                                 ExFreePool(valueName); */ /* INLINED */
                                    }
                                    goto switch_16_break;
                                  } else {
                                    if ((int)*(driveLetterName.Buffer + 0) <
                                        65) {
                                      {
                                        ntStatus = -1073741275L;
                                        /*                                   ExFreePool(valueName); */ /* INLINED */
                                      }
                                      goto switch_16_break;
                                    } else {
                                      if ((int)*(driveLetterName.Buffer + 0) >
                                          90) {
                                        {
                                          ntStatus = -1073741275L;
                                          /*                                     ExFreePool(valueName); */ /* INLINED */
                                        }
                                        goto switch_16_break;
                                      } else {
                                        if ((int)*(driveLetterName.Buffer +
                                                   1) != 58) {
                                          {
                                            ntStatus = -1073741275L;
                                            /*                                       ExFreePool(valueName); */ /* INLINED */
                                          }
                                          goto switch_16_break;
                                        } else {
                                        }
                                      }
                                    }
                                  }
                                  suggestedName =
                                      Irp->AssociatedIrp.SystemBuffer;
                                  suggestedName->UseOnlyIfThereAreNoOtherLinks =
                                      1;
                                  suggestedName->NameLength = 28;
                                  Irp->IoStatus.Information =
                                      (long)(&((MOUNTDEV_SUGGESTED_LINK_NAME
                                                    *)0)
                                                  ->Name) +
                                      28L;
                                  if (irpSp->Parameters.DeviceIoControl
                                          .OutputBufferLength <
                                      Irp->IoStatus.Information) {
                                    {
                                      Irp->IoStatus.Information =
                                          sizeof(MOUNTDEV_SUGGESTED_LINK_NAME);
                                      ntStatus = -2147483643L;
                                      /*                                 ExFreePool(valueName); */ /* INLINED */
                                    }
                                    goto switch_16_break;
                                  } else {
                                  }
                                  {
                                    RtlDeleteRegistryValue(
                                        0, "\\\000R\000e\000g\000i\000s\000t"
                                           "\000r\000y\000\\\000M\000a\000c\000"
                                           "h\000i\000n\000e\000\\\000S\000y"
                                           "\000s\000t\000e\000m\000\\\000D\000"
                                           "I\000S\000K\000",
                                        valueName);
                                    /*                               ExFreePool(valueName); */ /* INLINED */
                                    memcpy(suggestedName->Name,
                                           "\\\000D\000o\000s\000D\000e\000v"
                                           "\000i\000c\000e\000s\000\\\000",
                                           24);
                                    suggestedName->Name[12] =
                                        *(driveLetterName.Buffer + 0);
                                    suggestedName->Name[13] = ':';
                                  }
                                  goto switch_16_break;
                                } else {
                                }
                              switch_16_exp_11: /* CIL Label */;
                                if ((int)((KUSER_SHARED_DATA *
                                           const)4292804608U)
                                        ->AlternativeArchitecture == 1) {
                                  {}
                                  if (irpSp->Parameters.DeviceIoControl
                                          .OutputBufferLength <
                                      (ULONG)sizeof(SENSE_DEVISE_STATUS_PTOS)) {
                                    {}
                                    ntStatus = -1073741811L;
                                    goto switch_16_break;
                                  } else {
                                  }
                                  {} {
                                    ntStatus = FlQueueIrpToThread(
                                        Irp, disketteExtension);
                                  }
                                  goto switch_16_break;
                                } else {
                                }
                              switch_16_default: /* CIL Label */;
                                if (s == NP) {
                                  s = SKIP1;
                                } else {
                                  { errorFn(); }
                                }
                                {
                                  Irp->CurrentLocation =
                                      (CHAR)((int)Irp->CurrentLocation + 1);
                                  Irp->Tail.Overlay.__annonCompField17
                                      .__annonCompField16
                                      .CurrentStackLocation += 1;
                                  ntStatus = IofCallDriver(
                                      disketteExtension->TargetObject, Irp);
                                }
                                return (ntStatus);
                              } else {
                              switch_16_break: /* CIL Label */;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (ntStatus != 259L) {
      Irp->IoStatus.__annonCompField4.Status = ntStatus;
      myStatus = ntStatus;
      if (!(ntStatus >= 0L)) {
        if (ntStatus == -1073741661L) {
          tmp___2 = 1;
        } else {
          if (ntStatus == -1073741643L) {
            tmp___2 = 1;
          } else {
            if (ntStatus == -1073741662L) {
              tmp___2 = 1;
            } else {
              if (ntStatus == -1073741805L) {
                tmp___2 = 1;
              } else {
                if (ntStatus == -2147483626L) {
                  tmp___2 = 1;
                } else {
                  if (ntStatus == -1073741804L) {
                    tmp___2 = 1;
                  } else {
                    if (ntStatus == -1073741806L) {
                      tmp___2 = 1;
                    } else {
                      tmp___2 = 0;
                    }
                  }
                }
              }
            }
          }
        }
        if ((unsigned char)tmp___2) {
          {
            /*         IoSetHardErrorOrVerifyDevice(Irp, DeviceObject); */ /* INLINED
                                                                              */
          }
        } else {
        }
      } else {
      }
      { IofCompleteRequest(Irp, 0); }
    } else {
    }
    return (ntStatus);
  }
}
NTSTATUS FloppyPnp(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
  PIO_STACK_LOCATION irpSp;
  PDISKETTE_EXTENSION disketteExtension;
  NTSTATUS ntStatus;
  KEVENT doneEvent;
  PIO_STACK_LOCATION irpSp___0;
  PIO_STACK_LOCATION nextIrpSp;
  PIO_STACK_LOCATION irpSp___1;
  PCONFIGURATION_INFORMATION tmp;

  {
    ntStatus = 0L;
    {} {
      /*   ExAcquireFastMutex(PagingMutex); */ /* INLINED */
      PagingReferenceCount += 1UL;
    }
    if (PagingReferenceCount == 1UL) {
      { /*     MmResetDriverPaging(& DriverEntry); */ /* INLINED */
      }
    } else {
    }
    {
      /*   ExReleaseFastMutex(PagingMutex); */ /* INLINED */
      disketteExtension = DeviceObject->DeviceExtension;
      irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                  .CurrentStackLocation;
    }
    if (disketteExtension->IsRemoved) {
      {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.__annonCompField4.Status = -1073741738L;
        myStatus = -1073741738L;
        IofCompleteRequest(Irp, 0);
      }
      return (-1073741738L);
    } else {
    }
    if (irpSp->MinorFunction == 0) {
      goto switch_32_0;
    } else {
      if (irpSp->MinorFunction == 5) {
        goto switch_32_5;
      } else {
        if (irpSp->MinorFunction == 1) {
          goto switch_32_1;
        } else {
          if (irpSp->MinorFunction == 6) {
            goto switch_32_6;
          } else {
            if (irpSp->MinorFunction == 3) {
              goto switch_32_3;
            } else {
              if (irpSp->MinorFunction == 4) {
                goto switch_32_4;
              } else {
                if (irpSp->MinorFunction == 2) {
                  goto switch_32_2;
                } else {
                  {
                    goto switch_32_default;
                    if (0) {
                    switch_32_0 : /* CIL Label */
                    {
                      ntStatus = FloppyStartDevice(DeviceObject, Irp);
                    }
                      goto switch_32_break;
                    switch_32_5: /* CIL Label */;
                    switch_32_1: /* CIL Label */;
                      if ((int)irpSp->MinorFunction == 5) {
                        {}
                      } else {
                        {}
                      }
                      if (!disketteExtension->IsStarted) {
                        if (s == NP) {
                          s = SKIP1;
                        } else {
                          { errorFn(); }
                        }
                        {
                          Irp->CurrentLocation =
                              (CHAR)((int)Irp->CurrentLocation + 1);
                          Irp->Tail.Overlay.__annonCompField17
                              .__annonCompField16.CurrentStackLocation += 1;
                          ntStatus = IofCallDriver(
                              disketteExtension->TargetObject, Irp);
                        }
                        return (ntStatus);
                      } else {
                      }
                      {
                        /*                   ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
                        disketteExtension->HoldNewRequests = 1;
                        /*                   ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
                        ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
                      }
                      if (ntStatus == 259L) {
                        {
                          KeWaitForSingleObject(disketteExtension->FloppyThread,
                                                0, 0, 0, (void *)0);
                        }
                        if ((unsigned int)disketteExtension->FloppyThread !=
                            (unsigned int)((void *)0)) {
                          {
                            /*                       ObfDereferenceObject(disketteExtension->FloppyThread); */ /* INLINED */
                          }
                        } else {
                        }
                        disketteExtension->FloppyThread = (void *)0;
                        Irp->IoStatus.__annonCompField4.Status = 0L;
                        myStatus = 0L;
                        if (s == NP) {
                          s = SKIP1;
                        } else {
                          { errorFn(); }
                        }
                        {
                          Irp->CurrentLocation =
                              (CHAR)((int)Irp->CurrentLocation + 1);
                          Irp->Tail.Overlay.__annonCompField17
                              .__annonCompField16.CurrentStackLocation += 1;
                          ntStatus = IofCallDriver(
                              disketteExtension->TargetObject, Irp);
                        }
                      } else {
                        {
                          ntStatus = -1073741823L;
                          Irp->IoStatus.__annonCompField4.Status = ntStatus;
                          myStatus = ntStatus;
                          Irp->IoStatus.Information = 0;
                          IofCompleteRequest(Irp, 0);
                        }
                      }
                      goto switch_32_break;
                    switch_32_6: /* CIL Label */;
                    switch_32_3: /* CIL Label */;
                      if ((int)irpSp->MinorFunction == 6) {
                        {}
                      } else {
                        {}
                      }
                      if (!disketteExtension->IsStarted) {
                        Irp->IoStatus.__annonCompField4.Status = 0L;
                        myStatus = 0L;
                        if (s == NP) {
                          s = SKIP1;
                        } else {
                          { errorFn(); }
                        }
                        {
                          Irp->CurrentLocation =
                              (CHAR)((int)Irp->CurrentLocation + 1);
                          Irp->Tail.Overlay.__annonCompField17
                              .__annonCompField16.CurrentStackLocation += 1;
                          ntStatus = IofCallDriver(
                              disketteExtension->TargetObject, Irp);
                        }
                      } else {
                        {
                          Irp->IoStatus.__annonCompField4.Status = 0L;
                          myStatus = 0L;
                          irpSp___0 =
                              Irp->Tail.Overlay.__annonCompField17
                                  .__annonCompField16.CurrentStackLocation;
                          nextIrpSp =
                              Irp->Tail.Overlay.__annonCompField17
                                  .__annonCompField16.CurrentStackLocation -
                              1;
                          memcpy(nextIrpSp, irpSp___0,
                                 (long)(&((IO_STACK_LOCATION *)0)
                                             ->CompletionRoutine));
                          nextIrpSp->Control = 0;
                          /*                     KeInitializeEvent(& doneEvent, 1, 0); */ /* INLINED */
                        }
                        if (s != NP) {
                          { errorFn(); }
                        } else {
                          if (compRegistered != 0) {
                            { errorFn(); }
                          } else {
                            compRegistered = 1;
                            compFptr = &FloppyPnpComplete;
                          }
                        }
                        {
                          irpSp___1 =
                              Irp->Tail.Overlay.__annonCompField17
                                  .__annonCompField16.CurrentStackLocation -
                              1;
                          irpSp___1->CompletionRoutine = &FloppyPnpComplete;
                          irpSp___1->Context = &doneEvent;
                          irpSp___1->Control = 0;
                          irpSp___1->Control = 64;
                          irpSp___1->Control = (int)irpSp___1->Control | 128;
                          irpSp___1->Control = (int)irpSp___1->Control | 32;
                          ntStatus = IofCallDriver(
                              disketteExtension->TargetObject, Irp);
                        }
                        if (ntStatus == 259L) {
                          {
                            KeWaitForSingleObject(&doneEvent, 0, 0, 0,
                                                  (void *)0);
                            ntStatus = myStatus;
                          }
                        } else {
                        }
                        {
                          /*                     ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
                          disketteExtension->HoldNewRequests = 0;
                          /*                     ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
                          FloppyProcessQueuedRequests(disketteExtension);
                          Irp->IoStatus.__annonCompField4.Status = ntStatus;
                          myStatus = ntStatus;
                          Irp->IoStatus.Information = 0;
                          IofCompleteRequest(Irp, 0);
                        }
                      }
                      goto switch_32_break;
                    switch_32_4: /* CIL Label */;
                      {}
                      disketteExtension->IsStarted = 0;
                      Irp->IoStatus.__annonCompField4.Status = 0L;
                      myStatus = 0L;
                      if (s == NP) {
                        s = SKIP1;
                      } else {
                        { errorFn(); }
                      }
                      {
                        Irp->CurrentLocation =
                            (CHAR)((int)Irp->CurrentLocation + 1);
                        Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                            .CurrentStackLocation += 1;
                        ntStatus =
                            IofCallDriver(disketteExtension->TargetObject, Irp);
                      }
                      goto switch_32_break;
                    switch_32_2: /* CIL Label */;
                      {} {
                        /*                   ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
                        disketteExtension->HoldNewRequests = 0;
                        /*                   ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
                        disketteExtension->IsStarted = 0;
                        disketteExtension->IsRemoved = 1;
                        FloppyProcessQueuedRequests(disketteExtension);
                      }
                      if (s == NP) {
                        s = SKIP1;
                      } else {
                        { errorFn(); }
                      }
                      {
                        Irp->CurrentLocation =
                            (CHAR)((int)Irp->CurrentLocation + 1);
                        Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                            .CurrentStackLocation += 1;
                        Irp->IoStatus.__annonCompField4.Status = 0L;
                        myStatus = 0L;
                        ntStatus =
                            IofCallDriver(disketteExtension->TargetObject, Irp);
                      }
                      if ((unsigned int)disketteExtension->InterfaceString
                              .Buffer != (unsigned int)((void *)0)) {
                        {
                          IoSetDeviceInterfaceState(
                              &disketteExtension->InterfaceString, 0);
                          /*                     RtlFreeUnicodeString(& disketteExtension->InterfaceString); */ /* INLINED */
                          /*                     RtlInitUnicodeString(& disketteExtension->InterfaceString, (void *)0); */ /* INLINED */
                        }
                      } else {
                      }
                      {
                        /*                   RtlFreeUnicodeString(& disketteExtension->DeviceName); */ /* INLINED */
                        /*                   RtlInitUnicodeString(& disketteExtension->DeviceName, (void *)0); */ /* INLINED */
                      }
                      if ((int)disketteExtension->ArcName.Length != 0) {
                        {
                          IoDeleteSymbolicLink(&disketteExtension->ArcName);
                          /*                     RtlFreeUnicodeString(& disketteExtension->ArcName); */ /* INLINED */
                          /*                     RtlInitUnicodeString(& disketteExtension->ArcName, (void *)0); */ /* INLINED */
                        }
                      } else {
                      }
                      {
                        /*                   IoDetachDevice(disketteExtension->TargetObject); */ /* INLINED */
                        /*                   IoDeleteDevice(DeviceObject); */ /* INLINED */
                        tmp = IoGetConfigurationInformation();
                        tmp->FloppyCount -= 1UL;
                      }
                      goto switch_32_break;
                    switch_32_default: /* CIL Label */;
                      {}
                      if (s == NP) {
                        s = SKIP1;
                      } else {
                        { errorFn(); }
                      }
                      {
                        Irp->CurrentLocation =
                            (CHAR)((int)Irp->CurrentLocation + 1);
                        Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                            .CurrentStackLocation += 1;
                        ntStatus =
                            IofCallDriver(disketteExtension->TargetObject, Irp);
                      }
                    } else {
                    switch_32_break: /* CIL Label */;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
      /*   ExAcquireFastMutex(PagingMutex); */ /* INLINED */
      PagingReferenceCount -= 1UL;
    }
    if (PagingReferenceCount == 0UL) {
      { /* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
      }
    } else {
    }
    { /*   ExReleaseFastMutex(PagingMutex); */ /* INLINED */
    }
    return (ntStatus);
  }
}
NTSTATUS FloppyStartDevice(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
  NTSTATUS ntStatus;
  NTSTATUS pnpStatus;
  KEVENT doneEvent;
  FDC_INFO fdcInfo;
  CONFIGURATION_TYPE Dc;
  CONFIGURATION_TYPE Fp;
  PDISKETTE_EXTENSION disketteExtension;
  PIO_STACK_LOCATION irpSp;
  PIO_STACK_LOCATION irpSp___0;
  PIO_STACK_LOCATION nextIrpSp;
  PIO_STACK_LOCATION irpSp___1;
  INTERFACE_TYPE InterfaceType;

  {
    Dc = 13;
    Fp = 26;
    disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
    irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                .CurrentStackLocation;
    {} {} {} {
      /*   KeInitializeEvent(& doneEvent, 0, 0); */ /* INLINED */
      irpSp___0 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                      .CurrentStackLocation;
      nextIrpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                      .CurrentStackLocation -
                  1;
      memcpy(nextIrpSp, irpSp___0,
             (long)(&((IO_STACK_LOCATION *)0)->CompletionRoutine));
      nextIrpSp->Control = 0;
    }
    if (s != NP) {
      { errorFn(); }
    } else {
      if (compRegistered != 0) {
        { errorFn(); }
      } else {
        compRegistered = 1;
        compFptr = &FloppyPnpComplete;
      }
    }
    {
      irpSp___1 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                      .CurrentStackLocation -
                  1;
      irpSp___1->CompletionRoutine = &FloppyPnpComplete;
      irpSp___1->Context = &doneEvent;
      irpSp___1->Control = 0;
      irpSp___1->Control = 64;
      irpSp___1->Control = (int)irpSp___1->Control | 128;
      irpSp___1->Control = (int)irpSp___1->Control | 32;
      ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
    }
    if (ntStatus == 259L) {
      {
        ntStatus = KeWaitForSingleObject(&doneEvent, 0, 0, 0, (void *)0);
        ntStatus = myStatus;
      }
    } else {
    }
    {
      fdcInfo.BufferCount = 0;
      fdcInfo.BufferSize = 0;
      ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject,
                               ((7 << 16) | (770 << 2)) | 3, &fdcInfo);
    }
    if (ntStatus >= 0L) {
      disketteExtension->MaxTransferSize = fdcInfo.MaxTransferSize;
      if (fdcInfo.AcpiBios) {
        if (fdcInfo.AcpiFdiSupported) {
          { ntStatus = FlAcpiConfigureFloppy(disketteExtension, &fdcInfo); }
          if ((int)disketteExtension->DriveType == 4) {
            disketteExtension->PerpendicularMode =
                (int)disketteExtension->PerpendicularMode |
                (1 << fdcInfo.PeripheralNumber);
          } else {
          }
        } else {
          goto _L;
        }
      } else {
      _L: /* CIL Label */
        if ((int)disketteExtension->DriveType == 4) {
          disketteExtension->PerpendicularMode =
              (int)disketteExtension->PerpendicularMode |
              (1 << fdcInfo.PeripheralNumber);
        } else {
        }
        InterfaceType = 0;
        {
          while (1) {
          while_43_continue: /* CIL Label */;
            if ((int)InterfaceType < 16) {

            } else {
              goto while_43_break;
            }
            {
              fdcInfo.BusType = InterfaceType;
              ntStatus = IoQueryDeviceDescription(
                  &fdcInfo.BusType, &fdcInfo.BusNumber, &Dc,
                  &fdcInfo.ControllerNumber, &Fp, &fdcInfo.PeripheralNumber,
                  &FlConfigCallBack, disketteExtension);
            }
            if (ntStatus >= 0L) {
              {}
              goto while_43_break;
            } else {
            }
            InterfaceType = (INTERFACE_TYPE)((int)InterfaceType + 1);
          }
        while_43_break: /* CIL Label */;
        }
      }
      if (ntStatus >= 0L) {
        if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                ->AlternativeArchitecture == 1) {
          disketteExtension->DeviceUnit = (unsigned char)fdcInfo.UnitNumber;
          disketteExtension->DriveOnValue = (unsigned char)fdcInfo.UnitNumber;
        } else {
          disketteExtension->DeviceUnit =
              (unsigned char)fdcInfo.PeripheralNumber;
          disketteExtension->DriveOnValue =
              (unsigned char)(fdcInfo.PeripheralNumber |
                              (unsigned long)(16 << fdcInfo.PeripheralNumber));
        }
        {
          pnpStatus = IoRegisterDeviceInterface(
              disketteExtension->UnderlyingPDO,
              (GUID *)(&MOUNTDEV_MOUNTED_DEVICE_GUID), (void *)0,
              &disketteExtension->InterfaceString);
        }
        if (pnpStatus >= 0L) {
          {
            pnpStatus = IoSetDeviceInterfaceState(
                &disketteExtension->InterfaceString, 1);
          }
        } else {
        }
        {
          disketteExtension->IsStarted = 1;
          /*       ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
          disketteExtension->HoldNewRequests = 0;
          /*       ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
          FloppyProcessQueuedRequests(disketteExtension);
        }
      } else {
      }
    } else {
    }
    {
      Irp->IoStatus.__annonCompField4.Status = ntStatus;
      myStatus = ntStatus;
      IofCompleteRequest(Irp, 0);
    }
    return (ntStatus);
  }
}
NTSTATUS FloppyPnpComplete(PDEVICE_OBJECT DeviceObject, PIRP Irp,
                           PVOID Context) {

  {
    { KeSetEvent((struct _KEVENT *)Context, 1, 0); }
    return (-1073741802L);
  }
}
NTSTATUS FloppyPower(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
  PDISKETTE_EXTENSION disketteExtension;
  NTSTATUS ntStatus;
  PIO_STACK_LOCATION irpSp;
  POWER_STATE_TYPE type;
  POWER_STATE state;
  BOOLEAN WaitForCompletion;

  {
    ntStatus = myStatus;
    WaitForCompletion = 1;
    {}
    disketteExtension = DeviceObject->DeviceExtension;
    irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                .CurrentStackLocation;
    type = irpSp->Parameters.Power.Type;
    state = irpSp->Parameters.Power.State;
    if (irpSp->MinorFunction == 3) {
      goto switch_46_3;
    } else {
      if (irpSp->MinorFunction == 2) {
        goto switch_46_2;
      } else {
        {
          goto switch_46_default;
          if (0) {
          switch_46_3: /* CIL Label */;
            {}
            if ((int)type == 0) {
              if ((int)state.SystemState > 5) {
                ntStatus = 0L;
                goto switch_46_break;
              } else {
              }
            } else {
            }
            {
              /*         ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
            }
            if (disketteExtension->ThreadReferenceCount >= 0L) {
              {
                  /*           ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
              } {} {
                /*           PoStartNextPowerIrp(Irp); */ /* INLINED */
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.__annonCompField4.Status = -2147483631L;
                myStatus = -2147483631L;
                IofCompleteRequest(Irp, 0);
              }
              return (-2147483631L);
            } else {
            }
            {
              /*         ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
              ntStatus = 0L;
            }
            goto switch_46_break;
          switch_46_2: /* CIL Label */;
            if ((int)type == 0) {
              {
                /*           ExAcquireFastMutex(& disketteExtension->PowerDownMutex); */ /* INLINED */
              }
              if ((int)state.SystemState == 1) {
                {}
                disketteExtension->PoweringDown = 0;
                WaitForCompletion = 0;
              } else {
                {}
                WaitForCompletion = 1;
                disketteExtension->PoweringDown = 1;
              }
              {
                /*           ExReleaseFastMutex(& disketteExtension->PowerDownMutex); */ /* INLINED */
              }
              if ((unsigned int)disketteExtension->FloppyThread !=
                  (unsigned int)((void *)0)) {
                if ((int)WaitForCompletion == 1) {
                  {
                    KeWaitForSingleObject(disketteExtension->FloppyThread, 0, 0,
                                          0, (void *)0);
                  }
                } else {
                }
              } else {
              }
            } else {
            }
            {}
            ntStatus = 0L;
            goto switch_46_break;
          switch_46_default: /* CIL Label */;
            goto switch_46_break;
          } else {
          switch_46_break: /* CIL Label */;
          }
        }
      }
    }
    { /*   PoStartNextPowerIrp(Irp); */ /* INLINED */
    }
    if (s == NP) {
      s = SKIP1;
    } else {
      { errorFn(); }
    }
    {
      Irp->CurrentLocation = (CHAR)((int)Irp->CurrentLocation + 1);
      Irp->Tail.Overlay.__annonCompField17.__annonCompField16
          .CurrentStackLocation += 1;
      ntStatus = PoCallDriver(disketteExtension->TargetObject, Irp);
    }
    return (ntStatus);
  }
}
NTSTATUS FloppyReadWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
  PIO_STACK_LOCATION irpSp;
  NTSTATUS ntStatus;
  PDISKETTE_EXTENSION disketteExtension;

  {
    {} {
      disketteExtension = DeviceObject->DeviceExtension;
      irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                  .CurrentStackLocation;
      /*   ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED
                                                                           */
    }
    if (disketteExtension->HoldNewRequests) {
      {
        ntStatus = FloppyQueueRequest(disketteExtension, Irp);
        /*     ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED
                                                                               */
      }
      return (ntStatus);
    } else {
    }
    {
      /*   ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED
                                                                           */
    }
    if (disketteExtension->IsRemoved) {
      goto _L;
    } else {
      if (!disketteExtension->IsStarted) {
      _L: /* CIL Label */
        if (disketteExtension->IsRemoved) {
          ntStatus = -1073741738L;
        } else {
          ntStatus = -1073741823L;
        }
        {
          Irp->IoStatus.Information = 0;
          Irp->IoStatus.__annonCompField4.Status = ntStatus;
          myStatus = ntStatus;
          IofCompleteRequest(Irp, 0);
        }
        return (ntStatus);
      } else {
      }
    }
    if ((int)disketteExtension->MediaType > 0) {
      if (irpSp->Parameters.Read.ByteOffset.__annonCompField1.LowPart +
              irpSp->Parameters.Read.Length >
          disketteExtension->ByteCapacity) {
        goto _L___1;
      } else {
        if ((irpSp->Parameters.Read.Length &
             (disketteExtension->BytesPerSector - 1UL)) != 0UL) {
        _L___1 : /* CIL Label */
        {}
          {}
          ntStatus = -1073741811L;
        } else {
          goto _L___0;
        }
      }
    } else {
    _L___0: /* CIL Label */
      if (irpSp->Parameters.Read.Length) {
        {} { ntStatus = FlQueueIrpToThread(Irp, disketteExtension); }
      } else {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.__annonCompField4.Status = 0L;
        myStatus = 0L;
        {} { IofCompleteRequest(Irp, 0); }
        return (0L);
      }
    }
    if (ntStatus != 259L) {
      Irp->IoStatus.__annonCompField4.Status = ntStatus;
      myStatus = ntStatus;
      {} { IofCompleteRequest(Irp, 0); }
    } else {
    }
    return (ntStatus);
  }
}
NTSTATUS FlInterpretError(UCHAR StatusRegister1, UCHAR StatusRegister2) {

  {
    if ((int)StatusRegister1 & 32) {
      goto _L;
    } else {
      if ((int)StatusRegister2 & 32) {
      _L : /* CIL Label */
      {}
        return (-1073741761L);
      } else {
      }
    }
    if ((int)StatusRegister1 & 16) {
      {}
      return (-1073741764L);
    } else {
    }
    if ((int)StatusRegister1 & 4) {
      goto _L___0;
    } else {
      if ((int)StatusRegister1 & 128) {
      _L___0 : /* CIL Label */
      {}
        return (-1073741803L);
      } else {
      }
    }
    if ((int)StatusRegister2 & 1) {
      goto _L___1;
    } else {
      if ((int)StatusRegister2 & 2) {
        goto _L___1;
      } else {
        if ((int)StatusRegister2 & 64) {
        _L___1 : /* CIL Label */
        {}
          return (-1073741668L);
        } else {
        }
      }
    }
    if ((int)StatusRegister1 & 2) {
      {}
      return (-1073741662L);
    } else {
    }
    if ((int)StatusRegister1 & 1) {
      {}
      return (-1073741467L);
    } else {
    }
    if ((int)StatusRegister2 & 16) {
      {}
      return (-1073741466L);
    } else {
    }
    {}
    return (-1073741465L);
  }
}
void FlFinishOperation(PIRP Irp, PDISKETTE_EXTENSION DisketteExtension) {
  NTSTATUS ntStatus;
  int tmp;

  {
    {}
    if (myStatus != 0L) {
      if (DisketteExtension->HardwareFailed) {
        DisketteExtension->HardwareFailCount =
            (UCHAR)((int)DisketteExtension->HardwareFailCount + 1);
        if ((int)DisketteExtension->HardwareFailCount < 2) {
          { ntStatus = FlInitializeControllerHardware(DisketteExtension); }
          if (ntStatus >= 0L) {
            {}
            DisketteExtension->MediaType = -1;
            {} {
              /*           ExAcquireFastMutex(& DisketteExtension->ThreadReferenceMutex); */ /* INLINED */
              DisketteExtension->ThreadReferenceCount += 1L;
              /*           ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex); */ /* INLINED */
              ExfInterlockedInsertHeadList(
                  &DisketteExtension->ListEntry,
                  &Irp->Tail.Overlay.__annonCompField17.ListEntry,
                  &DisketteExtension->ListSpinLock);
            }
            return;
          } else {
          }
          {}
        } else {
        }
      } else {
      }
    } else {
    }
    DisketteExtension->HardwareFailCount = 0;
    if (!(myStatus >= 0L)) {
      if (myStatus == -1073741661L) {
        tmp = 1;
      } else {
        if (myStatus == -1073741643L) {
          tmp = 1;
        } else {
          if (myStatus == -1073741662L) {
            tmp = 1;
          } else {
            if (myStatus == -1073741805L) {
              tmp = 1;
            } else {
              if (myStatus == -2147483626L) {
                tmp = 1;
              } else {
                if (myStatus == -1073741804L) {
                  tmp = 1;
                } else {
                  if (myStatus == -1073741806L) {
                    tmp = 1;
                  } else {
                    tmp = 0;
                  }
                }
              }
            }
          }
        }
      }
      if ((unsigned char)tmp) {
        {
          /*       IoSetHardErrorOrVerifyDevice(Irp, DisketteExtension->DeviceObject); */ /* INLINED */
        }
      } else {
      }
    } else {
    }
    if (myStatus != 0L) {
      if (myStatus != -2147483626L) {
        if (myStatus != -1073741805L) {
          {}
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
    _L___0 : /* CIL Label */
    {}
    }
    {} {} { IofCompleteRequest(Irp, 1); }
    return;
  }
}
NTSTATUS FlStartDrive(PDISKETTE_EXTENSION DisketteExtension, PIRP Irp,
                      BOOLEAN WriteOperation, BOOLEAN SetUpMedia,
                      BOOLEAN IgnoreChange) {
  LARGE_INTEGER delay;
  BOOLEAN motorStarted;
  UCHAR driveStatus;
  NTSTATUS ntStatus;
  FDC_ENABLE_PARMS fdcEnableParms;
  FDC_DISK_CHANGE_PARMS fdcDiskChangeParms;

  {
    ntStatus = 0L;
    {} * (DriveMediaConstants +
          (DriveMediaLimits + DisketteExtension->DriveType)
              ->HighestDriveMediaType) =
        DisketteExtension->BiosDriveMediaConstants;
    if ((int)DisketteExtension->MediaType == -1) {
      DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + 0);
    } else {
      if ((int)DisketteExtension->MediaType == 0) {
        DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + 0);
      } else {
      }
    }
    fdcEnableParms.DriveOnValue = DisketteExtension->DriveOnValue;
    if (WriteOperation) {
      fdcEnableParms.TimeToWait =
          DisketteExtension->DriveMediaConstants.MotorSettleTimeWrite;
    } else {
      fdcEnableParms.TimeToWait =
          DisketteExtension->DriveMediaConstants.MotorSettleTimeRead;
    }
    {
      ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject,
                               ((7 << 16) | (774 << 2)) | 3, &fdcEnableParms);
      motorStarted = fdcEnableParms.MotorStarted;
    }
    if (ntStatus >= 0L) {
      {
        fdcDiskChangeParms.DriveOnValue = DisketteExtension->DriveOnValue;
        ntStatus =
            FlFdcDeviceIo(DisketteExtension->TargetObject,
                          ((7 << 16) | (776 << 2)) | 3, &fdcDiskChangeParms);
        driveStatus = fdcDiskChangeParms.DriveStatus;
      }
    } else {
    }
    if (!(ntStatus >= 0L)) {
      return (ntStatus);
    } else {
    }
    if ((int)DisketteExtension->DriveType == 0) {
      if (motorStarted) {
        goto _L___1;
      } else {
        goto _L___3;
      }
    } else {
    _L___3: /* CIL Label */
      if ((int)DisketteExtension->DriveType != 0) {
        if ((int)driveStatus & 128) {
        _L___1 : /* CIL Label */
        {}
          DisketteExtension->MediaType = -1;
          if ((int)((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
            if (Irp) {
              {
                /*             IoSetHardErrorOrVerifyDevice(Irp, DisketteExtension->DeviceObject); */ /* INLINED */
              }
            } else {
            }
            (DisketteExtension->DeviceObject)->Flags |= 2UL;
          } else {
          }
          if ((int)DisketteExtension->DriveType != 0) {
            if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                    ->AlternativeArchitecture == 1) {
              {
                DisketteExtension->FifoBuffer[0] = 14;
                DisketteExtension->FifoBuffer[1] =
                    DisketteExtension->DeviceUnit;
                ntStatus = FlIssueCommand(
                    DisketteExtension, DisketteExtension->FifoBuffer,
                    DisketteExtension->FifoBuffer, (void *)0, 0, 0);
              }
              if (!(ntStatus >= 0L)) {
                {}
                return (ntStatus);
              } else {
              }
              if ((int)DisketteExtension->FifoBuffer[0] & 32) {
                driveStatus = 127;
              } else {
                driveStatus = 128;
              }
              if ((int)driveStatus & 128) {
                {}
                if ((int)((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
                  (DisketteExtension->DeviceObject)->Flags &= 4294967293UL;
                } else {
                }
                return (-1073741805L);
              } else {
              }
            } else {
            }
            {
              DisketteExtension->FifoBuffer[0] = 16;
              DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
              DisketteExtension->FifoBuffer[2] = 1;
              ntStatus = FlIssueCommand(
                  DisketteExtension, DisketteExtension->FifoBuffer,
                  DisketteExtension->FifoBuffer, (void *)0, 0, 0);
            }
            if (!(ntStatus >= 0L)) {
              {}
              return (ntStatus);
            } else {
              if (!((int)DisketteExtension->FifoBuffer[0] & 32)) {
                goto _L;
              } else {
                if ((int)DisketteExtension->FifoBuffer[1] != 1) {
                _L : /* CIL Label */
                {}
                  DisketteExtension->HardwareFailed = 1;
                  return (-1073741464L);
                } else {
                }
              }
            }
            {
              DisketteExtension->FifoBuffer[0] = 16;
              DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
              DisketteExtension->FifoBuffer[2] = 0;
              delay.__annonCompField1.LowPart = 4294966396UL;
              delay.__annonCompField1.HighPart = -1;
              KeDelayExecutionThread(0, 0, &delay);
              ntStatus = FlIssueCommand(
                  DisketteExtension, DisketteExtension->FifoBuffer,
                  DisketteExtension->FifoBuffer, (void *)0, 0, 0);
              delay.__annonCompField1.LowPart = 4294967291UL;
              delay.__annonCompField1.HighPart = -1;
              KeDelayExecutionThread(0, 0, &delay);
            }
            if (!(ntStatus >= 0L)) {
              {}
              return (ntStatus);
            } else {
              if (!((int)DisketteExtension->FifoBuffer[0] & 32)) {
                goto _L___0;
              } else {
                if ((int)DisketteExtension->FifoBuffer[1] != 0) {
                _L___0 : /* CIL Label */
                {}
                  DisketteExtension->HardwareFailed = 1;
                  return (-1073741464L);
                } else {
                }
              }
            }
            if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                    ->AlternativeArchitecture == 1) {
              {
                DisketteExtension->FifoBuffer[0] = 14;
                DisketteExtension->FifoBuffer[1] =
                    DisketteExtension->DeviceUnit;
                ntStatus = FlIssueCommand(
                    DisketteExtension, DisketteExtension->FifoBuffer,
                    DisketteExtension->FifoBuffer, (void *)0, 0, 0);
              }
              if (!(ntStatus >= 0L)) {
                {}
                return (ntStatus);
              } else {
              }
              if ((int)DisketteExtension->FifoBuffer[0] & 32) {
                driveStatus = 127;
              } else {
                driveStatus = 128;
              }
            } else {
              {
                ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject,
                                         ((7 << 16) | (776 << 2)) | 3,
                                         &fdcDiskChangeParms);
                driveStatus = fdcDiskChangeParms.DriveStatus;
              }
              if (!(ntStatus >= 0L)) {
                return (ntStatus);
              } else {
              }
            }
            if ((int)driveStatus & 128) {
              {}
              if ((int)((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
                (DisketteExtension->DeviceObject)->Flags &= 4294967293UL;
              } else {
              }
              return (-1073741805L);
            } else {
            }
          } else {
          }
          if ((int)IgnoreChange == 0) {
            if ((int)((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
              {}
              return (-2147483626L);
            } else {
              return (-1073741435L);
            }
          } else {
          }
        } else {
          goto _L___2;
        }
      } else {
      _L___2: /* CIL Label */
        if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                ->AlternativeArchitecture == 1) {
          { FlHdbit(DisketteExtension); }
        } else {
        }
      }
    }
    if (SetUpMedia) {
      if ((int)DisketteExtension->MediaType == -1) {
        { ntStatus = FlDetermineMediaType(DisketteExtension); }
      } else {
        if ((int)DisketteExtension->MediaType == 0) {
          {}
          return (-1073741804L);
        } else {
          if ((int)DisketteExtension->DriveMediaType !=
              (int)DisketteExtension->LastDriveMediaType) {
            { ntStatus = FlDatarateSpecifyConfigure(DisketteExtension); }
            if (!(ntStatus >= 0L)) {
              {}
            } else {
            }
          } else {
          }
        }
      }
    } else {
    }
    if (WriteOperation) {
      if (ntStatus >= 0L) {
        {
          DisketteExtension->FifoBuffer[0] = 14;
          DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
          ntStatus =
              FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                             DisketteExtension->FifoBuffer, (void *)0, 0, 0);
        }
        if (!(ntStatus >= 0L)) {
          {}
          return (ntStatus);
        } else {
        }
        if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                ->AlternativeArchitecture == 1) {
          if (!((int)DisketteExtension->FifoBuffer[0] & 32)) {
            {}
            return (-1073741805L);
          } else {
          }
        } else {
        }
        if ((int)DisketteExtension->FifoBuffer[0] & 64) {
          {}
          return (-1073741662L);
        } else {
        }
      } else {
      }
    } else {
    }
    return (ntStatus);
  }
}
NTSTATUS FlDatarateSpecifyConfigure(PDISKETTE_EXTENSION DisketteExtension) {
  NTSTATUS ntStatus;

  {
    ntStatus = 0L;
    if (DisketteExtension->ControllerConfigurable) {
      DisketteExtension->FifoBuffer[0] = 17;
      DisketteExtension->FifoBuffer[1] = 0;
      DisketteExtension->FifoBuffer[2] = 15;
      DisketteExtension->FifoBuffer[2] =
          (int)DisketteExtension->FifoBuffer[2] + 16;
      if (!DisketteExtension->DriveMediaConstants.CylinderShift) {
        DisketteExtension->FifoBuffer[2] =
            (int)DisketteExtension->FifoBuffer[2] + 64;
      } else {
      }
      {
        DisketteExtension->FifoBuffer[3] = 0;
        ntStatus =
            FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                           DisketteExtension->FifoBuffer, (void *)0, 0, 0);
      }
      if (ntStatus == -1073741661L) {
        DisketteExtension->ControllerConfigurable = 0;
        ntStatus = 0L;
      } else {
      }
    } else {
    }
    if (ntStatus >= 0L) {
      goto _L;
    } else {
      if (ntStatus == -1073741661L) {
      _L : /* CIL Label */
      {
        DisketteExtension->FifoBuffer[0] = 13;
        DisketteExtension->FifoBuffer[1] =
            DisketteExtension->DriveMediaConstants.StepRateHeadUnloadTime;
        DisketteExtension->FifoBuffer[2] =
            DisketteExtension->DriveMediaConstants.HeadLoadTime;
        ntStatus =
            FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                           DisketteExtension->FifoBuffer, (void *)0, 0, 0);
      }
        if (ntStatus >= 0L) {
          {
            ntStatus = FlFdcDeviceIo(
                DisketteExtension->TargetObject, ((7 << 16) | (777 << 2)) | 3,
                &DisketteExtension->DriveMediaConstants.DataTransferRate);
          }
          if (ntStatus >= 0L) {
            { ntStatus = FlRecalibrateDrive(DisketteExtension); }
          } else {
          }
        } else {
          {}
        }
      } else {
        {}
      }
    }
    if (ntStatus >= 0L) {
      DisketteExtension->LastDriveMediaType = DisketteExtension->DriveMediaType;
    } else {
      DisketteExtension->LastDriveMediaType = 0;
      {}
    }
    return (ntStatus);
  }
}
NTSTATUS FlRecalibrateDrive(PDISKETTE_EXTENSION DisketteExtension) {
  NTSTATUS ntStatus;
  UCHAR recalibrateCount;
  UCHAR fifoBuffer[2];

  {
    recalibrateCount = 0;
    {
      while (1) {
      while_93_continue: /* CIL Label */;
        {
          DisketteExtension->FifoBuffer[0] = 11;
          DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
          ntStatus =
              FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                             DisketteExtension->FifoBuffer, (void *)0, 0, 0);
        }
        if (!(ntStatus >= 0L)) {
          {}
        } else {
        }
        if (ntStatus >= 0L) {
          if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                  ->AlternativeArchitecture == 1) {
            {
              fifoBuffer[0] = DisketteExtension->FifoBuffer[0];
              fifoBuffer[1] = DisketteExtension->FifoBuffer[1];
              DisketteExtension->FifoBuffer[0] = 14;
              DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
              ntStatus = FlIssueCommand(
                  DisketteExtension, DisketteExtension->FifoBuffer,
                  DisketteExtension->FifoBuffer, (void *)0, 0, 0);
            }
            if (!(ntStatus >= 0L)) {
              {}
              return (ntStatus);
            } else {
            }
            DisketteExtension->FifoBuffer[0] = fifoBuffer[0];
            DisketteExtension->FifoBuffer[1] = fifoBuffer[1];
          } else {
          }
          if (!((int)DisketteExtension->FifoBuffer[0] & 32)) {
            goto _L;
          } else {
            if ((int)DisketteExtension->FifoBuffer[1] != 0) {
            _L : /* CIL Label */
            {}
              DisketteExtension->HardwareFailed = 1;
              ntStatus = -1073741464L;
            } else {
            }
          }
        } else {
        }
        recalibrateCount = (UCHAR)((int)recalibrateCount + 1);
        if (!(ntStatus >= 0L)) {
          if ((int)recalibrateCount < 2) {

          } else {
            goto while_93_break;
          }
        } else {
          goto while_93_break;
        }
      }
    while_93_break: /* CIL Label */;
    }
    {}
    return (ntStatus);
  }
}
NTSTATUS FlDetermineMediaType(PDISKETTE_EXTENSION DisketteExtension) {
  NTSTATUS ntStatus;
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants;
  BOOLEAN mediaTypesExhausted;
  ULONG retries;
  USHORT sectorLengthCode;
  PBOOT_SECTOR_INFO bootSector;
  LARGE_INTEGER offset;
  PIRP irp;
  int tmp;
  PVOID tmp___0;
  int tmp___1;

  {
    retries = 0;
    {}
    DisketteExtension->IsReadOnly = 0;
    retries = 0;
    {
      while (1) {
      while_99_continue: /* CIL Label */;
        if (retries < 3UL) {

        } else {
          goto while_99_break;
        }
        if (retries) {
          {} { FlInitializeControllerHardware(DisketteExtension); }
        } else {
        }
        DisketteExtension->DriveMediaType =
            (DriveMediaLimits + DisketteExtension->DriveType)
                ->HighestDriveMediaType;
        DisketteExtension->DriveMediaConstants =
            *(DriveMediaConstants + DisketteExtension->DriveMediaType);
        mediaTypesExhausted = 0;
        {
          while (1) {
          while_101_continue: /* CIL Label */;
            if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                    ->AlternativeArchitecture == 1) {
              {
                sectorLengthCode =
                    (DriveMediaConstants + DisketteExtension->DriveMediaType)
                        ->SectorLengthCode;
                FlHdbit(DisketteExtension);
              }
            } else {
            }
            { ntStatus = FlDatarateSpecifyConfigure(DisketteExtension); }
            if (!(ntStatus >= 0L)) {
              {}
              mediaTypesExhausted = 1;
            } else {
              {
                driveMediaConstants =
                    DriveMediaConstants + DisketteExtension->DriveMediaType;
                DisketteExtension->FifoBuffer[1] =
                    (unsigned char)((int)DisketteExtension->DeviceUnit |
                                    (((int)driveMediaConstants->NumberOfHeads -
                                      1)
                                     << 2));
                DisketteExtension->FifoBuffer[0] = 84;
                ntStatus = FlIssueCommand(
                    DisketteExtension, DisketteExtension->FifoBuffer,
                    DisketteExtension->FifoBuffer, (void *)0, 0, 0);
              }
              if (!(ntStatus >= 0L)) {
                goto _L;
              } else {
                if (((int)DisketteExtension->FifoBuffer[0] & -33) !=
                    (int)((unsigned char)((int)DisketteExtension->DeviceUnit |
                                          (((int)driveMediaConstants
                                                ->NumberOfHeads -
                                            1)
                                           << 2)))) {
                  goto _L;
                } else {
                  if ((int)DisketteExtension->FifoBuffer[1] != 0) {
                    goto _L;
                  } else {
                    if ((int)DisketteExtension->FifoBuffer[2] != 0) {
                      goto _L;
                    } else {
                      if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                              ->AlternativeArchitecture == 1) {
                        if ((int)DisketteExtension->FifoBuffer[6] !=
                            (int)sectorLengthCode) {
                        _L : /* CIL Label */
                        {}
                          DisketteExtension->DriveMediaType =
                              (DRIVE_MEDIA_TYPE)(
                                  (int)DisketteExtension->DriveMediaType - 1);
                          DisketteExtension->DriveMediaConstants =
                              *(DriveMediaConstants +
                                DisketteExtension->DriveMediaType);
                          if (ntStatus != -1073741661L) {
                            ntStatus = -1073741804L;
                          } else {
                          }
                          if ((int)((char)DisketteExtension->DriveMediaType) <
                              (int)((char)(DriveMediaLimits +
                                           DisketteExtension->DriveType)
                                        ->LowestDriveMediaType)) {
                            DisketteExtension->MediaType = 0;
                            mediaTypesExhausted = 1;
                            {}
                          } else {
                          }
                        } else {
                          goto _L___0;
                        }
                      } else {
                      _L___0: /* CIL Label */
                        if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                                ->AlternativeArchitecture == 1) {
                          DisketteExtension->MediaType =
                              driveMediaConstants->MediaType;
                          DisketteExtension->BytesPerSector =
                              driveMediaConstants->BytesPerSector;
                          {}
                          DisketteExtension->ByteCapacity =
                              (((int)driveMediaConstants->BytesPerSector *
                                (int)driveMediaConstants->SectorsPerTrack) *
                               (1 + (int)driveMediaConstants->MaximumTrack)) *
                              (int)driveMediaConstants->NumberOfHeads;
                          DisketteExtension->DriveMediaConstants =
                              *(DriveMediaConstants +
                                DisketteExtension->DriveMediaType);
                          if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                                  ->AlternativeArchitecture == 1) {
                            tmp = 1024;
                          } else {
                            tmp = 512;
                          }
                          {
                            tmp___0 =
                                ExAllocatePoolWithTag(4, tmp, 1886350406UL);
                            bootSector = tmp___0;
                          }
                          if (!bootSector) {
                            return (-1073741670L);
                          } else {
                          }
                          offset.__annonCompField1.HighPart = 0;
                          offset.__annonCompField1.LowPart =
                              offset.__annonCompField1.HighPart;
                          if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                                  ->AlternativeArchitecture == 1) {
                            tmp___1 = 1024;
                          } else {
                            tmp___1 = 512;
                          }
                          {
                            irp = IoBuildAsynchronousFsdRequest(
                                3, DisketteExtension->DeviceObject, bootSector,
                                tmp___1, &offset, (void *)0);
                          }
                          if (!irp) {
                            {} {
                              /*                       ExFreePool(bootSector); */ /* INLINED */
                            }
                            return (-1073741670L);
                          } else {
                          }
                          {
                            irp->CurrentLocation =
                                (CHAR)((int)irp->CurrentLocation - 1);
                            irp->Tail.Overlay.__annonCompField17
                                .__annonCompField16.CurrentStackLocation -= 1;
                            ntStatus = FlReadWrite(DisketteExtension, irp, 1);
                          }
                          {} {
                            /*                     MmUnlockPages(irp->MdlAddress); */ /* INLINED */
                            /*                     IoFreeMdl(irp->MdlAddress); */ /* INLINED */
                            /*                     IoFreeIrp(irp); */ /* INLINED
                                                                         */
                            /*                     ExFreePool(bootSector); */ /* INLINED */
                          }
                          if (!(ntStatus >= 0L)) {
                            {}
                            DisketteExtension->DriveMediaType =
                                (DRIVE_MEDIA_TYPE)(
                                    (int)DisketteExtension->DriveMediaType - 1);
                            DisketteExtension->DriveMediaConstants =
                                *(DriveMediaConstants +
                                  DisketteExtension->DriveMediaType);
                            if (ntStatus != -1073741661L) {
                              ntStatus = -1073741804L;
                            } else {
                            }
                            if ((int)((char)DisketteExtension->DriveMediaType) <
                                (int)((char)(DriveMediaLimits +
                                             DisketteExtension->DriveType)
                                          ->LowestDriveMediaType)) {
                              DisketteExtension->MediaType = 0;
                              mediaTypesExhausted = 1;
                              {}
                            } else {
                            }
                          } else {
                          }
                        } else {
                        }
                      }
                    }
                  }
                }
              }
            }
            if (!(ntStatus >= 0L)) {
              if (!mediaTypesExhausted) {

              } else {
                goto while_101_break;
              }
            } else {
              goto while_101_break;
            }
          }
        while_101_break: /* CIL Label */;
        }
        if (ntStatus >= 0L) {
          {}
          goto while_99_break;
        } else {
        }
        retries += 1UL;
      }
    while_99_break: /* CIL Label */;
    }
    if (!(ntStatus >= 0L)) {
      goto _L___1;
    } else {
      if (mediaTypesExhausted) {
      _L___1 : /* CIL Label */
      {}
        return (ntStatus);
      } else {
      }
    }
    DisketteExtension->MediaType = driveMediaConstants->MediaType;
    DisketteExtension->BytesPerSector = driveMediaConstants->BytesPerSector;
    DisketteExtension->ByteCapacity =
        (((int)driveMediaConstants->BytesPerSector *
          (int)driveMediaConstants->SectorsPerTrack) *
         (1 + (int)driveMediaConstants->MaximumTrack)) *
        (int)driveMediaConstants->NumberOfHeads;
    {} {
      DisketteExtension->DriveMediaConstants =
          *(DriveMediaConstants + DisketteExtension->DriveMediaType);
      FlCheckBootSector(DisketteExtension);
    }
    return (ntStatus);
  }
}
void FlAllocateIoBuffer(PDISKETTE_EXTENSION DisketteExtension,
                        ULONG BufferSize) {
  BOOLEAN allocateContiguous;
  LARGE_INTEGER maxDmaAddress;
  PVOID tmp;
  PVOID tmp___0;

  {
    if (DisketteExtension->IoBuffer) {
      if (DisketteExtension->IoBufferSize >= BufferSize) {
        return;
      } else {
      }
      { FlFreeIoBuffer(DisketteExtension); }
    } else {
    }
    if (BufferSize > DisketteExtension->MaxTransferSize) {
      allocateContiguous = 1;
    } else {
      allocateContiguous = 0;
    }
    if (allocateContiguous) {
      {
        maxDmaAddress.QuadPart = 16777215;
        tmp = MmAllocateContiguousMemory(BufferSize, maxDmaAddress);
        DisketteExtension->IoBuffer = tmp;
      }
    } else {
      {
        tmp___0 = ExAllocatePoolWithTag(4, BufferSize, 1886350406UL);
        DisketteExtension->IoBuffer = tmp___0;
      }
    }
    if (!DisketteExtension->IoBuffer) {
      return;
    } else {
    }
    {
      DisketteExtension->IoBufferMdl = IoAllocateMdl(
          DisketteExtension->IoBuffer, BufferSize, 0, 0, (void *)0);
    }
    if (!DisketteExtension->IoBufferMdl) {
      if (allocateContiguous) {
        {
          /*       MmFreeContiguousMemory(DisketteExtension->IoBuffer); */ /* INLINED
                                                                              */
        }
      } else {
        { /*       ExFreePool(DisketteExtension->IoBuffer); */ /* INLINED */
        }
      }
      DisketteExtension->IoBuffer = (void *)0;
      return;
    } else {
    }
    { MmProbeAndLockPages(DisketteExtension->IoBufferMdl, 0, 2); }
    {}
    if (allocateContiguous) {
      {
        /*     MmFreeContiguousMemory(DisketteExtension->IoBuffer); */ /* INLINED
                                                                          */
      }
    } else {
      { /*     ExFreePool(DisketteExtension->IoBuffer); */ /* INLINED */
      }
    }
    DisketteExtension->IoBuffer = (void *)0;
    return;
    DisketteExtension->IoBufferSize = BufferSize;
  }
}
void FlFreeIoBuffer(PDISKETTE_EXTENSION DisketteExtension) {
  BOOLEAN contiguousBuffer;

  {
    if (!DisketteExtension->IoBuffer) {
      return;
    } else {
    }
    if (DisketteExtension->IoBufferSize > DisketteExtension->MaxTransferSize) {
      contiguousBuffer = 1;
    } else {
      contiguousBuffer = 0;
    }
    {
      DisketteExtension->IoBufferSize = 0;
      /*   MmUnlockPages(DisketteExtension->IoBufferMdl); */ /* INLINED */
      /*   IoFreeMdl(DisketteExtension->IoBufferMdl); */     /* INLINED */
      DisketteExtension->IoBufferMdl = (void *)0;
    }
    if (contiguousBuffer) {
      {
        /*     MmFreeContiguousMemory(DisketteExtension->IoBuffer); */ /* INLINED
                                                                          */
      }
    } else {
      { /*     ExFreePool(DisketteExtension->IoBuffer); */ /* INLINED */
      }
    }
    DisketteExtension->IoBuffer = (void *)0;
    return;
  }
}
void FloppyThread(PVOID Context) {
  PIRP irp;
  PIO_STACK_LOCATION irpSp;
  PLIST_ENTRY request;
  PDISKETTE_EXTENSION disketteExtension;
  NTSTATUS ntStatus;
  NTSTATUS waitStatus;
  LARGE_INTEGER queueWait;
  LARGE_INTEGER acquireWait;
  PKTHREAD tmp;
  PDISK_GEOMETRY outputBuffer;
  PSENSE_DEVISE_STATUS_PTOS outputBuffer___0;

  {
    {
      disketteExtension = Context;
      ntStatus = 0L;
      tmp = KeGetCurrentThread();
      KeSetPriorityThread(tmp, 16);
      queueWait.QuadPart = -30000000;
      acquireWait.QuadPart = -150000000;
    }
    {
      while (1) {
      while_114_continue: /* CIL Label */;
        {
          waitStatus = KeWaitForSingleObject(
              (void *)(&disketteExtension->RequestSemaphore), 0, 0, 0,
              &queueWait);
        }
        if (waitStatus == 258L) {
          if (!((int)((KUSER_SHARED_DATA * const)4292804608U)
                    ->AlternativeArchitecture == 1)) {
            if (disketteExtension->FloppyControllerAllocated) {
              {} {
                FlFdcDeviceIo(disketteExtension->TargetObject,
                              ((7 << 16) | (775 << 2)) | 3, (void *)0);
                FlFdcDeviceIo(disketteExtension->TargetObject,
                              ((7 << 16) | (769 << 2)) | 3,
                              disketteExtension->DeviceObject);
                disketteExtension->FloppyControllerAllocated = 0;
              }
            } else {
            }
          } else {
          }
          {
            /*       ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
          }
          if (disketteExtension->ThreadReferenceCount == 0L) {
            disketteExtension->ThreadReferenceCount = -1;
            if ((unsigned int)disketteExtension->FloppyThread !=
                (unsigned int)((void *)0)) {
              {
                /*           ObfDereferenceObject(disketteExtension->FloppyThread); */ /* INLINED */
                disketteExtension->FloppyThread = (void *)0;
              }
            } else {
            }
            {
              /*         ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
            }
            if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                    ->AlternativeArchitecture == 1) {
              if (disketteExtension->ReleaseFdcWithMotorRunning) {
                {
                  ntStatus =
                      FlFdcDeviceIo(disketteExtension->TargetObject,
                                    ((7 << 16) | (768 << 2)) | 3, &acquireWait);
                  FlFdcDeviceIo(disketteExtension->TargetObject,
                                ((7 << 16) | (775 << 2)) | 3, (void *)0);
                  FlFdcDeviceIo(disketteExtension->TargetObject,
                                ((7 << 16) | (769 << 2)) | 3,
                                disketteExtension->DeviceObject);
                  disketteExtension->FloppyControllerAllocated = 0;
                  disketteExtension->ReleaseFdcWithMotorRunning = 0;
                }
              } else {
              }
            } else {
            }
            {
              /*         ExAcquireFastMutex(PagingMutex); */ /* INLINED */
              PagingReferenceCount -= 1UL;
            }
            if (PagingReferenceCount == 0UL) {
              { /* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
              }
            } else {
            }
            {
                /*         ExReleaseFastMutex(PagingMutex); */ /* INLINED */
            } {} {
              PsTerminateSystemThread(0L);
            }
          } else {
          }
          {
            /*       ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
          }
          goto __Cont;
        } else {
        }
        {
          while (1) {
          while_117_continue: /* CIL Label */;
            {
              request = (void *)0;
              /* ExfInterlockedRemoveHeadList(& disketteExtension->ListEntry, & disketteExtension->ListSpinLock); */ /* INLINED */
            }
            if (request) {

            } else {
              goto while_117_break;
            }
            {
              /*       ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
              disketteExtension->ThreadReferenceCount -= 1L;
              /*       ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
              disketteExtension->HardwareFailed = 0;
              irp =
                  (IRP *)((CHAR *)request -
                          (unsigned long)(&((IRP *)0)
                                               ->Tail.Overlay.__annonCompField17
                                               .ListEntry));
              /*       ExAcquireFastMutex(& disketteExtension->PowerDownMutex); */ /* INLINED */
            }
            if ((int)disketteExtension->PoweringDown == 1) {
              {
                  /*         ExReleaseFastMutex(& disketteExtension->PowerDownMutex); */ /* INLINED */
              } {} {
                irp = (IRP *)((CHAR *)request -
                              (unsigned long)(&((IRP *)0)
                                                   ->Tail.Overlay
                                                   .__annonCompField17
                                                   .ListEntry));
                irp->IoStatus.__annonCompField4.Status = -1073741101L;
                irp->IoStatus.Information = 0;
                IofCompleteRequest(irp, 0);
              }
              goto while_117_continue;
            } else {
            }
            {
                /*       ExReleaseFastMutex(& disketteExtension->PowerDownMutex); */ /* INLINED */
            } {}
            irpSp = irp->Tail.Overlay.__annonCompField17.__annonCompField16
                        .CurrentStackLocation;
            {}
            if (irpSp->MajorFunction == 27) {
              goto switch_121_27;
            } else {
              if (irpSp->MajorFunction == 3) {
                goto switch_121_3;
              } else {
                if (irpSp->MajorFunction == 4) {
                  goto switch_121_4;
                } else {
                  if (irpSp->MajorFunction == 14) {
                    goto switch_121_14;
                  } else {
                    {
                      goto switch_121_default;
                      if (0) {
                      switch_121_27: /* CIL Label */;
                        {}
                        if ((int)irpSp->MinorFunction == 1) {
                          goto _L;
                        } else {
                          if ((int)irpSp->MinorFunction == 5) {
                          _L: /* CIL Label */
                            if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                                    ->AlternativeArchitecture == 1) {
                              if (disketteExtension
                                      ->ReleaseFdcWithMotorRunning) {
                                {
                                  FlFdcDeviceIo(disketteExtension->TargetObject,
                                                ((7 << 16) | (768 << 2)) | 3,
                                                &acquireWait);
                                  disketteExtension
                                      ->ReleaseFdcWithMotorRunning = 0;
                                  disketteExtension->FloppyControllerAllocated =
                                      1;
                                }
                              } else {
                              }
                            } else {
                            }
                            if (disketteExtension->FloppyControllerAllocated) {
                              {
                                FlFdcDeviceIo(disketteExtension->TargetObject,
                                              ((7 << 16) | (775 << 2)) | 3,
                                              (void *)0);
                                FlFdcDeviceIo(disketteExtension->TargetObject,
                                              ((7 << 16) | (769 << 2)) | 3,
                                              disketteExtension->DeviceObject);
                                disketteExtension->FloppyControllerAllocated =
                                    0;
                              }
                            } else {
                            }
                            {
                              /*                     ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
                              disketteExtension->ThreadReferenceCount = -1;
                              /*                     ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
                              /*                     ExAcquireFastMutex(PagingMutex); */ /* INLINED */
                              PagingReferenceCount -= 1UL;
                            }
                            if (PagingReferenceCount == 0UL) {
                              {
                                /* MmPageEntireDriver(& DriverEntry); */ /* INLINED
                                                                            */
                              }
                            } else {
                            }
                            {
                              /*                     ExReleaseFastMutex(PagingMutex); */ /* INLINED */
                              PsTerminateSystemThread(0L);
                            }
                          } else {
                            ntStatus = -1073741808L;
                          }
                        }
                        goto switch_121_break;
                      switch_121_3: /* CIL Label */;
                      switch_121_4: /* CIL Label */;
                        if (!disketteExtension->FloppyControllerAllocated) {
                          {
                            ntStatus = FlFdcDeviceIo(
                                disketteExtension->TargetObject,
                                ((7 << 16) | (768 << 2)) | 3, &acquireWait);
                          }
                          if (ntStatus >= 0L) {
                            disketteExtension->FloppyControllerAllocated = 1;
                            if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                                    ->AlternativeArchitecture == 1) {
                              disketteExtension->ReleaseFdcWithMotorRunning = 0;
                            } else {
                            }
                          } else {
                            goto switch_121_break;
                          }
                        } else {
                        }
                        if ((disketteExtension->DeviceObject)->Flags & 2UL) {
                          if (!((int)irpSp->Flags & 2)) {
                            {}
                            ntStatus = -2147483626L;
                          } else {
                            {
                              ntStatus = FlReadWrite(disketteExtension, irp, 0);
                            }
                          }
                        } else {
                          { ntStatus = FlReadWrite(disketteExtension, irp, 0); }
                        }
                        goto switch_121_break;
                      switch_121_14: /* CIL Label */;
                        if (!disketteExtension->FloppyControllerAllocated) {
                          {
                            ntStatus = FlFdcDeviceIo(
                                disketteExtension->TargetObject,
                                ((7 << 16) | (768 << 2)) | 3, &acquireWait);
                          }
                          if (ntStatus >= 0L) {
                            disketteExtension->FloppyControllerAllocated = 1;
                            if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                                    ->AlternativeArchitecture == 1) {
                              disketteExtension->ReleaseFdcWithMotorRunning = 0;
                            } else {
                            }
                          } else {
                            goto switch_121_break;
                          }
                        } else {
                        }
                        if ((disketteExtension->DeviceObject)->Flags & 2UL) {
                          if (!((int)irpSp->Flags & 2)) {
                            {}
                            ntStatus = -2147483626L;
                          } else {
                            goto _L___2;
                          }
                        } else {
                        _L___2: /* CIL Label */
                          if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                              (((45 << 16) | (1 << 14)) | (512 << 2))) {
                            goto switch_125_exp_12;
                          } else {
                            if (irpSp->Parameters.DeviceIoControl
                                    .IoControlCode ==
                                (((7 << 16) | (1 << 14)) | (512 << 2))) {
                              goto switch_125_exp_13;
                            } else {
                              if (irpSp->Parameters.DeviceIoControl
                                      .IoControlCode ==
                                  ((7 << 16) | (9 << 2))) {
                                goto switch_125_exp_14;
                              } else {
                                if (irpSp->Parameters.DeviceIoControl
                                        .IoControlCode == 7 << 16) {
                                  goto switch_125_exp_15;
                                } else {
                                  if (irpSp->Parameters.DeviceIoControl
                                          .IoControlCode ==
                                      (((7 << 16) | (3 << 14)) | (11 << 2))) {
                                    goto switch_125_exp_16;
                                  } else {
                                    if (irpSp->Parameters.DeviceIoControl
                                            .IoControlCode ==
                                        (((7 << 16) | (3 << 14)) | (6 << 2))) {
                                      goto switch_125_exp_17;
                                    } else {
                                      if (irpSp->Parameters.DeviceIoControl
                                              .IoControlCode ==
                                          ((7 << 16) | (248 << 2))) {
                                        goto switch_125_exp_18;
                                      } else {
                                        if (0) {
                                        switch_125_exp_12: /* CIL Label */;
                                        switch_125_exp_13: /* CIL Label */;
                                          {} {
                                            ntStatus = FlStartDrive(
                                                disketteExtension, irp, 0, 0,
                                                (unsigned char)(!(
                                                    !((int)irpSp->Flags & 2))));
                                          }
                                          goto switch_125_break;
                                        switch_125_exp_14: /* CIL Label */;
                                          {}
                                          if (disketteExtension->IsReadOnly) {
                                            ntStatus = -1073741811L;
                                          } else {
                                            {
                                              ntStatus = FlStartDrive(
                                                  disketteExtension, irp, 1, 0,
                                                  1);
                                            }
                                          }
                                          goto switch_125_break;
                                        switch_125_exp_15: /* CIL Label */;
                                          {}
                                          if (irpSp->Parameters.DeviceIoControl
                                                  .OutputBufferLength <
                                              (ULONG)sizeof(DISK_GEOMETRY)) {
                                            ntStatus = -1073741811L;
                                          } else {
                                            {
                                              ntStatus = FlStartDrive(
                                                  disketteExtension, irp, 0, 1,
                                                  (unsigned char)(!(!(
                                                      (int)irpSp->Flags & 2))));
                                            }
                                          }
                                          if (ntStatus >= 0L) {
                                            goto _L___0;
                                          } else {
                                            if (ntStatus == -1073741804L) {
                                            _L___0: /* CIL Label */
                                              outputBuffer =
                                                  (struct _DISK_GEOMETRY *)
                                                      irp->AssociatedIrp
                                                          .SystemBuffer;
                                              ntStatus = 0L;
                                              outputBuffer->MediaType =
                                                  disketteExtension->MediaType;
                                              if ((int)disketteExtension
                                                      ->MediaType == 0) {
                                                {}
                                                outputBuffer->Cylinders
                                                    .__annonCompField1.LowPart =
                                                    0;
                                                outputBuffer->Cylinders
                                                    .__annonCompField1
                                                    .HighPart = 0;
                                                outputBuffer
                                                    ->TracksPerCylinder = 0;
                                                outputBuffer->SectorsPerTrack =
                                                    0;
                                                outputBuffer->BytesPerSector =
                                                    0;
                                              } else {
                                                {}
                                                outputBuffer->Cylinders
                                                    .__annonCompField1.LowPart =
                                                    (int)disketteExtension
                                                        ->DriveMediaConstants
                                                        .MaximumTrack +
                                                    1;
                                                outputBuffer->Cylinders
                                                    .__annonCompField1
                                                    .HighPart = 0;
                                                outputBuffer
                                                    ->TracksPerCylinder =
                                                    disketteExtension
                                                        ->DriveMediaConstants
                                                        .NumberOfHeads;
                                                outputBuffer->SectorsPerTrack =
                                                    disketteExtension
                                                        ->DriveMediaConstants
                                                        .SectorsPerTrack;
                                                outputBuffer->BytesPerSector =
                                                    disketteExtension
                                                        ->DriveMediaConstants
                                                        .BytesPerSector;
                                              }
                                              {}
                                            } else {
                                            }
                                          }
                                          irp->IoStatus.Information =
                                              sizeof(DISK_GEOMETRY);
                                          goto switch_125_break;
                                        switch_125_exp_16: /* CIL Label */;
                                        switch_125_exp_17: /* CIL Label */;
                                          {} {
                                            ntStatus =
                                                FlStartDrive(disketteExtension,
                                                             irp, 1, 0, 0);
                                          }
                                          if (ntStatus >= 0L) {
                                            goto _L___1;
                                          } else {
                                            if (ntStatus == -1073741804L) {
                                            _L___1 : /* CIL Label */
                                            {
                                              FlAllocateIoBuffer(
                                                  disketteExtension, 4096);
                                            }
                                              if (disketteExtension->IoBuffer) {
                                                {
                                                  ntStatus = FlFormat(
                                                      disketteExtension, irp);
                                                }
                                              } else {
                                                ntStatus = -1073741670L;
                                              }
                                            } else {
                                            }
                                          }
                                          goto switch_125_break;
                                        switch_125_exp_18: /* CIL Label */;
                                          if ((int)((KUSER_SHARED_DATA *
                                                     const)4292804608U)
                                                  ->AlternativeArchitecture ==
                                              1) {
                                            {
                                              disketteExtension->FifoBuffer[0] =
                                                  14;
                                              disketteExtension->FifoBuffer[1] =
                                                  disketteExtension->DeviceUnit;
                                              ntStatus = FlIssueCommand(
                                                  disketteExtension,
                                                  disketteExtension->FifoBuffer,
                                                  disketteExtension->FifoBuffer,
                                                  (void *)0, 0, 0);
                                            }
                                            if (ntStatus >= 0L) {
                                              outputBuffer___0 =
                                                  (struct
                                                   _SENSE_DEVISE_STATUS_PTOS *)
                                                      irp->AssociatedIrp
                                                          .SystemBuffer;
                                              outputBuffer___0->ST3_PTOS =
                                                  Result_Status3_PTOS[0]
                                                      .ST3_PTOS;
                                              irp->IoStatus.Information =
                                                  sizeof(
                                                      SENSE_DEVISE_STATUS_PTOS);
                                            } else {
                                            }
                                            goto switch_125_break;
                                          } else {
                                          }
                                        } else {
                                        switch_125_break: /* CIL Label */;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        goto switch_121_break;
                      switch_121_default: /* CIL Label */;
                        {}
                        ntStatus = -1073741822L;
                      } else {
                      switch_121_break: /* CIL Label */;
                      }
                    }
                  }
                }
              }
            }
            if (ntStatus == -2147483631L) {
              {
                while (1) {
                while_134_continue: /* CIL Label */;
                  {
                    disketteExtension->HardwareFailed = 0;
                    irp->IoStatus.__annonCompField4.Status = -2147483631L;
                    IofCompleteRequest(irp, 1);
                    request = (void *)0;
                    /* ExfInterlockedRemoveHeadList(& disketteExtension->ListEntry, & disketteExtension->ListSpinLock); */ /* INLINED */
                  }
                  if (!request) {
                    goto while_134_break;
                  } else {
                  }
                  {
                    /*           ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
                    disketteExtension->ThreadReferenceCount -= 1L;
                    /*           ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
                    irp = (IRP *)((CHAR *)request -
                                  (unsigned long)(&((IRP *)0)
                                                       ->Tail.Overlay
                                                       .__annonCompField17
                                                       .ListEntry));
                  }
                }
              while_134_break: /* CIL Label */;
              }
            } else {
              irp->IoStatus.__annonCompField4.Status = ntStatus;
              if (disketteExtension->IoBuffer) {
                { FlFreeIoBuffer(disketteExtension); }
              } else {
              }
              { FlFinishOperation(irp, disketteExtension); }
            }
          }
        while_117_break: /* CIL Label */;
        }
        if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                ->AlternativeArchitecture == 1) {
          if (disketteExtension->FloppyControllerAllocated) {
            {
              FlFdcDeviceIo(disketteExtension->TargetObject,
                            ((7 << 16) | (769 << 2)) | 3,
                            disketteExtension->DeviceObject);
              disketteExtension->FloppyControllerAllocated = 0;
              disketteExtension->ReleaseFdcWithMotorRunning = 1;
            }
          } else {
          }
        } else {
        }
      __Cont: /* CIL Label */;
      }
    while_114_break: /* CIL Label */;
    }
  }
}
void FlConsolidateMediaTypeWithBootSector(PDISKETTE_EXTENSION DisketteExtension,
                                          PBOOT_SECTOR_INFO BootSector) {
  USHORT bpbNumberOfSectors;
  USHORT bpbNumberOfHeads;
  USHORT bpbSectorsPerTrack;
  USHORT bpbBytesPerSector;
  USHORT bpbMediaByte;
  USHORT bpbMaximumTrack;
  MEDIA_TYPE bpbMediaType;
  ULONG i;
  ULONG n;
  PDRIVE_MEDIA_CONSTANTS readidDriveMediaConstants;
  BOOLEAN changeToBpbMedia;
  int tmp;
  SIZE_T tmp___0;

  {
    {}
    if ((int)BootSector->JumpByte[0] != 235) {
      if ((int)BootSector->JumpByte[0] != 233) {
        return;
      } else {
      }
    } else {
    }
    bpbNumberOfSectors = (int)BootSector->NumberOfSectors[1] * 256 +
                         (int)BootSector->NumberOfSectors[0];
    bpbNumberOfHeads = (int)BootSector->NumberOfHeads[1] * 256 +
                       (int)BootSector->NumberOfHeads[0];
    bpbSectorsPerTrack = (int)BootSector->SectorsPerTrack[1] * 256 +
                         (int)BootSector->SectorsPerTrack[0];
    bpbBytesPerSector = (int)BootSector->BytesPerSector[1] * 256 +
                        (int)BootSector->BytesPerSector[0];
    bpbMediaByte = BootSector->MediaByte[0];
    if (!bpbNumberOfHeads) {
      return;
    } else {
      if (!bpbSectorsPerTrack) {
        return;
      } else {
      }
    }
    bpbMaximumTrack = ((int)bpbNumberOfSectors / (int)bpbNumberOfHeads) /
                          (int)bpbSectorsPerTrack -
                      1;
    bpbMediaType = 0;
    i = 0;
    {
      while (1) {
      while_136_continue: /* CIL Label */;
        if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                ->AlternativeArchitecture == 1) {
          tmp = 21;
        } else {
          tmp = 17;
        }
        if (i < (unsigned long)tmp) {

        } else {
          goto while_136_break;
        }
        if ((int)bpbBytesPerSector ==
            (int)(DriveMediaConstants + i)->BytesPerSector) {
          if ((int)bpbSectorsPerTrack ==
              (int)(DriveMediaConstants + i)->SectorsPerTrack) {
            if ((int)bpbMaximumTrack ==
                (int)(DriveMediaConstants + i)->MaximumTrack) {
              if ((int)bpbNumberOfHeads ==
                  (int)(DriveMediaConstants + i)->NumberOfHeads) {
                if ((int)bpbMediaByte ==
                    (int)(DriveMediaConstants + i)->MediaByte) {
                  bpbMediaType = (DriveMediaConstants + i)->MediaType;
                  goto while_136_break;
                } else {
                }
              } else {
              }
            } else {
            }
          } else {
          }
        } else {
        }
        i += 1UL;
      }
    while_136_break: /* CIL Label */;
    }
    if ((int)DisketteExtension->DriveType == 3) {
      if (bpbMediaType == 15) {
        goto switch_137_15;
      } else {
        if (bpbMediaType == 16) {
          goto switch_137_16;
        } else {
          if (bpbMediaType == 1) {
            goto switch_137_1;
          } else {
            if (bpbMediaType == 19) {
              goto switch_137_19;
            } else {
              {
                goto switch_137_default;
                if (0) {
                switch_137_15: /* CIL Label */
                  bpbMediaType = 14;
                  goto switch_137_break;
                switch_137_16: /* CIL Label */
                  bpbMediaType = 5;
                  goto switch_137_break;
                switch_137_1: /* CIL Label */
                  bpbMediaType = 17;
                  goto switch_137_break;
                switch_137_19: /* CIL Label */
                  bpbMediaType = 18;
                  goto switch_137_break;
                switch_137_default: /* CIL Label */;
                  goto switch_137_break;
                } else {
                switch_137_break: /* CIL Label */;
                }
              }
            }
          }
        }
      }
    } else {
    }
    {} {}
    if ((int)bpbMediaType == (int)DisketteExtension->MediaType) {
      changeToBpbMedia = 0;
      {}
    } else {
      readidDriveMediaConstants = &DisketteExtension->DriveMediaConstants;
      if ((int)bpbBytesPerSector ==
          (int)readidDriveMediaConstants->BytesPerSector) {
        if ((int)bpbSectorsPerTrack < 256) {
          if ((int)bpbMaximumTrack ==
              (int)readidDriveMediaConstants->MaximumTrack) {
            if ((int)bpbNumberOfHeads <=
                (int)readidDriveMediaConstants->NumberOfHeads) {
              changeToBpbMedia = 1;
            } else {
              changeToBpbMedia = 0;
            }
          } else {
            changeToBpbMedia = 0;
          }
        } else {
          changeToBpbMedia = 0;
        }
      } else {
        changeToBpbMedia = 0;
      }
      {}
      if ((int)bpbMediaType == 0) {
        bpbMediaType = readidDriveMediaConstants->MediaType;
        DisketteExtension->DriveMediaConstants.SkewDelta = 0;
      } else {
      }
    }
    if (changeToBpbMedia) {
      i = (DriveMediaLimits + DisketteExtension->DriveType)
              ->LowestDriveMediaType;
      n = (DriveMediaLimits + DisketteExtension->DriveType)
              ->HighestDriveMediaType;
      {
        while (1) {
        while_142_continue: /* CIL Label */;
          if (i <= n) {

          } else {
            goto while_142_break;
          }
          if ((int)bpbMediaType == (int)(DriveMediaConstants + i)->MediaType) {
            DisketteExtension->DriveMediaType = i;
            goto while_142_break;
          } else {
          }
          i += 1UL;
        }
      while_142_break: /* CIL Label */;
      }
      {
        DisketteExtension->MediaType = bpbMediaType;
        DisketteExtension->ByteCapacity =
            (int)bpbNumberOfSectors * (int)bpbBytesPerSector;
        DisketteExtension->DriveMediaConstants.SectorsPerTrack =
            (unsigned char)bpbSectorsPerTrack;
        DisketteExtension->DriveMediaConstants.NumberOfHeads =
            (unsigned char)bpbNumberOfHeads;
        tmp___0 = RtlCompareMemory(BootSector->OemData, "MSDMF3.", 7);
      }
      if (tmp___0 == 7UL) {
        DisketteExtension->IsReadOnly = 1;
      } else {
      }
    } else {
    }
    return;
  }
}
void FlCheckBootSector(PDISKETTE_EXTENSION DisketteExtension) {
  PBOOT_SECTOR_INFO bootSector;
  LARGE_INTEGER offset;
  PIRP irp;
  NTSTATUS status;
  int tmp;
  PVOID tmp___0;
  int tmp___1;

  {
    if ((int)((KUSER_SHARED_DATA * const)4292804608U)
            ->AlternativeArchitecture == 1) {
      tmp = 1024;
    } else {
      tmp = 512;
    }
    {
      tmp___0 = ExAllocatePoolWithTag(4, tmp, 1886350406UL);
      bootSector = tmp___0;
    }
    if (!bootSector) {
      return;
    } else {
    }
    offset.__annonCompField1.HighPart = 0;
    offset.__annonCompField1.LowPart = offset.__annonCompField1.HighPart;
    if ((int)((KUSER_SHARED_DATA * const)4292804608U)
            ->AlternativeArchitecture == 1) {
      tmp___1 = 1024;
    } else {
      tmp___1 = 512;
    }
    {
      irp = IoBuildAsynchronousFsdRequest(3, DisketteExtension->DeviceObject,
                                          bootSector, tmp___1, &offset,
                                          (void *)0);
    }
    if (!irp) {
      { /*     ExFreePool(bootSector); */ /* INLINED */
      }
      return;
    } else {
    }
    {
      irp->CurrentLocation = (CHAR)((int)irp->CurrentLocation - 1);
      irp->Tail.Overlay.__annonCompField17.__annonCompField16
          .CurrentStackLocation -= 1;
      status = FlReadWrite(DisketteExtension, irp, 1);
      /*   MmUnlockPages(irp->MdlAddress); */ /* INLINED */
      /*   IoFreeMdl(irp->MdlAddress); */     /* INLINED */
      /*   IoFreeIrp(irp); */                 /* INLINED */
      /*   ExFreePool(bootSector); */         /* INLINED */
    }
    return;
  }
}
NTSTATUS FlReadWriteTrack(PDISKETTE_EXTENSION DisketteExtension, PMDL IoMdl,
                          ULONG IoOffset, BOOLEAN WriteOperation,
                          UCHAR Cylinder, UCHAR Head, UCHAR Sector,
                          UCHAR NumberOfSectors, BOOLEAN NeedSeek) {
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants;
  ULONG byteToSectorShift;
  ULONG transferBytes;
  LARGE_INTEGER headSettleTime;
  NTSTATUS status;
  ULONG seekRetry;
  ULONG ioRetry;
  BOOLEAN recalibrateDrive;
  UCHAR i;

  {
    recalibrateDrive = 0;
    {}
    driveMediaConstants = &DisketteExtension->DriveMediaConstants;
    byteToSectorShift = 7 + (int)driveMediaConstants->SectorLengthCode;
    transferBytes = (unsigned long)NumberOfSectors << byteToSectorShift;
    headSettleTime.__annonCompField1.LowPart =
        -(10000 * (int)driveMediaConstants->HeadSettleTime);
    headSettleTime.__annonCompField1.HighPart = -1;
    seekRetry = 0;
    ioRetry = 0;
    {
      while (1) {
      while_144_continue: /* CIL Label */;
        if (seekRetry < 3UL) {

        } else {
          goto while_144_break;
        }
        if (recalibrateDrive) {
          {} { FlRecalibrateDrive(DisketteExtension); }
        } else {
        }
        if (recalibrateDrive) {
          goto _L___0;
        } else {
          if (NeedSeek) {
            if (!DisketteExtension->ControllerConfigurable) {
              goto _L___0;
            } else {
              if ((int)driveMediaConstants->CylinderShift != 0) {
              _L___0 : /* CIL Label */
              {
                DisketteExtension->FifoBuffer[0] = 16;
                DisketteExtension->FifoBuffer[1] =
                    ((int)Head << 2) | (int)DisketteExtension->DeviceUnit;
                DisketteExtension->FifoBuffer[2] =
                    (int)Cylinder << (int)driveMediaConstants->CylinderShift;
                status = FlIssueCommand(
                    DisketteExtension, DisketteExtension->FifoBuffer,
                    DisketteExtension->FifoBuffer, (void *)0, 0, 0);
              }
                if (status >= 0L) {
                  if (!((int)DisketteExtension->FifoBuffer[0] & 32)) {
                    DisketteExtension->HardwareFailed = 1;
                    status = -1073741464L;
                  } else {
                    if ((int)DisketteExtension->FifoBuffer[1] !=
                        (int)Cylinder
                            << (int)driveMediaConstants->CylinderShift) {
                      DisketteExtension->HardwareFailed = 1;
                      status = -1073741464L;
                    } else {
                    }
                  }
                  if (status >= 0L) {
                    {
                      KeDelayExecutionThread(0, 0, &headSettleTime);
                      DisketteExtension->FifoBuffer[0] = 84;
                      DisketteExtension->FifoBuffer[1] =
                          ((int)Head << 2) | (int)DisketteExtension->DeviceUnit;
                      status = FlIssueCommand(
                          DisketteExtension, DisketteExtension->FifoBuffer,
                          DisketteExtension->FifoBuffer, (void *)0, 0, 0);
                    }
                    if (status >= 0L) {
                      if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                              ->AlternativeArchitecture == 1) {
                        if ((int)DisketteExtension->FifoBuffer[0] & 8) {
                          return (-1073741661L);
                        } else {
                        }
                      } else {
                      }
                      if ((int)DisketteExtension->FifoBuffer[0] !=
                          (((int)Head << 2) |
                           (int)DisketteExtension->DeviceUnit)) {
                        {
                          DisketteExtension->HardwareFailed = 1;
                          status = FlInterpretError(
                              DisketteExtension->FifoBuffer[1],
                              DisketteExtension->FifoBuffer[2]);
                        }
                      } else {
                        if ((int)DisketteExtension->FifoBuffer[1] != 0) {
                          {
                            DisketteExtension->HardwareFailed = 1;
                            status = FlInterpretError(
                                DisketteExtension->FifoBuffer[1],
                                DisketteExtension->FifoBuffer[2]);
                          }
                        } else {
                          if ((int)DisketteExtension->FifoBuffer[2] != 0) {
                            {
                              DisketteExtension->HardwareFailed = 1;
                              status = FlInterpretError(
                                  DisketteExtension->FifoBuffer[1],
                                  DisketteExtension->FifoBuffer[2]);
                            }
                          } else {
                            if ((int)DisketteExtension->FifoBuffer[3] !=
                                (int)Cylinder) {
                              {
                                DisketteExtension->HardwareFailed = 1;
                                status = FlInterpretError(
                                    DisketteExtension->FifoBuffer[1],
                                    DisketteExtension->FifoBuffer[2]);
                              }
                            } else {
                            }
                          }
                        }
                      }
                    } else {
                      {}
                    }
                  } else {
                  }
                } else {
                  {}
                }
              } else {
                status = 0L;
              }
            }
          } else {
            status = 0L;
          }
        }
        if (!(status >= 0L)) {
          {}
          recalibrateDrive = 1;
          goto __Cont;
        } else {
        }
        {
          while (1) {
          while_149_continue: /* CIL Label */;
            DisketteExtension->FifoBuffer[1] =
                ((int)Head << 2) | (int)DisketteExtension->DeviceUnit;
            DisketteExtension->FifoBuffer[2] = Cylinder;
            DisketteExtension->FifoBuffer[3] = Head;
            DisketteExtension->FifoBuffer[4] = (int)Sector + 1;
            DisketteExtension->FifoBuffer[5] =
                driveMediaConstants->SectorLengthCode;
            DisketteExtension->FifoBuffer[6] =
                (int)Sector + (int)NumberOfSectors;
            DisketteExtension->FifoBuffer[7] =
                driveMediaConstants->ReadWriteGapLength;
            DisketteExtension->FifoBuffer[8] = driveMediaConstants->DataLength;
            if (WriteOperation) {
              DisketteExtension->FifoBuffer[0] = 66;
            } else {
              DisketteExtension->FifoBuffer[0] = 64;
            }
            {
              status = FlIssueCommand(DisketteExtension,
                                      DisketteExtension->FifoBuffer,
                                      DisketteExtension->FifoBuffer, IoMdl,
                                      IoOffset, transferBytes);
            }
            if (status >= 0L) {
              if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                      ->AlternativeArchitecture == 1) {
                if ((int)DisketteExtension->FifoBuffer[0] & 8) {
                  return (-1073741661L);
                } else {
                }
              } else {
              }
              if (((int)DisketteExtension->FifoBuffer[0] & 192) != 0) {
                if (((int)DisketteExtension->FifoBuffer[0] & 192) != 64) {
                  {
                    DisketteExtension->HardwareFailed = 1;
                    status = FlInterpretError(DisketteExtension->FifoBuffer[1],
                                              DisketteExtension->FifoBuffer[2]);
                  }
                } else {
                  if ((int)DisketteExtension->FifoBuffer[1] != 128) {
                    {
                      DisketteExtension->HardwareFailed = 1;
                      status =
                          FlInterpretError(DisketteExtension->FifoBuffer[1],
                                           DisketteExtension->FifoBuffer[2]);
                    }
                  } else {
                    if ((int)DisketteExtension->FifoBuffer[2] != 0) {
                      {
                        DisketteExtension->HardwareFailed = 1;
                        status =
                            FlInterpretError(DisketteExtension->FifoBuffer[1],
                                             DisketteExtension->FifoBuffer[2]);
                      }
                    } else {
                      goto _L___1;
                    }
                  }
                }
              } else {
              _L___1: /* CIL Label */
                if ((int)DisketteExtension->FifoBuffer[5] != 1) {
                  DisketteExtension->HardwareFailed = 1;
                  status = -1073741465L;
                } else {
                }
              }
            } else {
              {}
            }
            if (status >= 0L) {
              goto while_149_break;
            } else {
            }
            if (ioRetry >= 2UL) {
              {}
              goto while_149_break;
            } else {
            }
            ioRetry += 1UL;
          }
        while_149_break: /* CIL Label */;
        }
        if (status >= 0L) {
          goto while_144_break;
        } else {
        }
        recalibrateDrive = 1;
      __Cont: /* CIL Label */
        seekRetry += 1UL;
      }
    while_144_break: /* CIL Label */;
    }
    if (!(status >= 0L)) {
      if ((int)NumberOfSectors > 1) {
        {}
        i = 0;
        {
          while (1) {
          while_153_continue: /* CIL Label */;
            if ((int)i < (int)NumberOfSectors) {

            } else {
              goto while_153_break;
            }
            {
              status = FlReadWriteTrack(
                  DisketteExtension, IoMdl,
                  IoOffset + ((unsigned long)i << byteToSectorShift),
                  WriteOperation, Cylinder, Head,
                  (unsigned char)((int)Sector + (int)i), 1, 0);
            }
            if (!(status >= 0L)) {
              {}
              DisketteExtension->HardwareFailed = 1;
              goto while_153_break;
            } else {
            }
            i = (UCHAR)((int)i + 1);
          }
        while_153_break: /* CIL Label */;
        }
      } else {
      }
    } else {
    }
    return (status);
  }
}
NTSTATUS FlReadWrite(PDISKETTE_EXTENSION DisketteExtension, PIRP Irp,
                     BOOLEAN DriveStarted) {
  PIO_STACK_LOCATION irpSp;
  BOOLEAN writeOperation;
  NTSTATUS status;
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants;
  ULONG byteToSectorShift;
  ULONG currentSector;
  ULONG firstSector;
  ULONG lastSector;
  ULONG trackSize;
  UCHAR sectorsPerTrack;
  UCHAR numberOfHeads;
  UCHAR currentHead;
  UCHAR currentCylinder;
  UCHAR trackSector;
  PCHAR userBuffer;
  UCHAR skew;
  UCHAR skewDelta;
  UCHAR numTransferSectors;
  PMDL mdl;
  PCHAR ioBuffer;
  ULONG ioOffset;
  PVOID tmp___0;

  {
    irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                .CurrentStackLocation;
    {}
    if ((int)irpSp->MajorFunction == 4) {
      if (DisketteExtension->IsReadOnly) {
        {}
        return (-1073741811L);
      } else {
      }
      writeOperation = 1;
    } else {
      writeOperation = 0;
    }
    {}
    if (DriveStarted) {
      status = 0L;
    } else {
      {
        status = FlStartDrive(DisketteExtension, Irp, writeOperation, 1,
                              (unsigned char)(!(!((int)irpSp->Flags & 2))));
      }
    }
    if (!(status >= 0L)) {
      {}
      return (status);
    } else {
    }
    if ((int)((KUSER_SHARED_DATA * const)4292804608U)
            ->AlternativeArchitecture == 1) {
      { FlHdbit(DisketteExtension); }
    } else {
    }
    if ((int)DisketteExtension->MediaType == 0) {
      {}
      return (-1073741804L);
    } else {
    }
    driveMediaConstants = &DisketteExtension->DriveMediaConstants;
    byteToSectorShift = 7 + (int)driveMediaConstants->SectorLengthCode;
    firstSector = irpSp->Parameters.Read.ByteOffset.__annonCompField1.LowPart >>
                  byteToSectorShift;
    lastSector =
        firstSector + (irpSp->Parameters.Read.Length >> byteToSectorShift);
    sectorsPerTrack = driveMediaConstants->SectorsPerTrack;
    numberOfHeads = driveMediaConstants->NumberOfHeads;
    if ((int)(Irp->MdlAddress)->MdlFlags & 5) {
      userBuffer = (Irp->MdlAddress)->MappedSystemVa;
    } else {
      {
        tmp___0 = (void *)0;
        /* MmMapLockedPagesSpecifyCache(Irp->MdlAddress, 0, 1, (void *)0, 0, 32); */ /* INLINED */
        userBuffer = tmp___0;
      }
    }
    if ((unsigned int)userBuffer == (unsigned int)((void *)0)) {
      {}
      return (-1073741670L);
    } else {
    }
    trackSize = (unsigned long)sectorsPerTrack << byteToSectorShift;
    skew = 0;
    skewDelta = driveMediaConstants->SkewDelta;
    currentSector = firstSector;
    {
      while (1) {
      while_161_continue: /* CIL Label */;
        if (currentSector < lastSector) {

        } else {
          goto while_161_break;
        }
        currentCylinder =
            (unsigned char)((currentSector / (ULONG)sectorsPerTrack) /
                            (ULONG)numberOfHeads);
        trackSector =
            (unsigned char)(currentSector % (unsigned long)sectorsPerTrack);
        currentHead = (unsigned char)((currentSector / (ULONG)sectorsPerTrack) %
                                      (unsigned long)numberOfHeads);
        numTransferSectors = (int)sectorsPerTrack - (int)trackSector;
        if (lastSector - currentSector < (ULONG)numTransferSectors) {
          numTransferSectors = (unsigned char)(lastSector - currentSector);
        } else {
        }
        if (trackSize > DisketteExtension->MaxTransferSize) {
          {} { FlAllocateIoBuffer(DisketteExtension, trackSize); }
          if (!DisketteExtension->IoBuffer) {
            {}
            return (-1073741670L);
          } else {
          }
          mdl = DisketteExtension->IoBufferMdl;
          ioBuffer = DisketteExtension->IoBuffer;
          ioOffset = 0;
          if (writeOperation) {
            {
              memmove(ioBuffer,
                      userBuffer +
                          ((currentSector - firstSector) << byteToSectorShift),
                      (unsigned long)numTransferSectors << byteToSectorShift);
            }
          } else {
          }
        } else {
          mdl = Irp->MdlAddress;
          ioOffset = (currentSector - firstSector) << byteToSectorShift;
        }
        if ((int)skew >= (int)numTransferSectors + (int)trackSector) {
          skew = 0;
        } else {
        }
        if ((int)skew < (int)trackSector) {
          skew = trackSector;
        } else {
        }
        {
          status = FlReadWriteTrack(
              DisketteExtension, mdl,
              ioOffset + (((unsigned long)skew - (unsigned long)trackSector)
                          << byteToSectorShift),
              writeOperation, currentCylinder, currentHead, skew,
              (unsigned char)(((int)numTransferSectors + (int)trackSector) -
                              (int)skew),
              1);
        }
        if (status >= 0L) {
          if ((int)skew > (int)trackSector) {
            {
              status = FlReadWriteTrack(
                  DisketteExtension, mdl, ioOffset, writeOperation,
                  currentCylinder, currentHead, trackSector,
                  (unsigned char)((int)skew - (int)trackSector), 0);
            }
          } else {
            skew = ((int)numTransferSectors + (int)trackSector) %
                   (int)sectorsPerTrack;
          }
        } else {
          skew = ((int)numTransferSectors + (int)trackSector) %
                 (int)sectorsPerTrack;
        }
        if (!(status >= 0L)) {
          goto while_161_break;
        } else {
        }
        if (!writeOperation) {
          if (trackSize > DisketteExtension->MaxTransferSize) {
            {
              memmove(userBuffer +
                          ((currentSector - firstSector) << byteToSectorShift),
                      ioBuffer,
                      (unsigned long)numTransferSectors << byteToSectorShift);
            }
          } else {
          }
        } else {
        }
        skew = ((int)skew + (int)skewDelta) % (int)sectorsPerTrack;
        currentSector += (ULONG)numTransferSectors;
      }
    while_161_break: /* CIL Label */;
    }
    Irp->IoStatus.Information = (currentSector - firstSector)
                                << byteToSectorShift;
    if (status >= 0L) {
      if (firstSector == 0UL) {
        {
          FlConsolidateMediaTypeWithBootSector(
              DisketteExtension, (struct _BOOT_SECTOR_INFO *)userBuffer);
        }
      } else {
      }
    } else {
    }
    {}
    return (status);
  }
}
NTSTATUS FlFormat(PDISKETTE_EXTENSION DisketteExtension, PIRP Irp) {
  LARGE_INTEGER headSettleTime;
  PIO_STACK_LOCATION irpSp;
  PBAD_TRACK_NUMBER badTrackBuffer;
  PFORMAT_PARAMETERS formatParameters;
  PFORMAT_EX_PARAMETERS formatExParameters;
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants;
  NTSTATUS ntStatus;
  ULONG badTrackBufferLength;
  DRIVE_MEDIA_TYPE driveMediaType;
  UCHAR driveStatus;
  UCHAR numberOfBadTracks;
  UCHAR currentTrack;
  UCHAR endTrack;
  UCHAR whichSector;
  UCHAR retryCount;
  BOOLEAN bufferOverflow;
  FDC_DISK_CHANGE_PARMS fdcDiskChangeParms;
  ULONG length;
  UCHAR tmp;

  {
    numberOfBadTracks = 0;
    bufferOverflow = 0;
    {}
    irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16
                .CurrentStackLocation;
    formatParameters =
        (struct _FORMAT_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;
    if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
        (ULONG)(((7 << 16) | (3 << 14)) | (11 << 2))) {
      formatExParameters =
          (struct _FORMAT_EX_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;
    } else {
      formatExParameters = (void *)0;
    }
    {}
    badTrackBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    driveMediaType = (DriveMediaLimits + DisketteExtension->DriveType)
                         ->HighestDriveMediaType;
    {
      while (1) {
      while_167_continue: /* CIL Label */;
        if ((int)(DriveMediaConstants + driveMediaType)->MediaType !=
            (int)formatParameters->MediaType) {
          if ((int)driveMediaType >
              (int)(DriveMediaLimits + DisketteExtension->DriveType)
                  ->LowestDriveMediaType) {

          } else {
            goto while_167_break;
          }
        } else {
          goto while_167_break;
        }
        driveMediaType = (DRIVE_MEDIA_TYPE)((int)driveMediaType - 1);
      }
    while_167_break: /* CIL Label */;
    }
    driveMediaConstants = DriveMediaConstants + driveMediaType;
    DisketteExtension->MediaType = formatParameters->MediaType;
    DisketteExtension->DriveMediaType = driveMediaType;
    DisketteExtension->DriveMediaConstants =
        *(DriveMediaConstants + driveMediaType);
    if (formatExParameters) {
      DisketteExtension->DriveMediaConstants.SectorsPerTrack =
          (unsigned char)formatExParameters->SectorsPerTrack;
      DisketteExtension->DriveMediaConstants.FormatGapLength =
          (unsigned char)formatExParameters->FormatGapLength;
    } else {
    }
    driveMediaConstants = &DisketteExtension->DriveMediaConstants;
    DisketteExtension->BytesPerSector = driveMediaConstants->BytesPerSector;
    DisketteExtension->ByteCapacity =
        (((int)driveMediaConstants->BytesPerSector *
          (int)driveMediaConstants->SectorsPerTrack) *
         (1 + (int)driveMediaConstants->MaximumTrack)) *
        (int)driveMediaConstants->NumberOfHeads;
    currentTrack =
        (unsigned char)(formatParameters->StartCylinderNumber *
                            (ULONG)driveMediaConstants->NumberOfHeads +
                        formatParameters->StartHeadNumber);
    endTrack = (unsigned char)(formatParameters->EndCylinderNumber *
                                   (ULONG)driveMediaConstants->NumberOfHeads +
                               formatParameters->EndHeadNumber);
    {}
    if ((int)((KUSER_SHARED_DATA * const)4292804608U)
            ->AlternativeArchitecture == 1) {
      { FlHdbit(DisketteExtension); }
    } else {
    }
    if ((int)DisketteExtension->LastDriveMediaType != (int)driveMediaType) {
      { ntStatus = FlDatarateSpecifyConfigure(DisketteExtension); }
      if (!(ntStatus >= 0L)) {
        return (ntStatus);
      } else {
      }
    } else {
    }
    DisketteExtension->IsReadOnly = 0;
    {
      while (1) {
      while_169_continue: /* CIL Label */;
        DisketteExtension->FifoBuffer[0] = 16;
        DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
        DisketteExtension->FifoBuffer[2] =
            (unsigned char)((int)currentTrack /
                                (int)driveMediaConstants->NumberOfHeads
                            << (int)driveMediaConstants->CylinderShift);
        {} {
          ntStatus =
              FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                             DisketteExtension->FifoBuffer, (void *)0, 0, 0);
        }
        if (ntStatus >= 0L) {
          if ((int)DisketteExtension->FifoBuffer[0] & 32) {
            if ((int)DisketteExtension->FifoBuffer[1] ==
                (int)((
                    unsigned char)((int)currentTrack /
                                       (int)driveMediaConstants->NumberOfHeads
                                   << (int)driveMediaConstants
                                          ->CylinderShift))) {
              {
                headSettleTime.__annonCompField1.LowPart =
                    -(10000 * (int)driveMediaConstants->HeadSettleTime);
                headSettleTime.__annonCompField1.HighPart = -1;
                KeDelayExecutionThread(0, 0, &headSettleTime);
              }
              if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                      ->AlternativeArchitecture == 1) {

              } else {
                {
                  DisketteExtension->FifoBuffer[0] = 84;
                  DisketteExtension->FifoBuffer[1] =
                      DisketteExtension->DeviceUnit;
                  ntStatus = FlIssueCommand(
                      DisketteExtension, DisketteExtension->FifoBuffer,
                      DisketteExtension->FifoBuffer, (void *)0, 0, 0);
                }
              }
            } else {
              goto _L;
            }
          } else {
          _L : /* CIL Label */
          {}
            DisketteExtension->HardwareFailed = 1;
            ntStatus = -1073741464L;
          }
        } else {
        }
        if (!(ntStatus >= 0L)) {
          {}
          return (ntStatus);
        } else {
        }
        whichSector = 0;
        {
          while (1) {
          while_173_continue: /* CIL Label */;
            if ((int)whichSector < (int)driveMediaConstants->SectorsPerTrack) {

            } else {
              goto while_173_break;
            }
            *(DisketteExtension->IoBuffer + (int)whichSector * 4) =
                (int)currentTrack / (int)driveMediaConstants->NumberOfHeads;
            *(DisketteExtension->IoBuffer + ((int)whichSector * 4 + 1)) =
                (int)currentTrack % (int)driveMediaConstants->NumberOfHeads;
            if (formatExParameters) {
              *(DisketteExtension->IoBuffer + ((int)whichSector * 4 + 2)) =
                  (unsigned char)formatExParameters->SectorNumber[whichSector];
            } else {
              *(DisketteExtension->IoBuffer + ((int)whichSector * 4 + 2)) =
                  (int)whichSector + 1;
            }
            *(DisketteExtension->IoBuffer + ((int)whichSector * 4 + 3)) =
                driveMediaConstants->SectorLengthCode;
            {}
            whichSector = (UCHAR)((int)whichSector + 1);
          }
        while_173_break: /* CIL Label */;
        }
        retryCount = 0;
        {
          while (1) {
          while_175_continue: /* CIL Label */;
            length = driveMediaConstants->BytesPerSector;
            DisketteExtension->FifoBuffer[0] = 71;
            DisketteExtension->FifoBuffer[1] =
                (unsigned char)(((int)currentTrack %
                                     (int)driveMediaConstants->NumberOfHeads
                                 << 2) |
                                (int)DisketteExtension->DeviceUnit);
            DisketteExtension->FifoBuffer[2] =
                driveMediaConstants->SectorLengthCode;
            DisketteExtension->FifoBuffer[3] =
                driveMediaConstants->SectorsPerTrack;
            DisketteExtension->FifoBuffer[4] =
                driveMediaConstants->FormatGapLength;
            DisketteExtension->FifoBuffer[5] =
                driveMediaConstants->FormatFillCharacter;
            {} {
              ntStatus = FlIssueCommand(
                  DisketteExtension, DisketteExtension->FifoBuffer,
                  DisketteExtension->FifoBuffer, DisketteExtension->IoBufferMdl,
                  0, length);
            }
            if (!(ntStatus >= 0L)) {
              {}
            } else {
            }
            if (ntStatus >= 0L) {
              if ((int)DisketteExtension->FifoBuffer[0] & 208) {
                goto _L___0;
              } else {
                if ((int)DisketteExtension->FifoBuffer[1] & 16) {
                  goto _L___0;
                } else {
                  if ((int)DisketteExtension->FifoBuffer[2] != 0) {
                  _L___0 : /* CIL Label */
                  {}
                    {
                      DisketteExtension->HardwareFailed = 1;
                      ntStatus =
                          FlInterpretError(DisketteExtension->FifoBuffer[1],
                                           DisketteExtension->FifoBuffer[2]);
                    }
                  } else {
                  }
                }
              }
            } else {
            }
            if (!(ntStatus >= 0L)) {
              tmp = retryCount;
              retryCount = (UCHAR)((int)retryCount + 1);
              if (tmp < 3) {

              } else {
                goto while_175_break;
              }
            } else {
              goto while_175_break;
            }
          }
        while_175_break: /* CIL Label */;
        }
        if (!(ntStatus >= 0L)) {
          if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                  ->AlternativeArchitecture == 1) {
            {
              DisketteExtension->FifoBuffer[0] = 14;
              DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
              ntStatus = FlIssueCommand(
                  DisketteExtension, DisketteExtension->FifoBuffer,
                  DisketteExtension->FifoBuffer, (void *)0, 0, 0);
            }
            if (!(ntStatus >= 0L)) {
              {}
              return (ntStatus);
            } else {
            }
            if ((int)DisketteExtension->FifoBuffer[0] & 32) {
              driveStatus = 127;
            } else {
              driveStatus = 128;
            }
          } else {
            {
              ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject,
                                       ((7 << 16) | (776 << 2)) | 3,
                                       &fdcDiskChangeParms);
              driveStatus = fdcDiskChangeParms.DriveStatus;
            }
          }
          if ((int)DisketteExtension->DriveType != 0) {
            if ((int)driveStatus & 128) {
              return (-1073741805L);
            } else {
            }
          } else {
          }
          {}
          if (badTrackBufferLength >=
              (unsigned long)((unsigned int)((int)numberOfBadTracks + 1) *
                              sizeof(BAD_TRACK_NUMBER))) {
            badTrackBuffer = (USHORT *)Irp->AssociatedIrp.SystemBuffer;
            *(badTrackBuffer + numberOfBadTracks) =
                (unsigned short)currentTrack;
          } else {
            bufferOverflow = 1;
          }
          numberOfBadTracks = (UCHAR)((int)numberOfBadTracks + 1);
        } else {
        }
        currentTrack = (UCHAR)((int)currentTrack + 1);
        if ((int)currentTrack <= (int)endTrack) {

        } else {
          goto while_169_break;
        }
      }
    while_169_break: /* CIL Label */;
    }
    if (ntStatus >= 0L) {
      if (bufferOverflow) {
        ntStatus = -2147483643L;
      } else {
      }
    } else {
    }
    return (ntStatus);
  }
}
BOOLEAN FlCheckFormatParameters(PDISKETTE_EXTENSION DisketteExtension,
                                PFORMAT_PARAMETERS FormatParameters) {
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants;
  DRIVE_MEDIA_TYPE driveMediaType;

  {
    driveMediaType = (DriveMediaLimits + DisketteExtension->DriveType)
                         ->HighestDriveMediaType;
    {
      while (1) {
      while_181_continue: /* CIL Label */;
        if ((int)(DriveMediaConstants + driveMediaType)->MediaType !=
            (int)FormatParameters->MediaType) {
          if ((int)driveMediaType >
              (int)(DriveMediaLimits + DisketteExtension->DriveType)
                  ->LowestDriveMediaType) {

          } else {
            goto while_181_break;
          }
        } else {
          goto while_181_break;
        }
        driveMediaType = (DRIVE_MEDIA_TYPE)((int)driveMediaType - 1);
      }
    while_181_break: /* CIL Label */;
    }
    if ((int)(DriveMediaConstants + driveMediaType)->MediaType !=
        (int)FormatParameters->MediaType) {
      return (0);
    } else {
      driveMediaConstants = DriveMediaConstants + driveMediaType;
      if (FormatParameters->StartHeadNumber >
          (unsigned long)((int)driveMediaConstants->NumberOfHeads - 1)) {
        return (0);
      } else {
        if (FormatParameters->EndHeadNumber >
            (unsigned long)((int)driveMediaConstants->NumberOfHeads - 1)) {
          return (0);
        } else {
          if (FormatParameters->StartCylinderNumber >
              (ULONG)driveMediaConstants->MaximumTrack) {
            return (0);
          } else {
            if (FormatParameters->EndCylinderNumber >
                (ULONG)driveMediaConstants->MaximumTrack) {
              return (0);
            } else {
              if (FormatParameters->EndCylinderNumber <
                  FormatParameters->StartCylinderNumber) {
                return (0);
              } else {
                if ((int)((KUSER_SHARED_DATA * const)4292804608U)
                        ->AlternativeArchitecture == 1) {
                  if ((int)FormatParameters->MediaType == 6) {
                    return (0);
                  } else {
                    if ((int)FormatParameters->MediaType == 7) {
                      return (0);
                    } else {
                      if ((int)FormatParameters->MediaType == 8) {
                        return (0);
                      } else {
                        if ((int)FormatParameters->MediaType == 9) {
                          return (0);
                        } else {
                          if ((int)FormatParameters->MediaType == 10) {
                            return (0);
                          } else {
                          }
                        }
                      }
                    }
                  }
                } else {
                }
                return (1);
              }
            }
          }
        }
      }
    }
  }
}
NTSTATUS FlIssueCommand(PDISKETTE_EXTENSION DisketteExtension,
                        PUCHAR FifoInBuffer, PUCHAR FifoOutBuffer, PMDL IoMdl,
                        ULONG IoOffset, ULONG TransferBytes) {
  NTSTATUS ntStatus;
  ISSUE_FDC_COMMAND_PARMS issueCommandParms;

  {
    issueCommandParms.FifoInBuffer = FifoInBuffer;
    issueCommandParms.FifoOutBuffer = FifoOutBuffer;
    issueCommandParms.IoHandle = (void *)IoMdl;
    issueCommandParms.IoOffset = IoOffset;
    issueCommandParms.TransferBytes = TransferBytes;
    issueCommandParms.TimeOut = 4;
    {} {
      ntStatus =
          FlFdcDeviceIo(DisketteExtension->TargetObject,
                        ((7 << 16) | (771 << 2)) | 3, &issueCommandParms);
    }
    if (ntStatus == -1073741661L) {
      DisketteExtension->HardwareFailed = 1;
    } else {
      if (ntStatus == -1073741464L) {
        DisketteExtension->HardwareFailed = 1;
      } else {
      }
    }
    return (ntStatus);
  }
}
NTSTATUS FlInitializeControllerHardware(PDISKETTE_EXTENSION DisketteExtension) {
  NTSTATUS ntStatus;

  {
    {
      ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject,
                               ((7 << 16) | (773 << 2)) | 3, (void *)0);
    }
    if (ntStatus >= 0L) {
      if ((int)DisketteExtension->PerpendicularMode != 0) {
        {
          DisketteExtension->FifoBuffer[0] = 21;
          DisketteExtension->FifoBuffer[1] =
              (unsigned char)(128 |
                              ((int)DisketteExtension->PerpendicularMode << 2));
          ntStatus =
              FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                             DisketteExtension->FifoBuffer, (void *)0, 0, 0);
        }
      } else {
      }
    } else {
    }
    return (ntStatus);
  }
}
NTSTATUS FlFdcDeviceIo(PDEVICE_OBJECT DeviceObject, ULONG Ioctl, PVOID Data) {
  NTSTATUS ntStatus;
  PIRP irp;
  PIO_STACK_LOCATION irpStack;
  KEVENT doneEvent;
  IO_STATUS_BLOCK ioStatus;

  {
    {} {
      /*   KeInitializeEvent(& doneEvent, 0, 0); */ /* INLINED */
      irp =
          IoBuildDeviceIoControlRequest(Ioctl, DeviceObject, (void *)0, 0,
                                        (void *)0, 0, 1, &doneEvent, &ioStatus);
    }
    if ((unsigned int)irp == (unsigned int)((void *)0)) {
      {}
      return (-1073741670L);
    } else {
    }
    {
      irpStack = irp->Tail.Overlay.__annonCompField17.__annonCompField16
                     .CurrentStackLocation -
                 1;
      irpStack->Parameters.DeviceIoControl.Type3InputBuffer = Data;
      ntStatus = IofCallDriver(DeviceObject, irp);
    }
    if (ntStatus == 259L) {
      {
        KeWaitForSingleObject(&doneEvent, 5, 0, 0, (void *)0);
        ntStatus = ioStatus.__annonCompField4.Status;
      }
    } else {
    }
    return (ntStatus);
  }
}
NTSTATUS FlHdbit(PDISKETTE_EXTENSION DisketteExtension) {
  NTSTATUS ntStatus;
  SHORT st5;
  BOOLEAN media144MB;
  BOOLEAN mediaUpTo120MB;
  BOOLEAN supportDrive;
  SET_HD_BIT_PARMS setHdBitParameter;

  {
    st5 = 0;
    media144MB = 0;
    mediaUpTo120MB = 0;
    supportDrive = 1;
    {}
    if (DisketteExtension->DriveMediaType == 18) {
      goto switch_186_18;
    } else {
      if (DisketteExtension->DriveMediaType == 16) {
        goto switch_186_16;
      } else {
        if (DisketteExtension->DriveMediaType == 17) {
          goto switch_186_17;
        } else {
          if (DisketteExtension->DriveMediaType == 12) {
            goto switch_186_12;
          } else {
            if (DisketteExtension->DriveMediaType == 13) {
              goto switch_186_13;
            } else {
              if (DisketteExtension->DriveMediaType == 19) {
                goto switch_186_19;
              } else {
                if (DisketteExtension->DriveMediaType == 20) {
                  goto switch_186_20;
                } else {
                  if (DisketteExtension->DriveMediaType == 0) {
                    goto switch_186_0;
                  } else {
                    if (DisketteExtension->DriveMediaType == 1) {
                      goto switch_186_1;
                    } else {
                      if (DisketteExtension->DriveMediaType == 2) {
                        goto switch_186_2;
                      } else {
                        if (DisketteExtension->DriveMediaType == 3) {
                          goto switch_186_3;
                        } else {
                          if (DisketteExtension->DriveMediaType == 4) {
                            goto switch_186_4;
                          } else {
                            if (DisketteExtension->DriveMediaType == 5) {
                              goto switch_186_5;
                            } else {
                              if (DisketteExtension->DriveMediaType == 6) {
                                goto switch_186_6;
                              } else {
                                if (DisketteExtension->DriveMediaType == 7) {
                                  goto switch_186_7;
                                } else {
                                  if (DisketteExtension->DriveMediaType == 8) {
                                    goto switch_186_8;
                                  } else {
                                    if (DisketteExtension->DriveMediaType ==
                                        9) {
                                      goto switch_186_9;
                                    } else {
                                      if (DisketteExtension->DriveMediaType ==
                                          10) {
                                        goto switch_186_10;
                                      } else {
                                        if (DisketteExtension->DriveMediaType ==
                                            11) {
                                          goto switch_186_11;
                                        } else {
                                          if (DisketteExtension
                                                  ->DriveMediaType == 14) {
                                            goto switch_186_14;
                                          } else {
                                            if (DisketteExtension
                                                    ->DriveMediaType == 15) {
                                              goto switch_186_15;
                                            } else {
                                              {
                                                goto switch_186_default;
                                                if (0) {
                                                switch_186_18: /* CIL Label */
                                                  media144MB = 1;
                                                switch_186_16: /* CIL Label */;
                                                switch_186_17: /* CIL Label */;
                                                switch_186_12: /* CIL Label */;
                                                switch_186_13: /* CIL Label */;
                                                switch_186_19: /* CIL Label */;
                                                switch_186_20: /* CIL Label */
                                                  mediaUpTo120MB = 1;
                                                switch_186_0: /* CIL Label */;
                                                switch_186_1: /* CIL Label */;
                                                switch_186_2: /* CIL Label */;
                                                switch_186_3: /* CIL Label */;
                                                switch_186_4: /* CIL Label */;
                                                switch_186_5: /* CIL Label */;
                                                switch_186_6: /* CIL Label */;
                                                switch_186_7: /* CIL Label */;
                                                switch_186_8: /* CIL Label */;
                                                switch_186_9: /* CIL Label */;
                                                switch_186_10: /* CIL Label */;
                                                switch_186_11: /* CIL Label */;
                                                switch_186_14: /* CIL Label */;
                                                switch_186_15: /* CIL Label */;
                                                  goto switch_186_break;
                                                switch_186_default
                                                    : /* CIL Label */
                                                  mediaUpTo120MB = 1;
                                                  goto switch_186_break;
                                                } else {
                                                switch_186_break
                                                    : /* CIL Label */;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    setHdBitParameter.Media144MB = media144MB;
    setHdBitParameter.More120MB = mediaUpTo120MB;
    setHdBitParameter.DeviceUnit = DisketteExtension->DeviceUnit;
    if ((int)DisketteExtension->DriveType == 3) {
      setHdBitParameter.DriveType144MB = 1;
    } else {
      setHdBitParameter.DriveType144MB = 0;
    }
    {
      ntStatus =
          FlFdcDeviceIo(DisketteExtension->TargetObject,
                        ((7 << 16) | (785 << 2)) | 3, &setHdBitParameter);
    }
    if (!(ntStatus >= 0L)) {
      return (ntStatus);
    } else {
    }
    if (setHdBitParameter.ChangedHdBit) {
      { ntStatus = FlDatarateSpecifyConfigure(DisketteExtension); }
    } else {
    }
    return (ntStatus);
  }
}
NTSTATUS FloppyQueueRequest(PDISKETTE_EXTENSION DisketteExtension, PIRP Irp) {
  KIRQL oldIrql;
  NTSTATUS ntStatus;
  LONG tmp;

  {
    {
      /*   ExAcquireFastMutex(PagingMutex); */ /* INLINED */
      PagingReferenceCount += 1UL;
    }
    if (PagingReferenceCount == 1UL) {
      { /*     MmResetDriverPaging(& DriverEntry); */ /* INLINED */
      }
    } else {
    }
    {
      /*   ExReleaseFastMutex(PagingMutex); */ /* INLINED */
      oldIrql = KfAcquireSpinLock(&DisketteExtension->FlCancelSpinLock);
      InterlockedExchange((LONG *)((PVOID *)(&Irp->CancelRoutine)),
                          (long)((void *)(&FloppyCancelQueuedRequest)));
    }
    if (Irp->Cancel) {
      {
        tmp = InterlockedExchange((LONG *)((PVOID *)(&Irp->CancelRoutine)),
                                  (long)((void *)0));
      }
      if ((void (*)(struct _DEVICE_OBJECT * DeviceObject, struct _IRP * Irp))(
              (void *)tmp)) {
        {
          Irp->IoStatus.__annonCompField4.Status = -1073741536L;
          myStatus = -1073741536L;
          Irp->IoStatus.Information = 0;
          /*       KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql); */ /* INLINED */
          IofCompleteRequest(Irp, 0);
          /*       ExAcquireFastMutex(PagingMutex); */ /* INLINED */
          PagingReferenceCount -= 1UL;
        }
        if (PagingReferenceCount == 0UL) {
          { /* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
          }
        } else {
        }
        {
          /*       ExReleaseFastMutex(PagingMutex); */ /* INLINED */
          ntStatus = -1073741536L;
        }
      } else {
        goto _L;
      }
    } else {
    _L: /* CIL Label */
      Irp->IoStatus.__annonCompField4.Status = 259L;
      myStatus = 259L;
      (Irp->Tail.Overlay.__annonCompField17.__annonCompField16
           .CurrentStackLocation)
          ->Control = (int)(Irp->Tail.Overlay.__annonCompField17
                                .__annonCompField16.CurrentStackLocation)
                          ->Control |
                      1;
      if (pended == 0) {
        pended = 1;
      } else {
        { errorFn(); }
      }
      {
        ExfInterlockedInsertTailList(
            &DisketteExtension->NewRequestQueue,
            &Irp->Tail.Overlay.__annonCompField17.ListEntry,
            &DisketteExtension->NewRequestQueueSpinLock);
        /*     KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql); */ /* INLINED */
        ntStatus = 259L;
      }
    }
    return (ntStatus);
  }
}
void FloppyCancelQueuedRequest(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
  PDISKETTE_EXTENSION disketteExtension;
  KIRQL oldIrql;
  PLIST_ENTRY _EX_Blink;
  PLIST_ENTRY _EX_Flink;

  {
    disketteExtension = DeviceObject->DeviceExtension;
    {} {
      oldIrql = KfAcquireSpinLock(&disketteExtension->FlCancelSpinLock);
      Irp->IoStatus.__annonCompField4.Status = -1073741536L;
      myStatus = -1073741536L;
      Irp->IoStatus.Information = 0;
    }
    if (Irp->Tail.Overlay.__annonCompField17.ListEntry.Flink) {
      _EX_Flink = Irp->Tail.Overlay.__annonCompField17.ListEntry.Flink;
      _EX_Blink = Irp->Tail.Overlay.__annonCompField17.ListEntry.Blink;
      _EX_Blink->Flink = _EX_Flink;
      _EX_Flink->Blink = _EX_Blink;
    } else {
    }
    {
      /*   KfReleaseSpinLock(& disketteExtension->FlCancelSpinLock, oldIrql); */ /* INLINED */
      /*   IoReleaseCancelSpinLock(Irp->CancelIrql); */ /* INLINED */
      IofCompleteRequest(Irp, 0);
      /*   ExAcquireFastMutex(PagingMutex); */ /* INLINED */
      PagingReferenceCount -= 1UL;
    }
    if (PagingReferenceCount == 0UL) {
      { /* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
      }
    } else {
    }
    { /*   ExReleaseFastMutex(PagingMutex); */ /* INLINED */
    }
    return;
  }
}
void FloppyProcessQueuedRequests(PDISKETTE_EXTENSION DisketteExtension) {
  KIRQL oldIrql;
  PLIST_ENTRY headOfList;
  PIRP currentIrp;
  PIO_STACK_LOCATION irpSp;
  LONG tmp;

  {
    { oldIrql = KfAcquireSpinLock(&DisketteExtension->FlCancelSpinLock); }
    {
      while (1) {
      while_188_continue: /* CIL Label */;
        {
          headOfList = ExfInterlockedRemoveHeadList(
              &DisketteExtension->NewRequestQueue,
              &DisketteExtension->NewRequestQueueSpinLock);
        }
        if ((unsigned int)headOfList != (unsigned int)((void *)0)) {

        } else {
          goto while_188_break;
        }
        {
          currentIrp =
              (IRP *)((CHAR *)headOfList -
                      (unsigned long)(&((IRP *)0)
                                           ->Tail.Overlay.__annonCompField17
                                           .ListEntry));
          tmp = InterlockedExchange(
              (LONG *)((PVOID *)(&currentIrp->CancelRoutine)),
              (long)((void *)0));
        }
        if ((void (*)(struct _DEVICE_OBJECT * DeviceObject, struct _IRP * Irp))(
                (void *)tmp)) {
          irpSp = currentIrp->Tail.Overlay.__annonCompField17.__annonCompField16
                      .CurrentStackLocation;
        } else {
          currentIrp->Tail.Overlay.__annonCompField17.ListEntry.Flink =
              (void *)0;
          currentIrp = (void *)0;
        }
        {
          /*     KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql); */ /* INLINED */
        }
        if (currentIrp) {
          if (DisketteExtension->IsRemoved) {
            {
              currentIrp->IoStatus.Information = 0;
              currentIrp->IoStatus.__annonCompField4.Status = -1073741738L;
              IofCompleteRequest(currentIrp, 0);
            }
          } else {
            if (irpSp->MajorFunction == 3) {
              goto switch_189_3;
            } else {
              if (irpSp->MajorFunction == 4) {
                goto switch_189_4;
              } else {
                if (irpSp->MajorFunction == 14) {
                  goto switch_189_14;
                } else {
                  {
                    goto switch_189_default;
                    if (0) {
                    switch_189_3: /* CIL Label */;
                    switch_189_4 : /* CIL Label */
                    {
                      FloppyReadWrite(DisketteExtension->DeviceObject,
                                      currentIrp);
                    }
                      goto switch_189_break;
                    switch_189_14 : /* CIL Label */
                    {
                      FloppyDeviceControl(DisketteExtension->DeviceObject,
                                          currentIrp);
                    }
                      goto switch_189_break;
                    switch_189_default : /* CIL Label */
                    {
                      currentIrp->IoStatus.Information = 0;
                      currentIrp->IoStatus.__annonCompField4.Status =
                          -1073741823L;
                      IofCompleteRequest(currentIrp, 0);
                    }
                    } else {
                    switch_189_break: /* CIL Label */;
                    }
                  }
                }
              }
            }
          }
        } else {
        }
        if (currentIrp) {
          {
            /*       ExAcquireFastMutex(PagingMutex); */ /* INLINED */
            PagingReferenceCount -= 1UL;
          }
          if (PagingReferenceCount == 0UL) {
            { /* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
            }
          } else {
          }
          { /*       ExReleaseFastMutex(PagingMutex); */ /* INLINED */
          }
        } else {
        }
        { oldIrql = KfAcquireSpinLock(&DisketteExtension->FlCancelSpinLock); }
      }
    while_188_break: /* CIL Label */;
    }
    {
      /*   KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql); */ /* INLINED */
    }
    return;
  }
}
#pragma once
#pragma once
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4035)
#pragma warning(pop)
#pragma once
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(push)
#pragma warning(disable : 4035)
#pragma warning(pop)
#pragma warning(disable : 4035)
#pragma warning(push)
#pragma warning(disable : 4164)
#pragma function(_enable)
#pragma function(_disable)
#pragma warning(pop)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4103)
#pragma warning(disable : 4200)
#pragma warning(default : 4200)
IRP *pirp;
void stub_driver_init(void) {

  {
    s = NP;
    pended = 0;
    compFptr = 0;
    compRegistered = 0;
    lowerDriverReturn = 0;
    setEventCalled = 0;
    customIrp = 0;
    return;
  }
}
int main(void) {
  DRIVER_OBJECT d;
  UNICODE_STRING u;
  NTSTATUS status;
  int we_should_unload = __VERIFIER_nondet_int();
  IRP irp;
  int __BLAST_NONDET = __VERIFIER_nondet_int();
  int irp_choice = __VERIFIER_nondet_int();
  DEVICE_OBJECT devobj;
  d.DriverExtension = malloc(sizeof(struct _DRIVER_EXTENSION));

  {
    {
      status = 0;
      pirp = &irp;
      _BLAST_init();
      status = DriverEntry(&d, &u);
    }
    if (status >= 0L) {
      s = NP;
      customIrp = 0;
      setEventCalled = customIrp;
      lowerDriverReturn = setEventCalled;
      compRegistered = lowerDriverReturn;
      compFptr = compRegistered;
      pended = compFptr;
      pirp->IoStatus.__annonCompField4.Status = 0L;
      myStatus = 0L;
      if (irp_choice == 0) {
        pirp->IoStatus.__annonCompField4.Status = -1073741637L;
        myStatus = -1073741637L;
      } else {
      }
      { stub_driver_init(); }
      if (!(status >= 0L)) {
        return (-1);
      } else {
      }
      if (__BLAST_NONDET == 0) {
        goto switch_190_0;
      } else {
        if (__BLAST_NONDET == 1) {
          goto switch_190_1;
        } else {
          if (__BLAST_NONDET == 2) {
            goto switch_190_2;
          } else {
            if (__BLAST_NONDET == 3) {
              goto switch_190_3;
            } else {
              if (__BLAST_NONDET == 4) {
                goto switch_190_4;
              } else {
                {
                  goto switch_190_default;
                  if (0) {
                  switch_190_0 : /* CIL Label */
                  {
                    status = FloppyCreateClose(&devobj, pirp);
                  }
                    goto switch_190_break;
                  switch_190_1 : /* CIL Label */
                  {
                    status = FloppyCreateClose(&devobj, pirp);
                  }
                    goto switch_190_break;
                  switch_190_2 : /* CIL Label */
                  {
                    status = FloppyDeviceControl(&devobj, pirp);
                  }
                    goto switch_190_break;
                  switch_190_3 : /* CIL Label */
                  {
                    status = FloppyPnp(&devobj, pirp);
                  }
                    goto switch_190_break;
                  switch_190_4 : /* CIL Label */
                  {
                    status = FloppyPower(&devobj, pirp);
                  }
                    goto switch_190_break;
                  switch_190_default: /* CIL Label */;
                    return (-1);
                  } else {
                  switch_190_break: /* CIL Label */;
                  }
                }
              }
            }
          }
        }
      }
      if (we_should_unload) {
        { FloppyUnload(&d); }
      } else {
      }
    } else {
    }
    if (pended == 1) {
      if (s == NP) {
        s = NP;
      } else {
        goto _L___2;
      }
    } else {
    _L___2: /* CIL Label */
      if (pended == 1) {
        if (s == MPR3) {
          s = MPR3;
        } else {
          goto _L___1;
        }
      } else {
      _L___1: /* CIL Label */
        if (s == UNLOADED) {

        } else {
          if (status == -1L) {

          } else {
            if (s != SKIP2) {
              if (s != IPC) {
                if (s != DC) {
                  { errorFn(); }
                } else {
                  goto _L___0;
                }
              } else {
                goto _L___0;
              }
            } else {
            _L___0: /* CIL Label */
              if (pended == 1) {
                if (status != 259L) {
                  status = 0;
                } else {
                }
              } else {
                if (s == DC) {
                  if (status == 259L) {
                    { errorFn(); }
                  } else {
                  }
                } else {
                  if (status != (NTSTATUS)lowerDriverReturn) {
                    { errorFn(); }
                  } else {
                  }
                }
              }
            }
          }
        }
      }
    }
    status = 0;
    return (status);
  }
}
char _SLAM_alloc_dummy;
void ExAcquireFastMutex(PFAST_MUTEX FastMutex);
void ExAcquireFastMutex(PFAST_MUTEX FastMutex) {

  { return; }
}
void ExReleaseFastMutex(PFAST_MUTEX FastMutex);
void ExReleaseFastMutex(PFAST_MUTEX FastMutex) {

  { return; }
}
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes,
                            ULONG Tag);
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes,
                            ULONG Tag) {
  PVOID x;
  char *tmp;

  {
    {
      tmp = malloc(NumberOfBytes);
      x = tmp;
    }
    return (x);
  }
}
void ExFreePool(PVOID P);
void ExFreePool(PVOID P) {

  { return; }
}
PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead,
                                         PLIST_ENTRY ListEntry,
                                         PKSPIN_LOCK Lock);
PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead,
                                         PLIST_ENTRY ListEntry,
                                         PKSPIN_LOCK Lock) {

  { return ((void *)0); }
}
PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead,
                                         PLIST_ENTRY ListEntry,
                                         PKSPIN_LOCK Lock);
PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead,
                                         PLIST_ENTRY ListEntry,
                                         PKSPIN_LOCK Lock) {

  { return ((void *)0); }
}
PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead,
                                         PKSPIN_LOCK Lock);
PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead,
                                         PKSPIN_LOCK Lock) {

  { return ((void *)0); }
}
PMDL IoAllocateMdl(PVOID VirtualAddress, ULONG Length, BOOLEAN SecondaryBuffer,
                   BOOLEAN ChargeQuota, PIRP Irp);
PMDL IoAllocateMdl(PVOID VirtualAddress, ULONG Length, BOOLEAN SecondaryBuffer,
                   BOOLEAN ChargeQuota, PIRP Irp) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();
  char *tmp;

  {
    if (__BLAST_NONDET == 0) {
      goto switch_191_0;
    } else {
      {
        goto switch_191_default;
        if (0) {
        switch_191_0 : /* CIL Label */
        {
          tmp = &_SLAM_alloc_dummy; /* malloc(sizeof(MDL )); */ /* INLINED */
        }
          return ((void *)tmp);
        switch_191_default: /* CIL Label */;
          return ((void *)0);
        } else {
        switch_191_break: /* CIL Label */;
        }
      }
    }
  }
}
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice,
                                           PDEVICE_OBJECT TargetDevice);
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice,
                                           PDEVICE_OBJECT TargetDevice) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_192_0;
    } else {
      {
        goto switch_192_default;
        if (0) {
        switch_192_0: /* CIL Label */;
          return (TargetDevice);
        switch_192_default: /* CIL Label */;
          return ((void *)0);
        } else {
        switch_192_break: /* CIL Label */;
        }
      }
    }
  }
}
PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction,
                                   PDEVICE_OBJECT DeviceObject, PVOID Buffer,
                                   ULONG Length, PLARGE_INTEGER StartingOffset,
                                   PIO_STATUS_BLOCK IoStatusBlock);
PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction,
                                   PDEVICE_OBJECT DeviceObject, PVOID Buffer,
                                   ULONG Length, PLARGE_INTEGER StartingOffset,
                                   PIO_STATUS_BLOCK IoStatusBlock) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();
  char *tmp;

  {
    customIrp = 1;
    if (__BLAST_NONDET == 0) {
      goto switch_193_0;
    } else {
      {
        goto switch_193_default;
        if (0) {
        switch_193_0 : /* CIL Label */
        {
          tmp = &_SLAM_alloc_dummy; /* malloc(sizeof(IRP )); */ /* INLINED */
        }
          return ((void *)tmp);
        switch_193_default: /* CIL Label */;
          return ((void *)0);
        } else {
        switch_193_break: /* CIL Label */;
        }
      }
    }
  }
}
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode,
                                   PDEVICE_OBJECT DeviceObject,
                                   PVOID InputBuffer, ULONG InputBufferLength,
                                   PVOID OutputBuffer, ULONG OutputBufferLength,
                                   BOOLEAN InternalDeviceIoControl,
                                   PKEVENT Event,
                                   PIO_STATUS_BLOCK IoStatusBlock);
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode,
                                   PDEVICE_OBJECT DeviceObject,
                                   PVOID InputBuffer, ULONG InputBufferLength,
                                   PVOID OutputBuffer, ULONG OutputBufferLength,
                                   BOOLEAN InternalDeviceIoControl,
                                   PKEVENT Event,
                                   PIO_STATUS_BLOCK IoStatusBlock) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();
  char *tmp;

  {
    customIrp = 1;
    if (__BLAST_NONDET == 0) {
      goto switch_194_0;
    } else {
      {
        goto switch_194_default;
        if (0) {
        switch_194_0 : /* CIL Label */
        {
          tmp = &_SLAM_alloc_dummy; /* malloc(sizeof(IRP )); */ /* INLINED */
        }
          return ((void *)tmp);
        switch_194_default: /* CIL Label */;
          return ((void *)0);
        } else {
        switch_194_break: /* CIL Label */;
        }
      }
    }
  }
}
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize,
                        PUNICODE_STRING DeviceName, ULONG DeviceType,
                        ULONG DeviceCharacteristics, BOOLEAN Exclusive,
                        PDEVICE_OBJECT *DeviceObject);
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize,
                        PUNICODE_STRING DeviceName, ULONG DeviceType,
                        ULONG DeviceCharacteristics, BOOLEAN Exclusive,
                        PDEVICE_OBJECT *DeviceObject) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();
  char *tmp;

  {
    if (__BLAST_NONDET == 0) {
      goto switch_195_0;
    } else {
      {
        goto switch_195_default;
        if (0) {
        switch_195_0 : /* CIL Label */
        {
          tmp = &_SLAM_alloc_dummy;
          /* malloc(sizeof(DEVICE_OBJECT )); */ /* INLINED */
          *DeviceObject = (void *)tmp;
        }
          return (0L);
        switch_195_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_195_break: /* CIL Label */;
        }
      }
    }
  }
}
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName,
                              PUNICODE_STRING DeviceName);
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName,
                              PUNICODE_STRING DeviceName) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_196_0;
    } else {
      {
        goto switch_196_default;
        if (0) {
        switch_196_0: /* CIL Label */;
          return (0L);
        switch_196_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_196_break: /* CIL Label */;
        }
      }
    }
  }
}
void IoDeleteDevice(PDEVICE_OBJECT DeviceObject);
void IoDeleteDevice(PDEVICE_OBJECT DeviceObject) {

  { return; }
}
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName);
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_197_0;
    } else {
      {
        goto switch_197_default;
        if (0) {
        switch_197_0: /* CIL Label */;
          return (0L);
        switch_197_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_197_break: /* CIL Label */;
        }
      }
    }
  }
}
void IoDetachDevice(PDEVICE_OBJECT TargetDevice);
void IoDetachDevice(PDEVICE_OBJECT TargetDevice) {

  { return; }
}
void IoFreeIrp(PIRP Irp);
void IoFreeIrp(PIRP Irp) {

  { return; }
}
void IoFreeMdl(PMDL Mdl);
void IoFreeMdl(PMDL Mdl) {

  { return; }
}
PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void);
PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) {
  char *tmp;

  {
    {
      tmp = &_SLAM_alloc_dummy;
      /* malloc(sizeof(CONFIGURATION_INFORMATION )); */ /* INLINED */
    }
    return ((void *)tmp);
  }
}
NTSTATUS IoQueryDeviceDescription(
    PINTERFACE_TYPE BusType, PULONG BusNumber,
    PCONFIGURATION_TYPE ControllerType, PULONG ControllerNumber,
    PCONFIGURATION_TYPE PeripheralType, PULONG PeripheralNumber,
    NTSTATUS (*CalloutRoutine)(
        PVOID Context, PUNICODE_STRING PathName, INTERFACE_TYPE BusType,
        ULONG BusNumber, PKEY_VALUE_FULL_INFORMATION *BusInformation,
        CONFIGURATION_TYPE ControllerType, ULONG ControllerNumber,
        PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
        CONFIGURATION_TYPE PeripheralType, ULONG PeripheralNumber,
        PKEY_VALUE_FULL_INFORMATION *PeripheralInformation),
    PVOID Context);
NTSTATUS IoQueryDeviceDescription(
    PINTERFACE_TYPE BusType, PULONG BusNumber,
    PCONFIGURATION_TYPE ControllerType, PULONG ControllerNumber,
    PCONFIGURATION_TYPE PeripheralType, PULONG PeripheralNumber,
    NTSTATUS (*CalloutRoutine)(
        PVOID Context, PUNICODE_STRING PathName, INTERFACE_TYPE BusType,
        ULONG BusNumber, PKEY_VALUE_FULL_INFORMATION *BusInformation,
        CONFIGURATION_TYPE ControllerType, ULONG ControllerNumber,
        PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
        CONFIGURATION_TYPE PeripheralType, ULONG PeripheralNumber,
        PKEY_VALUE_FULL_INFORMATION *PeripheralInformation),
    PVOID Context) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_198_0;
    } else {
      {
        goto switch_198_default;
        if (0) {
        switch_198_0: /* CIL Label */;
          return (0L);
        switch_198_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_198_break: /* CIL Label */;
        }
      }
    }
  }
}
NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject,
                                   GUID const *InterfaceClassGuid,
                                   PUNICODE_STRING ReferenceString,
                                   PUNICODE_STRING SymbolicLinkName);
NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject,
                                   GUID const *InterfaceClassGuid,
                                   PUNICODE_STRING ReferenceString,
                                   PUNICODE_STRING SymbolicLinkName) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_199_0;
    } else {
      {
        goto switch_199_default;
        if (0) {
        switch_199_0: /* CIL Label */;
          return (0L);
        switch_199_default: /* CIL Label */;
          return (-1073741808L);
        } else {
        switch_199_break: /* CIL Label */;
        }
      }
    }
  }
}
void IoReleaseCancelSpinLock(KIRQL Irql);
void IoReleaseCancelSpinLock(KIRQL Irql) {

  { return; }
}
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName,
                                   BOOLEAN Enable);
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName,
                                   BOOLEAN Enable) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_200_0;
    } else {
      {
        goto switch_200_default;
        if (0) {
        switch_200_0: /* CIL Label */;
          return (0L);
        switch_200_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_200_break: /* CIL Label */;
        }
      }
    }
  }
}
void IoSetHardErrorOrVerifyDevice(PIRP Irp, PDEVICE_OBJECT DeviceObject);
void IoSetHardErrorOrVerifyDevice(PIRP Irp, PDEVICE_OBJECT DeviceObject) {

  { return; }
}
void stubMoreProcessingRequired(void) {

  {
    if (s == NP) {
      s = MPR1;
    } else {
      { errorFn(); }
    }
    return;
  }
}
NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();
  NTSTATUS returnVal2;
  int compRetStatus1;
  PVOID lcontext = __VERIFIER_nondet_pointer();
  NTSTATUS tmp;

  {
    if (compRegistered) {
      {
        tmp = FloppyPnpComplete(DeviceObject, Irp, lcontext);
        compRetStatus1 = tmp;
      }
      if ((long)compRetStatus1 == -1073741802L) {
        { stubMoreProcessingRequired(); }
      } else {
      }
    } else {
    }
    if (__BLAST_NONDET == 0) {
      goto switch_201_0;
    } else {
      if (__BLAST_NONDET == 1) {
        goto switch_201_1;
      } else {
        {
          goto switch_201_default;
          if (0) {
          switch_201_0: /* CIL Label */
            returnVal2 = 0L;
            goto switch_201_break;
          switch_201_1: /* CIL Label */
            returnVal2 = -1073741823L;
            goto switch_201_break;
          switch_201_default: /* CIL Label */
            returnVal2 = 259L;
            goto switch_201_break;
          } else {
          switch_201_break: /* CIL Label */;
          }
        }
      }
    }
    if (s == NP) {
      s = IPC;
      lowerDriverReturn = returnVal2;
    } else {
      if (s == MPR1) {
        if (returnVal2 == 259L) {
          s = MPR3;
          lowerDriverReturn = returnVal2;
        } else {
          s = NP;
          lowerDriverReturn = returnVal2;
        }
      } else {
        if (s == SKIP1) {
          s = SKIP2;
          lowerDriverReturn = returnVal2;
        } else {
          { errorFn(); }
        }
      }
    }
    return (returnVal2);
  }
}
void IofCompleteRequest(PIRP Irp, CCHAR PriorityBoost);
void IofCompleteRequest(PIRP Irp, CCHAR PriorityBoost) {

  {
    if (s == NP) {
      s = DC;
    } else {
      { errorFn(); }
    }
    return;
  }
}
KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock);
KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock) {

  { return ((unsigned char)0); }
}
NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable,
                                PLARGE_INTEGER Interval);
NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable,
                                PLARGE_INTEGER Interval) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_202_0;
    } else {
      {
        goto switch_202_default;
        if (0) {
        switch_202_0: /* CIL Label */;
          return (0L);
        switch_202_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_202_break: /* CIL Label */;
        }
      }
    }
  }
}
void KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
void KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State) {

  { return; }
}
void KeInitializeSemaphore(PRKSEMAPHORE Semaphore, LONG Count, LONG Limit);
void KeInitializeSemaphore(PRKSEMAPHORE Semaphore, LONG Count, LONG Limit) {

  { return; }
}
void KeInitializeSpinLock(PKSPIN_LOCK SpinLock);
void KeInitializeSpinLock(PKSPIN_LOCK SpinLock) {

  { return; }
}
LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore, KPRIORITY Increment,
                        LONG Adjustment, BOOLEAN Wait);
LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore, KPRIORITY Increment,
                        LONG Adjustment, BOOLEAN Wait) {
  LONG r = __VERIFIER_nondet_long();

  { return (r); }
}
void KfReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
void KfReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql) {

  { return; }
}
LONG KeSetEvent(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
LONG KeSetEvent(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait) {
  LONG l = __VERIFIER_nondet_long();

  {
    setEventCalled = 1;
    return (l);
  }
}
NTSTATUS KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason,
                               KPROCESSOR_MODE WaitMode, BOOLEAN Alertable,
                               PLARGE_INTEGER Timeout);
NTSTATUS KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason,
                               KPROCESSOR_MODE WaitMode, BOOLEAN Alertable,
                               PLARGE_INTEGER Timeout) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (s == MPR3) {
      if (setEventCalled == 1) {
        s = NP;
        setEventCalled = 0;
      } else {
        goto _L;
      }
    } else {
    _L: /* CIL Label */
      if (customIrp == 1) {
        s = NP;
        customIrp = 0;
      } else {
        if (s == MPR3) {
          { errorFn(); }
        } else {
        }
      }
    }
    if (__BLAST_NONDET == 0) {
      goto switch_203_0;
    } else {
      {
        goto switch_203_default;
        if (0) {
        switch_203_0: /* CIL Label */;
          return (0L);
        switch_203_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_203_break: /* CIL Label */;
        }
      }
    }
  }
}
PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes,
                                 PHYSICAL_ADDRESS HighestAcceptableAddress);
PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes,
                                 PHYSICAL_ADDRESS HighestAcceptableAddress) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();
  char *tmp;

  {
    if (__BLAST_NONDET == 0) {
      goto switch_204_0;
    } else {
      if (__BLAST_NONDET == 1) {
        goto switch_204_1;
      } else {
        if (0) {
        switch_204_0 : /* CIL Label */
        {
          tmp = &_SLAM_alloc_dummy; /* malloc(NumberOfBytes); */ /* INLINED */
        }
          return (tmp);
        switch_204_1: /* CIL Label */;
          return ((void *)0);
        } else {
        switch_204_break: /* CIL Label */;
        }
      }
    }
    return ((void *)0);
  }
}
void MmFreeContiguousMemory(PVOID BaseAddress);
void MmFreeContiguousMemory(PVOID BaseAddress) {

  { return; }
}
PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList,
                                   KPROCESSOR_MODE AccessMode,
                                   MEMORY_CACHING_TYPE CacheType,
                                   PVOID BaseAddress, ULONG BugCheckOnFailure,
                                   MM_PAGE_PRIORITY Priority);
PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList,
                                   KPROCESSOR_MODE AccessMode,
                                   MEMORY_CACHING_TYPE CacheType,
                                   PVOID BaseAddress, ULONG BugCheckOnFailure,
                                   MM_PAGE_PRIORITY Priority) {

  { return ((void *)0); }
}
PVOID MmPageEntireDriver(PVOID AddressWithinSection);
PVOID MmPageEntireDriver(PVOID AddressWithinSection) {

  { return ((void *)0); }
}
void MmResetDriverPaging(PVOID AddressWithinSection);
void MmResetDriverPaging(PVOID AddressWithinSection) {

  { return; }
}
void MmUnlockPages(PMDL MemoryDescriptorList);
void MmUnlockPages(PMDL MemoryDescriptorList) {

  { return; }
}
NTSTATUS
ObReferenceObjectByHandle(HANDLE Handle, ACCESS_MASK DesiredAccess,
                          POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode,
                          PVOID *Object,
                          POBJECT_HANDLE_INFORMATION HandleInformation);
NTSTATUS
ObReferenceObjectByHandle(HANDLE Handle, ACCESS_MASK DesiredAccess,
                          POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode,
                          PVOID *Object,
                          POBJECT_HANDLE_INFORMATION HandleInformation) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_205_0;
    } else {
      {
        goto switch_205_default;
        if (0) {
        switch_205_0: /* CIL Label */;
          return (0L);
        switch_205_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_205_break: /* CIL Label */;
        }
      }
    }
  }
}
void ObfDereferenceObject(PVOID Object);
void ObfDereferenceObject(PVOID Object) {

  { return; }
}
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();
  int compRetStatus;
  NTSTATUS returnVal;
  PVOID lcontext = __VERIFIER_nondet_pointer();
  NTSTATUS tmp;

  {
    if (compRegistered) {
      {
        tmp = FloppyPnpComplete(DeviceObject, Irp, lcontext);
        compRetStatus = tmp;
      }
      if ((long)compRetStatus == -1073741802L) {
        { stubMoreProcessingRequired(); }
      } else {
      }
    } else {
    }
    if (__BLAST_NONDET == 0) {
      goto switch_206_0;
    } else {
      if (__BLAST_NONDET == 1) {
        goto switch_206_1;
      } else {
        {
          goto switch_206_default;
          if (0) {
          switch_206_0: /* CIL Label */
            returnVal = 0L;
            goto switch_206_break;
          switch_206_1: /* CIL Label */
            returnVal = -1073741823L;
            goto switch_206_break;
          switch_206_default: /* CIL Label */
            returnVal = 259L;
            goto switch_206_break;
          } else {
          switch_206_break: /* CIL Label */;
          }
        }
      }
    }
    if (s == NP) {
      s = IPC;
      lowerDriverReturn = returnVal;
    } else {
      if (s == MPR1) {
        if (returnVal == 259L) {
          s = MPR3;
          lowerDriverReturn = returnVal;
        } else {
          s = NP;
          lowerDriverReturn = returnVal;
        }
      } else {
        if (s == SKIP1) {
          s = SKIP2;
          lowerDriverReturn = returnVal;
        } else {
          { errorFn(); }
        }
      }
    }
    return (returnVal);
  }
}
void PoStartNextPowerIrp(PIRP Irp);
void PoStartNextPowerIrp(PIRP Irp) {

  { return; }
}
NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle, ULONG DesiredAccess,
                              POBJECT_ATTRIBUTES ObjectAttributes,
                              HANDLE ProcessHandle, PCLIENT_ID ClientId,
                              void (*StartRoutine)(PVOID StartContext),
                              PVOID StartContext);
NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle, ULONG DesiredAccess,
                              POBJECT_ATTRIBUTES ObjectAttributes,
                              HANDLE ProcessHandle, PCLIENT_ID ClientId,
                              void (*StartRoutine)(PVOID StartContext),
                              PVOID StartContext) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_207_0;
    } else {
      {
        goto switch_207_default;
        if (0) {
        switch_207_0: /* CIL Label */;
          return (0L);
        switch_207_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_207_break: /* CIL Label */;
        }
      }
    }
  }
}
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus);
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_208_0;
    } else {
      {
        goto switch_208_default;
        if (0) {
        switch_208_0: /* CIL Label */;
          return (0L);
        switch_208_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_208_break: /* CIL Label */;
        }
      }
    }
  }
}
NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString,
                                      PANSI_STRING SourceString,
                                      BOOLEAN AllocateDestinationString);
NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString,
                                      PANSI_STRING SourceString,
                                      BOOLEAN AllocateDestinationString) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_209_0;
    } else {
      {
        goto switch_209_default;
        if (0) {
        switch_209_0: /* CIL Label */;
          return (0L);
        switch_209_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_209_break: /* CIL Label */;
        }
      }
    }
  }
}
SIZE_T RtlCompareMemory(void const *Source1, void const *Source2,
                        SIZE_T Length);
SIZE_T RtlCompareMemory(void const *Source1, void const *Source2,
                        SIZE_T Length) {
  SIZE_T r = __VERIFIER_nondet_long();

  { return (r); }
}
void RtlCopyUnicodeString(PUNICODE_STRING DestinationString,
                          PUNICODE_STRING SourceString);
void RtlCopyUnicodeString(PUNICODE_STRING DestinationString,
                          PUNICODE_STRING SourceString) {

  { return; }
}
NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo, PCWSTR Path,
                                PCWSTR ValueName);
NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo, PCWSTR Path,
                                PCWSTR ValueName) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_210_0;
    } else {
      {
        goto switch_210_default;
        if (0) {
        switch_210_0: /* CIL Label */;
          return (0L);
        switch_210_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_210_break: /* CIL Label */;
        }
      }
    }
  }
}
void RtlFreeUnicodeString(PUNICODE_STRING UnicodeString);
void RtlFreeUnicodeString(PUNICODE_STRING UnicodeString) {

  { return; }
}
void RtlInitString(PSTRING DestinationString, PCSZ SourceString);
void RtlInitString(PSTRING DestinationString, PCSZ SourceString) {

  { return; }
}
void RtlInitUnicodeString(PUNICODE_STRING DestinationString,
                          PCWSTR SourceString);
void RtlInitUnicodeString(PUNICODE_STRING DestinationString,
                          PCWSTR SourceString) {

  { return; }
}
NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo, PCWSTR Path,
                                PRTL_QUERY_REGISTRY_TABLE QueryTable,
                                PVOID Context, PVOID Environment);
NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo, PCWSTR Path,
                                PRTL_QUERY_REGISTRY_TABLE QueryTable,
                                PVOID Context, PVOID Environment) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_211_0;
    } else {
      {
        goto switch_211_default;
        if (0) {
        switch_211_0: /* CIL Label */;
          return (0L);
        switch_211_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_211_break: /* CIL Label */;
        }
      }
    }
  }
}
NTSTATUS ZwClose(HANDLE Handle);
NTSTATUS ZwClose(HANDLE Handle) {
  int __BLAST_NONDET = __VERIFIER_nondet_int();

  {
    if (__BLAST_NONDET == 0) {
      goto switch_212_0;
    } else {
      {
        goto switch_212_default;
        if (0) {
        switch_212_0: /* CIL Label */;
          return (0L);
        switch_212_default: /* CIL Label */;
          return (-1073741823L);
        } else {
        switch_212_break: /* CIL Label */;
        }
      }
    }
  }
}
