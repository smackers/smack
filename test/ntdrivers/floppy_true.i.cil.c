#include "smack.h"
extern void *malloc(unsigned long sz );
extern char __VERIFIER_nondet_char(void);
extern int __VERIFIER_nondet_int(void);
extern long __VERIFIER_nondet_long(void);
extern void *__VERIFIER_nondet_pointer(void);
/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#pragma pack(push,8)
typedef unsigned int size_t;
typedef unsigned short wchar_t;
#pragma pack(pop)
#pragma pack(push,8)
#pragma pack(pop)
typedef unsigned long ULONG_PTR;
typedef unsigned long *PULONG_PTR;
typedef ULONG_PTR SIZE_T;
typedef void *PVOID;
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
typedef wchar_t WCHAR;
typedef WCHAR *PWSTR;
typedef WCHAR const   *PCWSTR;
typedef CHAR *PCHAR;
typedef LONG *PLONG;
typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef UCHAR *PUCHAR;
typedef ULONG *PULONG;
typedef void *HANDLE;
typedef HANDLE *PHANDLE;
typedef char CCHAR;
typedef short CSHORT;
typedef ULONG LCID;
typedef LONG NTSTATUS;
typedef long long LONGLONG;
struct __anonstruct____missing_field_name_1 {
   ULONG LowPart ;
   LONG HighPart ;
};
struct __anonstruct_u_2 {
   ULONG LowPart ;
   LONG HighPart ;
};
union _LARGE_INTEGER {
   struct __anonstruct____missing_field_name_1 __annonCompField1 ;
   struct __anonstruct_u_2 u ;
   LONGLONG QuadPart ;
};
typedef union _LARGE_INTEGER LARGE_INTEGER;
typedef LARGE_INTEGER *PLARGE_INTEGER;
struct _LUID {
   ULONG LowPart ;
   LONG HighPart ;
};
typedef struct _LUID LUID;
typedef LARGE_INTEGER PHYSICAL_ADDRESS;
enum _EVENT_TYPE {
    NotificationEvent = 0,
    SynchronizationEvent = 1
} ;
typedef enum _EVENT_TYPE EVENT_TYPE;
typedef char const   *PCSZ;
struct _STRING {
   USHORT Length ;
   USHORT MaximumLength ;
   PCHAR Buffer ;
};
typedef struct _STRING STRING;
typedef STRING *PSTRING;
typedef PSTRING PANSI_STRING;
struct _UNICODE_STRING {
   USHORT Length ;
   USHORT MaximumLength ;
   PWSTR Buffer ;
};
typedef struct _UNICODE_STRING UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef UCHAR BOOLEAN;
struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink ;
   struct _LIST_ENTRY *Blink ;
};
typedef struct _LIST_ENTRY LIST_ENTRY;
typedef struct _LIST_ENTRY *PLIST_ENTRY;
struct _OBJECT_ATTRIBUTES {
   ULONG Length ;
   HANDLE RootDirectory ;
   PUNICODE_STRING ObjectName ;
   ULONG Attributes ;
   PVOID SecurityDescriptor ;
   PVOID SecurityQualityOfService ;
};
typedef struct _OBJECT_ATTRIBUTES OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
struct _GUID {
   unsigned long Data1 ;
   unsigned short Data2 ;
   unsigned short Data3 ;
   unsigned char Data4[8] ;
};
typedef struct _GUID GUID;
typedef UCHAR KIRQL;
enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt = 2,
    NtProductServer = 3
} ;
typedef enum _NT_PRODUCT_TYPE NT_PRODUCT_TYPE;
struct _KTHREAD;
typedef struct _KTHREAD *PKTHREAD;
struct _ETHREAD;
typedef struct _ETHREAD *PETHREAD;
struct _EPROCESS;
typedef struct _EPROCESS *PEPROCESS;
struct _IO_TIMER;
typedef struct _IO_TIMER *PIO_TIMER;
struct _OBJECT_TYPE;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef CCHAR KPROCESSOR_MODE;
struct _KAPC;
struct _KAPC;
typedef void (*PKNORMAL_ROUTINE)(PVOID NormalContext , PVOID SystemArgument1 , PVOID SystemArgument2 );
struct _KAPC {
   CSHORT Type ;
   CSHORT Size ;
   ULONG Spare0 ;
   struct _KTHREAD *Thread ;
   LIST_ENTRY ApcListEntry ;
   void (*KernelRoutine)(struct _KAPC *Apc , PKNORMAL_ROUTINE *NormalRoutine , PVOID *NormalContext ,
                         PVOID *SystemArgument1 , PVOID *SystemArgument2 ) ;
   void (*RundownRoutine)(struct _KAPC *Apc ) ;
   void (*NormalRoutine)(PVOID NormalContext , PVOID SystemArgument1 , PVOID SystemArgument2 ) ;
   PVOID NormalContext ;
   PVOID SystemArgument1 ;
   PVOID SystemArgument2 ;
   CCHAR ApcStateIndex ;
   KPROCESSOR_MODE ApcMode ;
   BOOLEAN Inserted ;
};
typedef struct _KAPC KAPC;
struct _KDPC;
struct _KDPC;
struct _KDPC {
   CSHORT Type ;
   UCHAR Number ;
   UCHAR Importance ;
   LIST_ENTRY DpcListEntry ;
   void (*DeferredRoutine)(struct _KDPC *Dpc , PVOID DeferredContext , PVOID SystemArgument1 ,
                           PVOID SystemArgument2 ) ;
   PVOID DeferredContext ;
   PVOID SystemArgument1 ;
   PVOID SystemArgument2 ;
   PULONG_PTR Lock ;
};
typedef struct _KDPC KDPC;
typedef struct _KDPC *PKDPC;
struct _MDL {
   struct _MDL *Next ;
   CSHORT Size ;
   CSHORT MdlFlags ;
   struct _EPROCESS *Process ;
   PVOID MappedSystemVa ;
   PVOID StartVa ;
   ULONG ByteCount ;
   ULONG ByteOffset ;
};
typedef struct _MDL MDL;
typedef struct _MDL *PMDL;
typedef PVOID PACCESS_TOKEN;
typedef PVOID PSECURITY_DESCRIPTOR;
typedef ULONG ACCESS_MASK;
#pragma pack(push,4)
struct _LUID_AND_ATTRIBUTES {
   LUID Luid ;
   ULONG Attributes ;
};
typedef struct _LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES;
#pragma pack(pop)
struct _PRIVILEGE_SET {
   ULONG PrivilegeCount ;
   ULONG Control ;
   LUID_AND_ATTRIBUTES Privilege[1] ;
};
typedef struct _PRIVILEGE_SET PRIVILEGE_SET;
enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous = 0,
    SecurityIdentification = 1,
    SecurityImpersonation = 2,
    SecurityDelegation = 3
} ;
typedef enum _SECURITY_IMPERSONATION_LEVEL SECURITY_IMPERSONATION_LEVEL;
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE;
struct _SECURITY_QUALITY_OF_SERVICE {
   ULONG Length ;
   SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
   SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode ;
   BOOLEAN EffectiveOnly ;
};
typedef struct _SECURITY_QUALITY_OF_SERVICE *PSECURITY_QUALITY_OF_SERVICE;
typedef ULONG SECURITY_INFORMATION;
typedef LONG KPRIORITY;
typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;
struct _RTL_QUERY_REGISTRY_TABLE {
   NTSTATUS (*QueryRoutine)(PWSTR ValueName , ULONG ValueType ,
                                                            PVOID ValueData , ULONG ValueLength ,
                                                            PVOID Context , PVOID EntryContext ) ;
   ULONG Flags ;
   PWSTR Name ;
   PVOID EntryContext ;
   ULONG DefaultType ;
   PVOID DefaultData ;
   ULONG DefaultLength ;
};
typedef struct _RTL_QUERY_REGISTRY_TABLE RTL_QUERY_REGISTRY_TABLE;
typedef struct _RTL_QUERY_REGISTRY_TABLE *PRTL_QUERY_REGISTRY_TABLE;
union __anonunion____missing_field_name_6 {
   NTSTATUS Status ;
   PVOID Pointer ;
};
struct _IO_STATUS_BLOCK {
   union __anonunion____missing_field_name_6 __annonCompField4 ;
   ULONG_PTR Information ;
};
typedef struct _IO_STATUS_BLOCK IO_STATUS_BLOCK;
typedef struct _IO_STATUS_BLOCK *PIO_STATUS_BLOCK;
enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation = 2,
    FileBothDirectoryInformation = 3,
    FileBasicInformation = 4,
    FileStandardInformation = 5,
    FileInternalInformation = 6,
    FileEaInformation = 7,
    FileAccessInformation = 8,
    FileNameInformation = 9,
    FileRenameInformation = 10,
    FileLinkInformation = 11,
    FileNamesInformation = 12,
    FileDispositionInformation = 13,
    FilePositionInformation = 14,
    FileFullEaInformation = 15,
    FileModeInformation = 16,
    FileAlignmentInformation = 17,
    FileAllInformation = 18,
    FileAllocationInformation = 19,
    FileEndOfFileInformation = 20,
    FileAlternateNameInformation = 21,
    FileStreamInformation = 22,
    FilePipeInformation = 23,
    FilePipeLocalInformation = 24,
    FilePipeRemoteInformation = 25,
    FileMailslotQueryInformation = 26,
    FileMailslotSetInformation = 27,
    FileCompressionInformation = 28,
    FileObjectIdInformation = 29,
    FileCompletionInformation = 30,
    FileMoveClusterInformation = 31,
    FileQuotaInformation = 32,
    FileReparsePointInformation = 33,
    FileNetworkOpenInformation = 34,
    FileAttributeTagInformation = 35,
    FileTrackingInformation = 36,
    FileMaximumInformation = 37
} ;
typedef enum _FILE_INFORMATION_CLASS FILE_INFORMATION_CLASS;
struct _FILE_BASIC_INFORMATION {
   LARGE_INTEGER CreationTime ;
   LARGE_INTEGER LastAccessTime ;
   LARGE_INTEGER LastWriteTime ;
   LARGE_INTEGER ChangeTime ;
   ULONG FileAttributes ;
};
typedef struct _FILE_BASIC_INFORMATION *PFILE_BASIC_INFORMATION;
struct _FILE_STANDARD_INFORMATION {
   LARGE_INTEGER AllocationSize ;
   LARGE_INTEGER EndOfFile ;
   ULONG NumberOfLinks ;
   BOOLEAN DeletePending ;
   BOOLEAN Directory ;
};
typedef struct _FILE_STANDARD_INFORMATION *PFILE_STANDARD_INFORMATION;
struct _FILE_NETWORK_OPEN_INFORMATION {
   LARGE_INTEGER CreationTime ;
   LARGE_INTEGER LastAccessTime ;
   LARGE_INTEGER LastWriteTime ;
   LARGE_INTEGER ChangeTime ;
   LARGE_INTEGER AllocationSize ;
   LARGE_INTEGER EndOfFile ;
   ULONG FileAttributes ;
};
typedef struct _FILE_NETWORK_OPEN_INFORMATION *PFILE_NETWORK_OPEN_INFORMATION;
enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation = 2,
    FileFsSizeInformation = 3,
    FileFsDeviceInformation = 4,
    FileFsAttributeInformation = 5,
    FileFsControlInformation = 6,
    FileFsFullSizeInformation = 7,
    FileFsObjectIdInformation = 8,
    FileFsMaximumInformation = 9
} ;
typedef enum _FSINFOCLASS FS_INFORMATION_CLASS;
enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa = 1,
    Eisa = 2,
    MicroChannel = 3,
    TurboChannel = 4,
    PCIBus = 5,
    VMEBus = 6,
    NuBus = 7,
    PCMCIABus = 8,
    CBus = 9,
    MPIBus = 10,
    MPSABus = 11,
    ProcessorInternal = 12,
    InternalPowerBus = 13,
    PNPISABus = 14,
    PNPBus = 15,
    MaximumInterfaceType = 16
} ;
typedef enum _INTERFACE_TYPE INTERFACE_TYPE;
typedef enum _INTERFACE_TYPE *PINTERFACE_TYPE;
struct _KEY_VALUE_FULL_INFORMATION {
   ULONG TitleIndex ;
   ULONG Type ;
   ULONG DataOffset ;
   ULONG DataLength ;
   ULONG NameLength ;
   WCHAR Name[1] ;
};
typedef struct _KEY_VALUE_FULL_INFORMATION *PKEY_VALUE_FULL_INFORMATION;
struct _CLIENT_ID {
   HANDLE UniqueProcess ;
   HANDLE UniqueThread ;
};
typedef struct _CLIENT_ID CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;
enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7
} ;
typedef enum _SYSTEM_POWER_STATE SYSTEM_POWER_STATE;
enum __anonenum_POWER_ACTION_11 {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7
} ;
typedef enum __anonenum_POWER_ACTION_11 POWER_ACTION;
enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5
} ;
typedef enum _DEVICE_POWER_STATE DEVICE_POWER_STATE;
union _POWER_STATE {
   SYSTEM_POWER_STATE SystemState ;
   DEVICE_POWER_STATE DeviceState ;
};
typedef union _POWER_STATE POWER_STATE;
enum _POWER_STATE_TYPE {
    SystemPowerState = 0,
    DevicePowerState = 1
} ;
typedef enum _POWER_STATE_TYPE POWER_STATE_TYPE;
struct _KSYSTEM_TIME {
   ULONG LowPart ;
   LONG High1Time ;
   LONG High2Time ;
};
typedef struct _KSYSTEM_TIME KSYSTEM_TIME;
enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign = 0,
    NEC98x86 = 1,
    EndAlternatives = 2
} ;
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ALTERNATIVE_ARCHITECTURE_TYPE;
struct _KUSER_SHARED_DATA {
   ULONG volatile   TickCountLow ;
   ULONG TickCountMultiplier ;
   KSYSTEM_TIME volatile   InterruptTime ;
   KSYSTEM_TIME volatile   SystemTime ;
   KSYSTEM_TIME volatile   TimeZoneBias ;
   USHORT ImageNumberLow ;
   USHORT ImageNumberHigh ;
   WCHAR NtSystemRoot[260] ;
   ULONG MaxStackTraceDepth ;
   ULONG CryptoExponent ;
   ULONG TimeZoneId ;
   ULONG Reserved2[8] ;
   NT_PRODUCT_TYPE NtProductType ;
   BOOLEAN ProductTypeIsValid ;
   ULONG NtMajorVersion ;
   ULONG NtMinorVersion ;
   BOOLEAN ProcessorFeatures[64] ;
   ULONG Reserved1 ;
   ULONG Reserved3 ;
   ULONG volatile   TimeSlip ;
   ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture ;
   LARGE_INTEGER SystemExpirationDate ;
   ULONG SuiteMask ;
   BOOLEAN KdDebuggerEnabled ;
};
typedef struct _KUSER_SHARED_DATA KUSER_SHARED_DATA;
typedef PVOID PASSIGNED_RESOURCE;
#pragma pack(push,4)
struct __anonstruct_Generic_16 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
struct __anonstruct_Port_17 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
struct __anonstruct_Interrupt_18 {
   ULONG Level ;
   ULONG Vector ;
   ULONG Affinity ;
};
struct __anonstruct_Memory_19 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
struct __anonstruct_Dma_20 {
   ULONG Channel ;
   ULONG Port ;
   ULONG Reserved1 ;
};
struct __anonstruct_DevicePrivate_21 {
   ULONG Data[3] ;
};
struct __anonstruct_BusNumber_22 {
   ULONG Start ;
   ULONG Length ;
   ULONG Reserved ;
};
struct __anonstruct_DeviceSpecificData_23 {
   ULONG DataSize ;
   ULONG Reserved1 ;
   ULONG Reserved2 ;
};
union __anonunion_u_15 {
   struct __anonstruct_Generic_16 Generic ;
   struct __anonstruct_Port_17 Port ;
   struct __anonstruct_Interrupt_18 Interrupt ;
   struct __anonstruct_Memory_19 Memory ;
   struct __anonstruct_Dma_20 Dma ;
   struct __anonstruct_DevicePrivate_21 DevicePrivate ;
   struct __anonstruct_BusNumber_22 BusNumber ;
   struct __anonstruct_DeviceSpecificData_23 DeviceSpecificData ;
};
struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
   UCHAR Type ;
   UCHAR ShareDisposition ;
   USHORT Flags ;
   union __anonunion_u_15 u ;
};
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR CM_PARTIAL_RESOURCE_DESCRIPTOR;
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#pragma pack(pop)
struct _CM_PARTIAL_RESOURCE_LIST {
   USHORT Version ;
   USHORT Revision ;
   ULONG Count ;
   CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1] ;
};
typedef struct _CM_PARTIAL_RESOURCE_LIST CM_PARTIAL_RESOURCE_LIST;
struct _CM_FULL_RESOURCE_DESCRIPTOR {
   INTERFACE_TYPE InterfaceType ;
   ULONG BusNumber ;
   CM_PARTIAL_RESOURCE_LIST PartialResourceList ;
};
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR CM_FULL_RESOURCE_DESCRIPTOR;
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR *PCM_FULL_RESOURCE_DESCRIPTOR;
struct _CM_RESOURCE_LIST {
   ULONG Count ;
   CM_FULL_RESOURCE_DESCRIPTOR List[1] ;
};
typedef struct _CM_RESOURCE_LIST *PCM_RESOURCE_LIST;
#pragma pack(push,1)
#pragma pack(pop)
struct _CM_FLOPPY_DEVICE_DATA {
   USHORT Version ;
   USHORT Revision ;
   CHAR Size[8] ;
   ULONG MaxDensity ;
   ULONG MountDensity ;
   UCHAR StepRateHeadUnloadTime ;
   UCHAR HeadLoadTime ;
   UCHAR MotorOffTime ;
   UCHAR SectorLengthCode ;
   UCHAR SectorPerTrack ;
   UCHAR ReadWriteGapLength ;
   UCHAR DataTransferLength ;
   UCHAR FormatGapLength ;
   UCHAR FormatFillCharacter ;
   UCHAR HeadSettleTime ;
   UCHAR MotorSettleTime ;
   UCHAR MaximumTrackValue ;
   UCHAR DataTransferRate ;
};
typedef struct _CM_FLOPPY_DEVICE_DATA *PCM_FLOPPY_DEVICE_DATA;
struct __anonstruct_Port_25 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
struct __anonstruct_Memory_26 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
struct __anonstruct_Interrupt_27 {
   ULONG MinimumVector ;
   ULONG MaximumVector ;
};
struct __anonstruct_Dma_28 {
   ULONG MinimumChannel ;
   ULONG MaximumChannel ;
};
struct __anonstruct_Generic_29 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
struct __anonstruct_DevicePrivate_30 {
   ULONG Data[3] ;
};
struct __anonstruct_BusNumber_31 {
   ULONG Length ;
   ULONG MinBusNumber ;
   ULONG MaxBusNumber ;
   ULONG Reserved ;
};
struct __anonstruct_AssignedResource_32 {
   PASSIGNED_RESOURCE AssignedResource ;
};
struct __anonstruct_SubAllocateFrom_33 {
   UCHAR Type ;
   UCHAR Reserved[3] ;
   PASSIGNED_RESOURCE AssignedResource ;
   PHYSICAL_ADDRESS Transformation ;
};
struct __anonstruct_ConfigData_34 {
   ULONG Priority ;
   ULONG Reserved1 ;
   ULONG Reserved2 ;
};
union __anonunion_u_24 {
   struct __anonstruct_Port_25 Port ;
   struct __anonstruct_Memory_26 Memory ;
   struct __anonstruct_Interrupt_27 Interrupt ;
   struct __anonstruct_Dma_28 Dma ;
   struct __anonstruct_Generic_29 Generic ;
   struct __anonstruct_DevicePrivate_30 DevicePrivate ;
   struct __anonstruct_BusNumber_31 BusNumber ;
   struct __anonstruct_AssignedResource_32 AssignedResource ;
   struct __anonstruct_SubAllocateFrom_33 SubAllocateFrom ;
   struct __anonstruct_ConfigData_34 ConfigData ;
};
struct _IO_RESOURCE_DESCRIPTOR {
   UCHAR Option ;
   UCHAR Type ;
   UCHAR ShareDisposition ;
   UCHAR Spare1 ;
   USHORT Flags ;
   USHORT Spare2 ;
   union __anonunion_u_24 u ;
};
typedef struct _IO_RESOURCE_DESCRIPTOR IO_RESOURCE_DESCRIPTOR;
struct _IO_RESOURCE_LIST {
   USHORT Version ;
   USHORT Revision ;
   ULONG Count ;
   IO_RESOURCE_DESCRIPTOR Descriptors[1] ;
};
typedef struct _IO_RESOURCE_LIST IO_RESOURCE_LIST;
struct _IO_RESOURCE_REQUIREMENTS_LIST {
   ULONG ListSize ;
   INTERFACE_TYPE InterfaceType ;
   ULONG BusNumber ;
   ULONG SlotNumber ;
   ULONG Reserved[3] ;
   ULONG AlternativeLists ;
   IO_RESOURCE_LIST List[1] ;
};
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST *PIO_RESOURCE_REQUIREMENTS_LIST;
enum _CONFIGURATION_TYPE {
    ArcSystem = 0,
    CentralProcessor = 1,
    FloatingPointProcessor = 2,
    PrimaryIcache = 3,
    PrimaryDcache = 4,
    SecondaryIcache = 5,
    SecondaryDcache = 6,
    SecondaryCache = 7,
    EisaAdapter = 8,
    TcAdapter = 9,
    ScsiAdapter = 10,
    DtiAdapter = 11,
    MultiFunctionAdapter = 12,
    DiskController = 13,
    TapeController = 14,
    CdromController = 15,
    WormController = 16,
    SerialController = 17,
    NetworkController = 18,
    DisplayController = 19,
    ParallelController = 20,
    PointerController = 21,
    KeyboardController = 22,
    AudioController = 23,
    OtherController = 24,
    DiskPeripheral = 25,
    FloppyDiskPeripheral = 26,
    TapePeripheral = 27,
    ModemPeripheral = 28,
    MonitorPeripheral = 29,
    PrinterPeripheral = 30,
    PointerPeripheral = 31,
    KeyboardPeripheral = 32,
    TerminalPeripheral = 33,
    OtherPeripheral = 34,
    LinePeripheral = 35,
    NetworkPeripheral = 36,
    SystemMemory = 37,
    DockingInformation = 38,
    RealModeIrqRoutingTable = 39,
    MaximumType = 40
} ;
typedef enum _CONFIGURATION_TYPE CONFIGURATION_TYPE;
typedef enum _CONFIGURATION_TYPE *PCONFIGURATION_TYPE;
enum _KWAIT_REASON {
    Executive = 0,
    FreePage = 1,
    PageIn = 2,
    PoolAllocation = 3,
    DelayExecution = 4,
    Suspended = 5,
    UserRequest = 6,
    WrExecutive = 7,
    WrFreePage = 8,
    WrPageIn = 9,
    WrPoolAllocation = 10,
    WrDelayExecution = 11,
    WrSuspended = 12,
    WrUserRequest = 13,
    WrEventPair = 14,
    WrQueue = 15,
    WrLpcReceive = 16,
    WrLpcReply = 17,
    WrVirtualMemory = 18,
    WrPageOut = 19,
    WrRendezvous = 20,
    Spare2 = 21,
    Spare3 = 22,
    Spare4 = 23,
    Spare5 = 24,
    Spare6 = 25,
    WrKernel = 26,
    MaximumWaitReason = 27
} ;
typedef enum _KWAIT_REASON KWAIT_REASON;
struct _DISPATCHER_HEADER {
   UCHAR Type ;
   UCHAR Absolute ;
   UCHAR Size ;
   UCHAR Inserted ;
   LONG SignalState ;
   LIST_ENTRY WaitListHead ;
};
typedef struct _DISPATCHER_HEADER DISPATCHER_HEADER;
struct _KDEVICE_QUEUE {
   CSHORT Type ;
   CSHORT Size ;
   LIST_ENTRY DeviceListHead ;
   KSPIN_LOCK Lock ;
   BOOLEAN Busy ;
};
typedef struct _KDEVICE_QUEUE KDEVICE_QUEUE;
struct _KDEVICE_QUEUE_ENTRY {
   LIST_ENTRY DeviceListEntry ;
   ULONG SortKey ;
   BOOLEAN Inserted ;
};
typedef struct _KDEVICE_QUEUE_ENTRY KDEVICE_QUEUE_ENTRY;
struct _KEVENT {
   DISPATCHER_HEADER Header ;
};
typedef struct _KEVENT KEVENT;
typedef struct _KEVENT *PKEVENT;
typedef struct _KEVENT *PRKEVENT;
struct _KSEMAPHORE {
   DISPATCHER_HEADER Header ;
   LONG Limit ;
};
typedef struct _KSEMAPHORE KSEMAPHORE;
typedef struct _KSEMAPHORE *PKSEMAPHORE;
typedef struct _KSEMAPHORE *PRKSEMAPHORE;
enum _MEMORY_CACHING_TYPE {
    MmNonCached = 0,
    MmCached = 1,
    MmWriteCombined = 2,
    MmHardwareCoherentCached = 3,
    MmNonCachedUnordered = 4,
    MmUSWCCached = 5,
    MmMaximumCacheType = 6
} ;
typedef enum _MEMORY_CACHING_TYPE MEMORY_CACHING_TYPE;
enum _POOL_TYPE {
    NonPagedPool = 0,
    PagedPool = 1,
    NonPagedPoolMustSucceed = 2,
    DontUseThisType = 3,
    NonPagedPoolCacheAligned = 4,
    PagedPoolCacheAligned = 5,
    NonPagedPoolCacheAlignedMustS = 6,
    MaxPoolType = 7,
    NonPagedPoolSession = 32,
    PagedPoolSession = 33,
    NonPagedPoolMustSucceedSession = 34,
    DontUseThisTypeSession = 35,
    NonPagedPoolCacheAlignedSession = 36,
    PagedPoolCacheAlignedSession = 37,
    NonPagedPoolCacheAlignedMustSSession = 38
} ;
typedef enum _POOL_TYPE POOL_TYPE;
struct _FAST_MUTEX {
   LONG Count ;
   PKTHREAD Owner ;
   ULONG Contention ;
   KEVENT Event ;
   ULONG OldIrql ;
};
typedef struct _FAST_MUTEX FAST_MUTEX;
typedef struct _FAST_MUTEX *PFAST_MUTEX;
typedef ULONG_PTR ERESOURCE_THREAD;
union __anonunion____missing_field_name_38 {
   LONG OwnerCount ;
   ULONG TableSize ;
};
struct _OWNER_ENTRY {
   ERESOURCE_THREAD OwnerThread ;
   union __anonunion____missing_field_name_38 __annonCompField10 ;
};
typedef struct _OWNER_ENTRY OWNER_ENTRY;
typedef struct _OWNER_ENTRY *POWNER_ENTRY;
union __anonunion____missing_field_name_39 {
   PVOID Address ;
   ULONG_PTR CreatorBackTraceIndex ;
};
struct _ERESOURCE {
   LIST_ENTRY SystemResourcesList ;
   POWNER_ENTRY OwnerTable ;
   SHORT ActiveCount ;
   USHORT Flag ;
   PKSEMAPHORE SharedWaiters ;
   PKEVENT ExclusiveWaiters ;
   OWNER_ENTRY OwnerThreads[2] ;
   ULONG ContentionCount ;
   USHORT NumberOfSharedWaiters ;
   USHORT NumberOfExclusiveWaiters ;
   union __anonunion____missing_field_name_39 __annonCompField11 ;
   KSPIN_LOCK SpinLock ;
};
enum _LOCK_OPERATION {
    IoReadAccess = 0,
    IoWriteAccess = 1,
    IoModifyAccess = 2
} ;
typedef enum _LOCK_OPERATION LOCK_OPERATION;
enum _MM_PAGE_PRIORITY {
    LowPagePriority = 0,
    NormalPagePriority = 16,
    HighPagePriority = 32
} ;
typedef enum _MM_PAGE_PRIORITY MM_PAGE_PRIORITY;
struct _DRIVER_OBJECT;
struct _DRIVER_OBJECT;
struct _SECURITY_SUBJECT_CONTEXT {
   PACCESS_TOKEN ClientToken ;
   SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
   PACCESS_TOKEN PrimaryToken ;
   PVOID ProcessAuditId ;
};
typedef struct _SECURITY_SUBJECT_CONTEXT SECURITY_SUBJECT_CONTEXT;
struct _INITIAL_PRIVILEGE_SET {
   ULONG PrivilegeCount ;
   ULONG Control ;
   LUID_AND_ATTRIBUTES Privilege[3] ;
};
typedef struct _INITIAL_PRIVILEGE_SET INITIAL_PRIVILEGE_SET;
union __anonunion_Privileges_40 {
   INITIAL_PRIVILEGE_SET InitialPrivilegeSet ;
   PRIVILEGE_SET PrivilegeSet ;
};
struct _ACCESS_STATE {
   LUID OperationID ;
   BOOLEAN SecurityEvaluated ;
   BOOLEAN GenerateAudit ;
   BOOLEAN GenerateOnClose ;
   BOOLEAN PrivilegesAllocated ;
   ULONG Flags ;
   ACCESS_MASK RemainingDesiredAccess ;
   ACCESS_MASK PreviouslyGrantedAccess ;
   ACCESS_MASK OriginalDesiredAccess ;
   SECURITY_SUBJECT_CONTEXT SubjectSecurityContext ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
   PVOID AuxData ;
   union __anonunion_Privileges_40 Privileges ;
   BOOLEAN AuditPrivileges ;
   UNICODE_STRING ObjectName ;
   UNICODE_STRING ObjectTypeName ;
};
typedef struct _ACCESS_STATE *PACCESS_STATE;
struct _DEVICE_OBJECT;
struct _DEVICE_OBJECT;
struct _DRIVER_OBJECT;
struct _FILE_OBJECT;
struct _FILE_OBJECT;
struct _IRP;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;
struct _SCSI_REQUEST_BLOCK;
typedef NTSTATUS (*PDRIVER_DISPATCH)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp );
struct _COMPRESSED_DATA_INFO;
struct _FAST_IO_DISPATCH {
   ULONG SizeOfFastIoDispatch ;
   BOOLEAN (*FastIoCheckIfPossible)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                    ULONG Length , BOOLEAN Wait , ULONG LockKey ,
                                    BOOLEAN CheckForReadOperation , PIO_STATUS_BLOCK IoStatus ,
                                    struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoRead)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                         ULONG Length , BOOLEAN Wait , ULONG LockKey , PVOID Buffer ,
                         PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                          ULONG Length , BOOLEAN Wait , ULONG LockKey , PVOID Buffer ,
                          PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryBasicInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                   PFILE_BASIC_INFORMATION Buffer , PIO_STATUS_BLOCK IoStatus ,
                                   struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryStandardInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                      PFILE_STANDARD_INFORMATION Buffer , PIO_STATUS_BLOCK IoStatus ,
                                      struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoLock)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                         PLARGE_INTEGER Length , PEPROCESS ProcessId , ULONG Key ,
                         BOOLEAN FailImmediately , BOOLEAN ExclusiveLock , PIO_STATUS_BLOCK IoStatus ,
                         struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockSingle)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                 PLARGE_INTEGER Length , PEPROCESS ProcessId , ULONG Key ,
                                 PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockAll)(struct _FILE_OBJECT *FileObject , PEPROCESS ProcessId ,
                              PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockAllByKey)(struct _FILE_OBJECT *FileObject , PVOID ProcessId ,
                                   ULONG Key , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoDeviceControl)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                  PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                  ULONG OutputBufferLength , ULONG IoControlCode ,
                                  PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   void (*AcquireFileForNtCreateSection)(struct _FILE_OBJECT *FileObject ) ;
   void (*ReleaseFileForNtCreateSection)(struct _FILE_OBJECT *FileObject ) ;
   void (*FastIoDetachDevice)(struct _DEVICE_OBJECT *SourceDevice , struct _DEVICE_OBJECT *TargetDevice ) ;
   BOOLEAN (*FastIoQueryNetworkOpenInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                         struct _FILE_NETWORK_OPEN_INFORMATION *Buffer ,
                                         struct _IO_STATUS_BLOCK *IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*AcquireForModWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER EndingOffset ,
                                  struct _ERESOURCE **ResourceToRelease , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlRead)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                      ULONG Length , ULONG LockKey , PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus ,
                      struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlReadComplete)(struct _FILE_OBJECT *FileObject , PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*PrepareMdlWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                              ULONG Length , ULONG LockKey , PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus ,
                              struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlWriteComplete)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                               PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoReadCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                   ULONG Length , ULONG LockKey , PVOID Buffer , PMDL *MdlChain ,
                                   PIO_STATUS_BLOCK IoStatus , struct _COMPRESSED_DATA_INFO *CompressedDataInfo ,
                                   ULONG CompressedDataInfoLength , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoWriteCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                    ULONG Length , ULONG LockKey , PVOID Buffer ,
                                    PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus , struct _COMPRESSED_DATA_INFO *CompressedDataInfo ,
                                    ULONG CompressedDataInfoLength , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlReadCompleteCompressed)(struct _FILE_OBJECT *FileObject , PMDL MdlChain ,
                                        struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlWriteCompleteCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                         PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryOpen)(struct _IRP *Irp , PFILE_NETWORK_OPEN_INFORMATION NetworkInformation ,
                              struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*ReleaseForModWrite)(struct _FILE_OBJECT *FileObject , struct _ERESOURCE *ResourceToRelease ,
                                  struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*AcquireForCcFlush)(struct _FILE_OBJECT *FileObject , struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*ReleaseForCcFlush)(struct _FILE_OBJECT *FileObject , struct _DEVICE_OBJECT *DeviceObject ) ;
};
typedef struct _FAST_IO_DISPATCH *PFAST_IO_DISPATCH;
enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject = 2,
    DeallocateObjectKeepRegisters = 3
} ;
typedef enum _IO_ALLOCATION_ACTION IO_ALLOCATION_ACTION;
struct _IO_SECURITY_CONTEXT {
   PSECURITY_QUALITY_OF_SERVICE SecurityQos ;
   PACCESS_STATE AccessState ;
   ACCESS_MASK DesiredAccess ;
   ULONG FullCreateOptions ;
};
typedef struct _IO_SECURITY_CONTEXT *PIO_SECURITY_CONTEXT;
struct _VPB {
   CSHORT Type ;
   CSHORT Size ;
   USHORT Flags ;
   USHORT VolumeLabelLength ;
   struct _DEVICE_OBJECT *DeviceObject ;
   struct _DEVICE_OBJECT *RealDevice ;
   ULONG SerialNumber ;
   ULONG ReferenceCount ;
   WCHAR VolumeLabel[(32U * sizeof(WCHAR )) / sizeof(WCHAR )] ;
};
typedef struct _VPB *PVPB;
struct _WAIT_CONTEXT_BLOCK {
   KDEVICE_QUEUE_ENTRY WaitQueueEntry ;
   IO_ALLOCATION_ACTION (*DeviceRoutine)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ,
                                         PVOID MapRegisterBase , PVOID Context ) ;
   PVOID DeviceContext ;
   ULONG NumberOfMapRegisters ;
   PVOID DeviceObject ;
   PVOID CurrentIrp ;
   PKDPC BufferChainingDpc ;
};
typedef struct _WAIT_CONTEXT_BLOCK WAIT_CONTEXT_BLOCK;
union __anonunion_Queue_43 {
   LIST_ENTRY ListEntry ;
   WAIT_CONTEXT_BLOCK Wcb ;
};
struct _DEVOBJ_EXTENSION;
struct _DEVICE_OBJECT {
   CSHORT Type ;
   USHORT Size ;
   LONG ReferenceCount ;
   struct _DRIVER_OBJECT *DriverObject ;
   struct _DEVICE_OBJECT *NextDevice ;
   struct _DEVICE_OBJECT *AttachedDevice ;
   struct _IRP *CurrentIrp ;
   PIO_TIMER Timer ;
   ULONG Flags ;
   ULONG Characteristics ;
   PVPB Vpb ;
   PVOID DeviceExtension ;
   ULONG DeviceType ;
   CCHAR StackSize ;
   union __anonunion_Queue_43 Queue ;
   ULONG AlignmentRequirement ;
   KDEVICE_QUEUE DeviceQueue ;
   KDPC Dpc ;
   ULONG ActiveThreadCount ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
   KEVENT DeviceLock ;
   USHORT SectorSize ;
   USHORT Spare1 ;
   struct _DEVOBJ_EXTENSION *DeviceObjectExtension ;
   PVOID Reserved ;
};
typedef struct _DEVICE_OBJECT DEVICE_OBJECT;
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT;
struct _DEVOBJ_EXTENSION {
   CSHORT Type ;
   USHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
};
struct _DRIVER_EXTENSION {
   struct _DRIVER_OBJECT *DriverObject ;
   NTSTATUS (*AddDevice)(struct _DRIVER_OBJECT *DriverObject , struct _DEVICE_OBJECT *PhysicalDeviceObject ) ;
   ULONG Count ;
   UNICODE_STRING ServiceKeyName ;
};
typedef struct _DRIVER_EXTENSION *PDRIVER_EXTENSION;
struct _DRIVER_OBJECT {
   CSHORT Type ;
   CSHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
   ULONG Flags ;
   PVOID DriverStart ;
   ULONG DriverSize ;
   PVOID DriverSection ;
   PDRIVER_EXTENSION DriverExtension ;
   UNICODE_STRING DriverName ;
   PUNICODE_STRING HardwareDatabase ;
   PFAST_IO_DISPATCH FastIoDispatch ;
   NTSTATUS (*DriverInit)(struct _DRIVER_OBJECT *DriverObject , PUNICODE_STRING RegistryPath ) ;
   void (*DriverStartIo)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ) ;
   void (*DriverUnload)(struct _DRIVER_OBJECT *DriverObject ) ;
   PDRIVER_DISPATCH MajorFunction[28] ;
};
typedef struct _DRIVER_OBJECT DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;
struct _SECTION_OBJECT_POINTERS {
   PVOID DataSectionObject ;
   PVOID SharedCacheMap ;
   PVOID ImageSectionObject ;
};
typedef struct _SECTION_OBJECT_POINTERS SECTION_OBJECT_POINTERS;
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;
struct _IO_COMPLETION_CONTEXT {
   PVOID Port ;
   PVOID Key ;
};
typedef struct _IO_COMPLETION_CONTEXT *PIO_COMPLETION_CONTEXT;
struct _FILE_OBJECT {
   CSHORT Type ;
   CSHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
   PVPB Vpb ;
   PVOID FsContext ;
   PVOID FsContext2 ;
   PSECTION_OBJECT_POINTERS SectionObjectPointer ;
   PVOID PrivateCacheMap ;
   NTSTATUS FinalStatus ;
   struct _FILE_OBJECT *RelatedFileObject ;
   BOOLEAN LockOperation ;
   BOOLEAN DeletePending ;
   BOOLEAN ReadAccess ;
   BOOLEAN WriteAccess ;
   BOOLEAN DeleteAccess ;
   BOOLEAN SharedRead ;
   BOOLEAN SharedWrite ;
   BOOLEAN SharedDelete ;
   ULONG Flags ;
   UNICODE_STRING FileName ;
   LARGE_INTEGER CurrentByteOffset ;
   ULONG Waiters ;
   ULONG Busy ;
   PVOID LastLock ;
   KEVENT Lock ;
   KEVENT Event ;
   PIO_COMPLETION_CONTEXT CompletionContext ;
};
typedef struct _FILE_OBJECT *PFILE_OBJECT;
union __anonunion_AssociatedIrp_44 {
   struct _IRP *MasterIrp ;
   LONG IrpCount ;
   PVOID SystemBuffer ;
};
struct __anonstruct_AsynchronousParameters_46 {
   void (*UserApcRoutine)(PVOID ApcContext , PIO_STATUS_BLOCK IoStatusBlock ,
                                                          ULONG Reserved ) ;
   PVOID UserApcContext ;
};
union __anonunion_Overlay_45 {
   struct __anonstruct_AsynchronousParameters_46 AsynchronousParameters ;
   LARGE_INTEGER AllocationSize ;
};
struct __anonstruct____missing_field_name_50 {
   PVOID DriverContext[4] ;
};
union __anonunion____missing_field_name_49 {
   KDEVICE_QUEUE_ENTRY DeviceQueueEntry ;
   struct __anonstruct____missing_field_name_50 __annonCompField14 ;
};
struct _IO_STACK_LOCATION;
union __anonunion____missing_field_name_52 {
   struct _IO_STACK_LOCATION *CurrentStackLocation ;
   ULONG PacketType ;
};
struct __anonstruct____missing_field_name_51 {
   LIST_ENTRY ListEntry ;
   union __anonunion____missing_field_name_52 __annonCompField16 ;
};
struct __anonstruct_Overlay_48 {
   union __anonunion____missing_field_name_49 __annonCompField15 ;
   PETHREAD Thread ;
   PCHAR AuxiliaryBuffer ;
   struct __anonstruct____missing_field_name_51 __annonCompField17 ;
   PFILE_OBJECT OriginalFileObject ;
};
union __anonunion_Tail_47 {
   struct __anonstruct_Overlay_48 Overlay ;
   KAPC Apc ;
   PVOID CompletionKey ;
};
struct _IRP {
   CSHORT Type ;
   USHORT Size ;
   PMDL MdlAddress ;
   ULONG Flags ;
   union __anonunion_AssociatedIrp_44 AssociatedIrp ;
   LIST_ENTRY ThreadListEntry ;
   IO_STATUS_BLOCK IoStatus ;
   KPROCESSOR_MODE RequestorMode ;
   BOOLEAN PendingReturned ;
   CHAR StackCount ;
   CHAR CurrentLocation ;
   BOOLEAN Cancel ;
   KIRQL CancelIrql ;
   CCHAR ApcEnvironment ;
   UCHAR AllocationFlags ;
   PIO_STATUS_BLOCK UserIosb ;
   PKEVENT UserEvent ;
   union __anonunion_Overlay_45 Overlay ;
   void (*CancelRoutine)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ) ;
   PVOID UserBuffer ;
   union __anonunion_Tail_47 Tail ;
};
typedef struct _IRP IRP;
typedef struct _IRP *PIRP;
enum _DEVICE_RELATION_TYPE {
    BusRelations = 0,
    EjectionRelations = 1,
    PowerRelations = 2,
    RemovalRelations = 3,
    TargetDeviceRelation = 4
} ;
typedef enum _DEVICE_RELATION_TYPE DEVICE_RELATION_TYPE;
enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined = 0,
    DeviceUsageTypePaging = 1,
    DeviceUsageTypeHibernation = 2,
    DeviceUsageTypeDumpFile = 3
} ;
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE DEVICE_USAGE_NOTIFICATION_TYPE;
struct _INTERFACE {
   USHORT Size ;
   USHORT Version ;
   PVOID Context ;
   void (*InterfaceReference)(PVOID Context ) ;
   void (*InterfaceDereference)(PVOID Context ) ;
};
typedef struct _INTERFACE *PINTERFACE;
struct _DEVICE_CAPABILITIES {
   USHORT Size ;
   USHORT Version ;
   ULONG DeviceD1 : 1 ;
   ULONG DeviceD2 : 1 ;
   ULONG LockSupported : 1 ;
   ULONG EjectSupported : 1 ;
   ULONG Removable : 1 ;
   ULONG DockDevice : 1 ;
   ULONG UniqueID : 1 ;
   ULONG SilentInstall : 1 ;
   ULONG RawDeviceOK : 1 ;
   ULONG SurpriseRemovalOK : 1 ;
   ULONG WakeFromD0 : 1 ;
   ULONG WakeFromD1 : 1 ;
   ULONG WakeFromD2 : 1 ;
   ULONG WakeFromD3 : 1 ;
   ULONG HardwareDisabled : 1 ;
   ULONG NonDynamic : 1 ;
   ULONG WarmEjectSupported : 1 ;
   ULONG Reserved : 15 ;
   ULONG Address ;
   ULONG UINumber ;
   DEVICE_POWER_STATE DeviceState[7] ;
   SYSTEM_POWER_STATE SystemWake ;
   DEVICE_POWER_STATE DeviceWake ;
   ULONG D1Latency ;
   ULONG D2Latency ;
   ULONG D3Latency ;
};
typedef struct _DEVICE_CAPABILITIES *PDEVICE_CAPABILITIES;
struct _POWER_SEQUENCE {
   ULONG SequenceD1 ;
   ULONG SequenceD2 ;
   ULONG SequenceD3 ;
};
typedef struct _POWER_SEQUENCE *PPOWER_SEQUENCE;
enum __anonenum_BUS_QUERY_ID_TYPE_53 {
    BusQueryDeviceID = 0,
    BusQueryHardwareIDs = 1,
    BusQueryCompatibleIDs = 2,
    BusQueryInstanceID = 3,
    BusQueryDeviceSerialNumber = 4
} ;
typedef enum __anonenum_BUS_QUERY_ID_TYPE_53 BUS_QUERY_ID_TYPE;
enum __anonenum_DEVICE_TEXT_TYPE_54 {
    DeviceTextDescription = 0,
    DeviceTextLocationInformation = 1
} ;
typedef enum __anonenum_DEVICE_TEXT_TYPE_54 DEVICE_TEXT_TYPE;
#pragma pack(push,4)
struct __anonstruct_Create_56 {
   PIO_SECURITY_CONTEXT SecurityContext ;
   ULONG Options ;
   USHORT FileAttributes ;
   USHORT ShareAccess ;
   ULONG EaLength ;
};
struct __anonstruct_Read_57 {
   ULONG Length ;
   ULONG Key ;
   LARGE_INTEGER ByteOffset ;
};
struct __anonstruct_Write_58 {
   ULONG Length ;
   ULONG Key ;
   LARGE_INTEGER ByteOffset ;
};
struct __anonstruct_QueryFile_59 {
   ULONG Length ;
   FILE_INFORMATION_CLASS FileInformationClass ;
};
struct __anonstruct____missing_field_name_62 {
   BOOLEAN ReplaceIfExists ;
   BOOLEAN AdvanceOnly ;
};
union __anonunion____missing_field_name_61 {
   struct __anonstruct____missing_field_name_62 __annonCompField18 ;
   ULONG ClusterCount ;
   HANDLE DeleteHandle ;
};
struct __anonstruct_SetFile_60 {
   ULONG Length ;
   FILE_INFORMATION_CLASS FileInformationClass ;
   PFILE_OBJECT FileObject ;
   union __anonunion____missing_field_name_61 __annonCompField19 ;
};
struct __anonstruct_QueryVolume_63 {
   ULONG Length ;
   FS_INFORMATION_CLASS FsInformationClass ;
};
struct __anonstruct_DeviceIoControl_64 {
   ULONG OutputBufferLength ;
   ULONG InputBufferLength ;
   ULONG IoControlCode ;
   PVOID Type3InputBuffer ;
};
struct __anonstruct_QuerySecurity_65 {
   SECURITY_INFORMATION SecurityInformation ;
   ULONG Length ;
};
struct __anonstruct_SetSecurity_66 {
   SECURITY_INFORMATION SecurityInformation ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
};
struct __anonstruct_MountVolume_67 {
   PVPB Vpb ;
   PDEVICE_OBJECT DeviceObject ;
};
struct __anonstruct_VerifyVolume_68 {
   PVPB Vpb ;
   PDEVICE_OBJECT DeviceObject ;
};
struct __anonstruct_Scsi_69 {
   struct _SCSI_REQUEST_BLOCK *Srb ;
};
struct __anonstruct_QueryDeviceRelations_70 {
   DEVICE_RELATION_TYPE Type ;
};
struct __anonstruct_QueryInterface_71 {
   GUID const   *InterfaceType ;
   USHORT Size ;
   USHORT Version ;
   PINTERFACE Interface ;
   PVOID InterfaceSpecificData ;
};
struct __anonstruct_DeviceCapabilities_72 {
   PDEVICE_CAPABILITIES Capabilities ;
};
struct __anonstruct_FilterResourceRequirements_73 {
   PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList ;
};
struct __anonstruct_ReadWriteConfig_74 {
   ULONG WhichSpace ;
   PVOID Buffer ;
   ULONG Offset ;
   ULONG Length ;
};
struct __anonstruct_SetLock_75 {
   BOOLEAN Lock ;
};
struct __anonstruct_QueryId_76 {
   BUS_QUERY_ID_TYPE IdType ;
};
struct __anonstruct_QueryDeviceText_77 {
   DEVICE_TEXT_TYPE DeviceTextType ;
   LCID LocaleId ;
};
struct __anonstruct_UsageNotification_78 {
   BOOLEAN InPath ;
   BOOLEAN Reserved[3] ;
   DEVICE_USAGE_NOTIFICATION_TYPE Type ;
};
struct __anonstruct_WaitWake_79 {
   SYSTEM_POWER_STATE PowerState ;
};
struct __anonstruct_PowerSequence_80 {
   PPOWER_SEQUENCE PowerSequence ;
};
struct __anonstruct_Power_81 {
   ULONG SystemContext ;
   POWER_STATE_TYPE Type ;
   POWER_STATE State ;
   POWER_ACTION ShutdownType ;
};
struct __anonstruct_StartDevice_82 {
   PCM_RESOURCE_LIST AllocatedResources ;
   PCM_RESOURCE_LIST AllocatedResourcesTranslated ;
};
struct __anonstruct_WMI_83 {
   ULONG_PTR ProviderId ;
   PVOID DataPath ;
   ULONG BufferSize ;
   PVOID Buffer ;
};
struct __anonstruct_Others_84 {
   PVOID Argument1 ;
   PVOID Argument2 ;
   PVOID Argument3 ;
   PVOID Argument4 ;
};
union __anonunion_Parameters_55 {
   struct __anonstruct_Create_56 Create ;
   struct __anonstruct_Read_57 Read ;
   struct __anonstruct_Write_58 Write ;
   struct __anonstruct_QueryFile_59 QueryFile ;
   struct __anonstruct_SetFile_60 SetFile ;
   struct __anonstruct_QueryVolume_63 QueryVolume ;
   struct __anonstruct_DeviceIoControl_64 DeviceIoControl ;
   struct __anonstruct_QuerySecurity_65 QuerySecurity ;
   struct __anonstruct_SetSecurity_66 SetSecurity ;
   struct __anonstruct_MountVolume_67 MountVolume ;
   struct __anonstruct_VerifyVolume_68 VerifyVolume ;
   struct __anonstruct_Scsi_69 Scsi ;
   struct __anonstruct_QueryDeviceRelations_70 QueryDeviceRelations ;
   struct __anonstruct_QueryInterface_71 QueryInterface ;
   struct __anonstruct_DeviceCapabilities_72 DeviceCapabilities ;
   struct __anonstruct_FilterResourceRequirements_73 FilterResourceRequirements ;
   struct __anonstruct_ReadWriteConfig_74 ReadWriteConfig ;
   struct __anonstruct_SetLock_75 SetLock ;
   struct __anonstruct_QueryId_76 QueryId ;
   struct __anonstruct_QueryDeviceText_77 QueryDeviceText ;
   struct __anonstruct_UsageNotification_78 UsageNotification ;
   struct __anonstruct_WaitWake_79 WaitWake ;
   struct __anonstruct_PowerSequence_80 PowerSequence ;
   struct __anonstruct_Power_81 Power ;
   struct __anonstruct_StartDevice_82 StartDevice ;
   struct __anonstruct_WMI_83 WMI ;
   struct __anonstruct_Others_84 Others ;
};
struct _IO_STACK_LOCATION {
   UCHAR MajorFunction ;
   UCHAR MinorFunction ;
   UCHAR Flags ;
   UCHAR Control ;
   union __anonunion_Parameters_55 Parameters ;
   PDEVICE_OBJECT DeviceObject ;
   PFILE_OBJECT FileObject ;
   NTSTATUS (*CompletionRoutine)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) ;
   PVOID Context ;
};
typedef struct _IO_STACK_LOCATION IO_STACK_LOCATION;
typedef struct _IO_STACK_LOCATION *PIO_STACK_LOCATION;
#pragma pack(pop)
struct _CONFIGURATION_INFORMATION {
   ULONG DiskCount ;
   ULONG FloppyCount ;
   ULONG CdRomCount ;
   ULONG TapeCount ;
   ULONG ScsiPortCount ;
   ULONG SerialCount ;
   ULONG ParallelCount ;
   BOOLEAN AtDiskPrimaryAddressClaimed ;
   BOOLEAN AtDiskSecondaryAddressClaimed ;
   ULONG Version ;
   ULONG MediumChangerCount ;
};
typedef struct _CONFIGURATION_INFORMATION CONFIGURATION_INFORMATION;
typedef struct _CONFIGURATION_INFORMATION *PCONFIGURATION_INFORMATION;
struct _OBJECT_HANDLE_INFORMATION {
   ULONG HandleAttributes ;
   ACCESS_MASK GrantedAccess ;
};
typedef struct _OBJECT_HANDLE_INFORMATION *POBJECT_HANDLE_INFORMATION;
enum _MEDIA_TYPE {
    Unknown = 0,
    F5_1Pt2_512 = 1,
    F3_1Pt44_512 = 2,
    F3_2Pt88_512 = 3,
    F3_20Pt8_512 = 4,
    F3_720_512 = 5,
    F5_360_512 = 6,
    F5_320_512 = 7,
    F5_320_1024 = 8,
    F5_180_512 = 9,
    F5_160_512 = 10,
    RemovableMedia = 11,
    FixedMedia = 12,
    F3_120M_512 = 13,
    F3_640_512 = 14,
    F5_640_512 = 15,
    F5_720_512 = 16,
    F3_1Pt2_512 = 17,
    F3_1Pt23_1024 = 18,
    F5_1Pt23_1024 = 19,
    F3_128Mb_512 = 20,
    F3_230Mb_512 = 21,
    F8_256_128 = 22
} ;
typedef enum _MEDIA_TYPE MEDIA_TYPE;
struct _FORMAT_PARAMETERS {
   MEDIA_TYPE MediaType ;
   ULONG StartCylinderNumber ;
   ULONG EndCylinderNumber ;
   ULONG StartHeadNumber ;
   ULONG EndHeadNumber ;
};
typedef struct _FORMAT_PARAMETERS FORMAT_PARAMETERS;
typedef struct _FORMAT_PARAMETERS *PFORMAT_PARAMETERS;
typedef USHORT BAD_TRACK_NUMBER;
typedef USHORT *PBAD_TRACK_NUMBER;
struct _FORMAT_EX_PARAMETERS {
   MEDIA_TYPE MediaType ;
   ULONG StartCylinderNumber ;
   ULONG EndCylinderNumber ;
   ULONG StartHeadNumber ;
   ULONG EndHeadNumber ;
   USHORT FormatGapLength ;
   USHORT SectorsPerTrack ;
   USHORT SectorNumber[1] ;
};
typedef struct _FORMAT_EX_PARAMETERS FORMAT_EX_PARAMETERS;
typedef struct _FORMAT_EX_PARAMETERS *PFORMAT_EX_PARAMETERS;
struct _DISK_GEOMETRY {
   LARGE_INTEGER Cylinders ;
   MEDIA_TYPE MediaType ;
   ULONG TracksPerCylinder ;
   ULONG SectorsPerTrack ;
   ULONG BytesPerSector ;
};
typedef struct _DISK_GEOMETRY DISK_GEOMETRY;
typedef struct _DISK_GEOMETRY *PDISK_GEOMETRY;
#pragma pack(push,1)
#pragma pack(pop)
#pragma pack(push,1)
#pragma pack(pop)
#pragma pack(push,1)
#pragma pack(pop)
#pragma pack(push,1)
#pragma pack(pop)
#pragma pack(push,1)
#pragma pack(pop)
struct _TRANSFER_BUFFER {
   PHYSICAL_ADDRESS Logical ;
   PVOID Virtual ;
};
typedef struct _TRANSFER_BUFFER TRANSFER_BUFFER;
struct _ACPI_FDI_DATA {
   ULONG DriveNumber ;
   ULONG DeviceType ;
   ULONG MaxCylinderNumber ;
   ULONG MaxSectorNumber ;
   ULONG MaxHeadNumber ;
   ULONG StepRateHeadUnloadTime ;
   ULONG HeadLoadTime ;
   ULONG MotorOffTime ;
   ULONG SectorLengthCode ;
   ULONG SectorPerTrack ;
   ULONG ReadWriteGapLength ;
   ULONG DataTransferLength ;
   ULONG FormatGapLength ;
   ULONG FormatFillCharacter ;
   ULONG HeadSettleTime ;
   ULONG MotorSettleTime ;
};
typedef struct _ACPI_FDI_DATA ACPI_FDI_DATA;
enum _ACPI_FDI_DEVICE_TYPE {
    CmosProblem = 0,
    Form525Capacity360 = 1,
    Form525Capacity1200 = 2,
    Form35Capacity720 = 3,
    Form35Capacity1440 = 4,
    Form35Capacity2880 = 5
} ;
struct _FDC_INFO {
   UCHAR FloppyControllerType ;
   UCHAR SpeedsAvailable ;
   ULONG AdapterBufferSize ;
   INTERFACE_TYPE BusType ;
   ULONG BusNumber ;
   ULONG ControllerNumber ;
   ULONG PeripheralNumber ;
   ULONG UnitNumber ;
   ULONG MaxTransferSize ;
   BOOLEAN AcpiBios ;
   BOOLEAN AcpiFdiSupported ;
   ACPI_FDI_DATA AcpiFdiData ;
   ULONG BufferCount ;
   ULONG BufferSize ;
   TRANSFER_BUFFER BufferAddress[] ;
};
typedef struct _FDC_INFO FDC_INFO;
typedef struct _FDC_INFO *PFDC_INFO;
struct _FDC_ENABLE_PARMS {
   UCHAR DriveOnValue ;
   USHORT TimeToWait ;
   BOOLEAN MotorStarted ;
};
typedef struct _FDC_ENABLE_PARMS FDC_ENABLE_PARMS;
struct _FDC_DISK_CHANGE_PARMS {
   UCHAR DriveStatus ;
   UCHAR DriveOnValue ;
};
typedef struct _FDC_DISK_CHANGE_PARMS FDC_DISK_CHANGE_PARMS;
struct _ISSUE_FDC_COMMAND_PARMS {
   PUCHAR FifoInBuffer ;
   PUCHAR FifoOutBuffer ;
   PVOID IoHandle ;
   ULONG IoOffset ;
   ULONG TransferBytes ;
   ULONG TimeOut ;
};
typedef struct _ISSUE_FDC_COMMAND_PARMS ISSUE_FDC_COMMAND_PARMS;
struct _SET_HD_BIT_PARMS {
   BOOLEAN DriveType144MB ;
   BOOLEAN Media144MB ;
   BOOLEAN More120MB ;
   UCHAR DeviceUnit ;
   BOOLEAN ChangedHdBit ;
};
typedef struct _SET_HD_BIT_PARMS SET_HD_BIT_PARMS;
struct _MOUNTDEV_NAME {
   USHORT NameLength ;
   WCHAR Name[1] ;
};
typedef struct _MOUNTDEV_NAME MOUNTDEV_NAME;
typedef struct _MOUNTDEV_NAME *PMOUNTDEV_NAME;
struct _MOUNTDEV_UNIQUE_ID {
   USHORT UniqueIdLength ;
   UCHAR UniqueId[1] ;
};
typedef struct _MOUNTDEV_UNIQUE_ID MOUNTDEV_UNIQUE_ID;
typedef struct _MOUNTDEV_UNIQUE_ID *PMOUNTDEV_UNIQUE_ID;
struct _MOUNTDEV_SUGGESTED_LINK_NAME {
   BOOLEAN UseOnlyIfThereAreNoOtherLinks ;
   USHORT NameLength ;
   WCHAR Name[1] ;
};
typedef struct _MOUNTDEV_SUGGESTED_LINK_NAME MOUNTDEV_SUGGESTED_LINK_NAME;
typedef struct _MOUNTDEV_SUGGESTED_LINK_NAME *PMOUNTDEV_SUGGESTED_LINK_NAME;
struct _BOOT_SECTOR_INFO {
   UCHAR JumpByte[1] ;
   UCHAR Ignore1[2] ;
   UCHAR OemData[8] ;
   UCHAR BytesPerSector[2] ;
   UCHAR Ignore2[6] ;
   UCHAR NumberOfSectors[2] ;
   UCHAR MediaByte[1] ;
   UCHAR Ignore3[2] ;
   UCHAR SectorsPerTrack[2] ;
   UCHAR NumberOfHeads[2] ;
};
typedef struct _BOOT_SECTOR_INFO *PBOOT_SECTOR_INFO;
enum _DRIVE_MEDIA_TYPE {
    Drive360Media160 = 0,
    Drive360Media180 = 1,
    Drive360Media320 = 2,
    Drive360Media32X = 3,
    Drive360Media360 = 4,
    Drive720Media720 = 5,
    Drive120Media160 = 6,
    Drive120Media180 = 7,
    Drive120Media320 = 8,
    Drive120Media32X = 9,
    Drive120Media360 = 10,
    Drive120Media120 = 11,
    Drive144Media720 = 12,
    Drive144Media144 = 13,
    Drive288Media720 = 14,
    Drive288Media144 = 15,
    Drive288Media288 = 16
} ;
typedef enum _DRIVE_MEDIA_TYPE DRIVE_MEDIA_TYPE;
enum _DRIVE_MEDIA_TYPE_NEC98 {
    Drive360Media160Nec98 = 0,
    Drive360Media180Nec98 = 1,
    Drive360Media320Nec98 = 2,
    Drive360Media32XNec98 = 3,
    Drive360Media360Nec98 = 4,
    Drive120Media160Nec98 = 5,
    Drive120Media180Nec98 = 6,
    Drive120Media320Nec98 = 7,
    Drive120Media32XNec98 = 8,
    Drive120Media360Nec98 = 9,
    Drive120Media640Nec98 = 10,
    Drive120Media720Nec98 = 11,
    Drive120Media120Nec98 = 12,
    Drive120Media123Nec98 = 13,
    Drive144Media640Nec98 = 14,
    Drive144Media720Nec98 = 15,
    Drive144Media120Nec98 = 16,
    Drive144Media123Nec98 = 17,
    Drive144Media144Nec98 = 18,
    Drive12EMedia120Nec98 = 19,
    Drive12EMedia123Nec98 = 20
} ;
typedef enum _DRIVE_MEDIA_TYPE_NEC98 DRIVE_MEDIA_TYPE_NEC98;
struct _DRIVE_MEDIA_LIMITS {
   DRIVE_MEDIA_TYPE HighestDriveMediaType ;
   DRIVE_MEDIA_TYPE LowestDriveMediaType ;
};
typedef struct _DRIVE_MEDIA_LIMITS DRIVE_MEDIA_LIMITS;
typedef struct _DRIVE_MEDIA_LIMITS *PDRIVE_MEDIA_LIMITS;
struct _DRIVE_MEDIA_LIMITS_NEC98 {
   DRIVE_MEDIA_TYPE_NEC98 HighestDriveMediaType ;
   DRIVE_MEDIA_TYPE_NEC98 LowestDriveMediaType ;
};
typedef struct _DRIVE_MEDIA_LIMITS_NEC98 DRIVE_MEDIA_LIMITS_NEC98;
struct _DRIVE_MEDIA_CONSTANTS {
   MEDIA_TYPE MediaType ;
   UCHAR StepRateHeadUnloadTime ;
   UCHAR HeadLoadTime ;
   UCHAR MotorOffTime ;
   UCHAR SectorLengthCode ;
   USHORT BytesPerSector ;
   UCHAR SectorsPerTrack ;
   UCHAR ReadWriteGapLength ;
   UCHAR FormatGapLength ;
   UCHAR FormatFillCharacter ;
   UCHAR HeadSettleTime ;
   USHORT MotorSettleTimeRead ;
   USHORT MotorSettleTimeWrite ;
   UCHAR MaximumTrack ;
   UCHAR CylinderShift ;
   UCHAR DataTransferRate ;
   UCHAR NumberOfHeads ;
   UCHAR DataLength ;
   UCHAR MediaByte ;
   UCHAR SkewDelta ;
};
typedef struct _DRIVE_MEDIA_CONSTANTS DRIVE_MEDIA_CONSTANTS;
typedef struct _DRIVE_MEDIA_CONSTANTS *PDRIVE_MEDIA_CONSTANTS;
struct _DISKETTE_EXTENSION {
   KSPIN_LOCK FlCancelSpinLock ;
   PDEVICE_OBJECT UnderlyingPDO ;
   PDEVICE_OBJECT TargetObject ;
   BOOLEAN IsStarted ;
   BOOLEAN IsRemoved ;
   BOOLEAN HoldNewRequests ;
   LIST_ENTRY NewRequestQueue ;
   KSPIN_LOCK NewRequestQueueSpinLock ;
   PDEVICE_OBJECT DeviceObject ;
   KSEMAPHORE RequestSemaphore ;
   KSPIN_LOCK ListSpinLock ;
   FAST_MUTEX ThreadReferenceMutex ;
   LONG ThreadReferenceCount ;
   PKTHREAD FloppyThread ;
   LIST_ENTRY ListEntry ;
   BOOLEAN HardwareFailed ;
   UCHAR HardwareFailCount ;
   ULONG MaxTransferSize ;
   UCHAR FifoBuffer[10] ;
   PUCHAR IoBuffer ;
   PMDL IoBufferMdl ;
   ULONG IoBufferSize ;
   PDRIVER_OBJECT DriverObject ;
   DRIVE_MEDIA_TYPE LastDriveMediaType ;
   BOOLEAN FloppyControllerAllocated ;
   BOOLEAN ACPI_BIOS ;
   UCHAR DriveType ;
   ULONG BytesPerSector ;
   ULONG ByteCapacity ;
   MEDIA_TYPE MediaType ;
   DRIVE_MEDIA_TYPE DriveMediaType ;
   UCHAR DeviceUnit ;
   UCHAR DriveOnValue ;
   BOOLEAN IsReadOnly ;
   DRIVE_MEDIA_CONSTANTS BiosDriveMediaConstants ;
   DRIVE_MEDIA_CONSTANTS DriveMediaConstants ;
   UCHAR PerpendicularMode ;
   BOOLEAN ControllerConfigurable ;
   UNICODE_STRING DeviceName ;
   UNICODE_STRING InterfaceString ;
   UNICODE_STRING ArcName ;
   BOOLEAN ReleaseFdcWithMotorRunning ;
   BOOLEAN PoweringDown ;
   FAST_MUTEX PowerDownMutex ;
   FAST_MUTEX HoldNewReqMutex ;
};
typedef struct _DISKETTE_EXTENSION DISKETTE_EXTENSION;
typedef DISKETTE_EXTENSION *PDISKETTE_EXTENSION;
struct _SENSE_DEVISE_STATUS_PTOS {
   UCHAR ST3_PTOS ;
};
typedef struct _SENSE_DEVISE_STATUS_PTOS SENSE_DEVISE_STATUS_PTOS;
typedef struct _SENSE_DEVISE_STATUS_PTOS *PSENSE_DEVISE_STATUS_PTOS;
#pragma pack(push,8)
#pragma pack(pop)
struct _KAPC;
struct _KDPC;
#pragma pack(push,4)
#pragma pack(pop)
#pragma pack(push,4)
#pragma pack(pop)
#pragma pack(push,1)
#pragma pack(pop)
struct _DRIVER_OBJECT;
struct _DEVICE_OBJECT;
struct _DRIVER_OBJECT;
struct _FILE_OBJECT;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;
#pragma pack(push,4)
#pragma pack(pop)
#pragma once
extern int sprintf(char * , char const   *  , ...) ;
extern int swprintf(wchar_t * , wchar_t const   *  , ...) ;
#pragma once
#pragma once
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable:4035)
#pragma warning(pop)
#pragma once
extern void *memcpy(void * , void const   * , size_t  ) ;
extern void *memset(void * , int  , size_t  ) ;
extern void *memmove(void * , void const   * , size_t  ) ;
extern PKTHREAD KeGetCurrentThread() ;
#pragma warning(disable:4103)
#pragma warning(disable:4103)
  NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo ,
                                                                                                PCWSTR Path ,
                                                                                                PRTL_QUERY_REGISTRY_TABLE QueryTable ,
                                                                                                PVOID Context ,
                                                                                                PVOID Environment ) ;
  NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo ,
                                                                                                PCWSTR Path ,
                                                                                                PCWSTR ValueName ) ;
  void RtlInitString(PSTRING DestinationString ,
                                                                                   PCSZ SourceString ) ;
  void RtlInitUnicodeString(PUNICODE_STRING DestinationString ,
                                                                                          PCWSTR SourceString ) ;
  NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString ,
                                                                                                      PANSI_STRING SourceString ,
                                                                                                      BOOLEAN AllocateDestinationString ) ;
  void RtlCopyUnicodeString(PUNICODE_STRING DestinationString ,
                                                                                          PUNICODE_STRING SourceString ) ;
  void RtlFreeUnicodeString(PUNICODE_STRING UnicodeString ) ;
  SIZE_T RtlCompareMemory(void const   *Source1 ,
                                                                                        void const   *Source2 ,
                                                                                        SIZE_T Length ) ;
#pragma warning(push)
#pragma warning(disable:4035)
#pragma warning(pop)
extern   LONG InterlockedExchange(PLONG Target ,
                                                                                                 LONG Value ) ;
#pragma warning(disable:4035)
#pragma warning(push)
#pragma warning(disable:4164)
#pragma function(_enable)
#pragma function(_disable)
#pragma warning(pop)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
  void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type ,
                                                       BOOLEAN State ) ;
  LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment ,
                                                BOOLEAN Wait ) ;
  void KeInitializeSemaphore(PRKSEMAPHORE Semaphore ,
                                                           LONG Count , LONG Limit ) ;
  LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment ,
                                                        LONG Adjustment , BOOLEAN Wait ) ;
  NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode ,
                                                                BOOLEAN Alertable ,
                                                                PLARGE_INTEGER Interval ) ;
extern   KPRIORITY KeSetPriorityThread(PKTHREAD Thread ,
                                                                     KPRIORITY Priority ) ;
  NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason ,
                                                               KPROCESSOR_MODE WaitMode ,
                                                               BOOLEAN Alertable ,
                                                               PLARGE_INTEGER Timeout ) ;
  void KeInitializeSpinLock(PKSPIN_LOCK SpinLock ) ;
extern   KIRQL KfAcquireSpinLock(PKSPIN_LOCK SpinLock ) ;
  void KfReleaseSpinLock(PKSPIN_LOCK SpinLock ,
                                                                                        KIRQL NewIrql ) ;
  PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType ,
                                                                                            SIZE_T NumberOfBytes ,
                                                                                            ULONG Tag ) ;
  void ExFreePool(PVOID P ) ;
  void ExAcquireFastMutex(PFAST_MUTEX FastMutex ) ;
  void ExReleaseFastMutex(PFAST_MUTEX FastMutex ) ;
  PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead ,
                                                                                                          PLIST_ENTRY ListEntry ,
                                                                                                          PKSPIN_LOCK Lock ) ;
  PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead ,
                                                                                                          PLIST_ENTRY ListEntry ,
                                                                                                          PKSPIN_LOCK Lock ) ;
  PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead ,
                                                                                                          PKSPIN_LOCK Lock ) ;
extern   void MmProbeAndLockPages(PMDL MemoryDescriptorList ,
                                                                KPROCESSOR_MODE AccessMode ,
                                                                LOCK_OPERATION Operation ) ;
  void MmUnlockPages(PMDL MemoryDescriptorList ) ;
  PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList ,
                                                                   KPROCESSOR_MODE AccessMode ,
                                                                   MEMORY_CACHING_TYPE CacheType ,
                                                                   PVOID BaseAddress ,
                                                                   ULONG BugCheckOnFailure ,
                                                                   MM_PAGE_PRIORITY Priority ) ;
  PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes ,
                                                                 PHYSICAL_ADDRESS HighestAcceptableAddress ) ;
  void MmFreeContiguousMemory(PVOID BaseAddress ) ;
  void MmResetDriverPaging(PVOID AddressWithinSection ) ;
  PVOID MmPageEntireDriver(PVOID AddressWithinSection ) ;
  NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle ,
                                                              ULONG DesiredAccess ,
                                                              POBJECT_ATTRIBUTES ObjectAttributes ,
                                                              HANDLE ProcessHandle ,
                                                              PCLIENT_ID ClientId ,
                                                              void (*StartRoutine)(PVOID StartContext ) ,
                                                              PVOID StartContext ) ;
  NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) ;
#pragma warning(disable:4103)
#pragma warning(disable:4103)
  PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length ,
                                                   BOOLEAN SecondaryBuffer , BOOLEAN ChargeQuota ,
                                                   PIRP Irp ) ;
  PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice ,
                                                                           PDEVICE_OBJECT TargetDevice ) ;
  PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction ,
                                                                   PDEVICE_OBJECT DeviceObject ,
                                                                   PVOID Buffer ,
                                                                   ULONG Length ,
                                                                   PLARGE_INTEGER StartingOffset ,
                                                                   PIO_STATUS_BLOCK IoStatusBlock ) ;
  PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode ,
                                                                   PDEVICE_OBJECT DeviceObject ,
                                                                   PVOID InputBuffer ,
                                                                   ULONG InputBufferLength ,
                                                                   PVOID OutputBuffer ,
                                                                   ULONG OutputBufferLength ,
                                                                   BOOLEAN InternalDeviceIoControl ,
                                                                   PKEVENT Event ,
                                                                   PIO_STATUS_BLOCK IoStatusBlock ) ;
  NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject ,
                                                                                        PIRP Irp ) ;
  void IofCompleteRequest(PIRP Irp ,
                                                                                         CCHAR PriorityBoost ) ;
  NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject ,
                                                        ULONG DeviceExtensionSize ,
                                                        PUNICODE_STRING DeviceName ,
                                                        ULONG DeviceType , ULONG DeviceCharacteristics ,
                                                        BOOLEAN Exclusive , PDEVICE_OBJECT *DeviceObject ) ;
  NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName ,
                                                              PUNICODE_STRING DeviceName ) ;
  void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) ;
  NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) ;
  void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) ;
  void IoFreeIrp(PIRP Irp ) ;
  void IoFreeMdl(PMDL Mdl ) ;
  PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) ;
  NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType ,
                                                                  PULONG BusNumber ,
                                                                  PCONFIGURATION_TYPE ControllerType ,
                                                                  PULONG ControllerNumber ,
                                                                  PCONFIGURATION_TYPE PeripheralType ,
                                                                  PULONG PeripheralNumber ,
                                                                  NTSTATUS (*CalloutRoutine)(PVOID Context ,
                                                                                             PUNICODE_STRING PathName ,
                                                                                             INTERFACE_TYPE BusType ,
                                                                                             ULONG BusNumber ,
                                                                                             PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                                                                                             CONFIGURATION_TYPE ControllerType ,
                                                                                             ULONG ControllerNumber ,
                                                                                             PKEY_VALUE_FULL_INFORMATION *ControllerInformation ,
                                                                                             CONFIGURATION_TYPE PeripheralType ,
                                                                                             ULONG PeripheralNumber ,
                                                                                             PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ,
                                                                  PVOID Context ) ;
  void IoReleaseCancelSpinLock(KIRQL Irql ) ;
  void IoSetHardErrorOrVerifyDevice(PIRP Irp , PDEVICE_OBJECT DeviceObject ) ;
  NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject ,
                                                                                                   GUID const   *InterfaceClassGuid ,
                                                                                                   PUNICODE_STRING ReferenceString ,
                                                                                                   PUNICODE_STRING SymbolicLinkName ) ;
  NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName ,
                                                                   BOOLEAN Enable ) ;
#pragma warning(disable:4200)
#pragma warning(default:4200)
  NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject ,
                                                      PIRP Irp ) ;
  void PoStartNextPowerIrp(PIRP Irp ) ;
  NTSTATUS ObReferenceObjectByHandle(HANDLE Handle ,
                                                                   ACCESS_MASK DesiredAccess ,
                                                                   POBJECT_TYPE ObjectType ,
                                                                   KPROCESSOR_MODE AccessMode ,
                                                                   PVOID *Object ,
                                                                   POBJECT_HANDLE_INFORMATION HandleInformation ) ;
  void ObfDereferenceObject(PVOID Object ) ;
  NTSTATUS ZwClose(HANDLE Handle ) ;
#pragma once
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma once
#pragma once
  struct _GUID  const  MOUNTDEV_MOUNTED_DEVICE_GUID  =    {1408590605,
    46783, 4560, {148, 242, 0, 160, 201, 30, 251, 139}};
#pragma once
DRIVE_MEDIA_LIMITS _DriveMediaLimits[5]  = {      {4, 0}, 
        {11, 6}, 
        {5, 5}, 
        {13, 12}, 
        {16, 14}};
DRIVE_MEDIA_LIMITS_NEC98 _DriveMediaLimits_NEC98[6]  = {      {4, 0}, 
        {13, 5}, 
        {11, 5}, 
        {18, 14}, 
        {18, 14}, 
        {20, 19}};
PDRIVE_MEDIA_LIMITS DriveMediaLimits  ;
DRIVE_MEDIA_CONSTANTS _DriveMediaConstants[17]  = 
  {      {10, 223, 2, 37, 2, 512, 8, 42, 80, 246, 15, 1000, 1000, 39, 0, 2, 1, 255, 254,
      0}, 
        {9, 223, 2, 37, 2, 512, 9, 42, 80, 246, 15, 1000, 1000, 39, 0, 2, 1, 255, 252,
      0}, 
        {7, 223, 2, 37, 2, 512, 8, 42, 80, 246, 15, 1000, 1000, 39, 0, 2, 2, 255, 255,
      0}, 
        {8, 223, 2, 37, 3, 1024, 4, 128, 240, 246, 15, 1000, 1000, 39, 0, 2, 2, 255,
      255, 0}, 
        {6, 223, 2, 37, 2, 512, 9, 42, 80, 246, 15, 250, 1000, 39, 0, 2, 2, 255, 253,
      0}, 
        {5, 223, 2, 37, 2, 512, 9, 42, 80, 246, 15, 500, 1000, 79, 0, 2, 2, 255, 249,
      2}, 
        {10, 223, 2, 37, 2, 512, 8, 42, 80, 246, 15, 1000, 1000, 39, 1, 1, 1, 255, 254,
      0}, 
        {9, 223, 2, 37, 2, 512, 9, 42, 80, 246, 15, 1000, 1000, 39, 1, 1, 1, 255, 252,
      0}, 
        {7, 223, 2, 37, 2, 512, 8, 42, 80, 246, 15, 1000, 1000, 39, 1, 1, 2, 255, 255,
      0}, 
        {8, 223, 2, 37, 3, 1024, 4, 128, 240, 246, 15, 1000, 1000, 39, 1, 1, 2, 255,
      255, 0}, 
        {6, 223, 2, 37, 2, 512, 9, 42, 80, 246, 15, 625, 1000, 39, 1, 1, 2, 255, 253,
      0}, 
        {1, 223, 2, 37, 2, 512, 15, 27, 84, 246, 15, 625, 1000, 79, 0, 0, 2, 255, 249,
      0}, 
        {5, 223, 2, 37, 2, 512, 9, 42, 80, 246, 15, 500, 1000, 79, 0, 2, 2, 255, 249,
      2}, 
        {2, 175, 2, 37, 2, 512, 18, 27, 101, 246, 15, 500, 1000, 79, 0, 0, 2, 255, 240,
      3}, 
        {5, 225, 2, 37, 2, 512, 9, 42, 80, 246, 15, 500, 1000, 79, 0, 2, 2, 255, 249,
      2}, 
        {2, 209, 2, 37, 2, 512, 18, 27, 101, 246, 15, 500, 1000, 79, 0, 0, 2, 255, 240,
      3}, 
        {3, 161, 2, 37, 2, 512, 36, 56, 83, 246, 15, 500, 1000, 79, 0, 3, 2, 255, 240,
      6}};
DRIVE_MEDIA_CONSTANTS _DriveMediaConstants_NEC98[21]  = 
  {      {10, 223, 2, 37, 2, 512, 8, 42, 80, 246, 15, 1000, 1000, 39, 0, 2, 1, 255, 254,
      0}, 
        {9, 223, 2, 37, 2, 512, 9, 42, 80, 246, 15, 1000, 1000, 39, 0, 2, 1, 255, 252,
      0}, 
        {7, 223, 2, 37, 2, 512, 8, 42, 80, 246, 15, 1000, 1000, 39, 0, 2, 2, 255, 255,
      0}, 
        {8, 223, 2, 37, 3, 1024, 4, 128, 240, 246, 15, 1000, 1000, 39, 0, 2, 2, 255,
      255, 0}, 
        {6, 223, 2, 37, 2, 512, 9, 42, 80, 246, 15, 250, 1000, 39, 0, 2, 2, 255, 253,
      0}, 
        {10, 223, 22, 37, 2, 512, 8, 42, 80, 229, 15, 1000, 1000, 39, 1, 2, 1, 255, 254,
      0}, 
        {9, 223, 22, 37, 2, 512, 9, 42, 80, 229, 15, 1000, 1000, 39, 1, 2, 1, 255, 252,
      0}, 
        {7, 223, 22, 37, 2, 512, 8, 42, 80, 229, 15, 1000, 1000, 39, 1, 2, 2, 255, 255,
      0}, 
        {8, 223, 22, 37, 3, 1024, 4, 128, 240, 229, 15, 1000, 1000, 39, 1, 2, 2, 255,
      255, 0}, 
        {6, 223, 22, 37, 2, 512, 9, 42, 80, 229, 15, 1000, 1000, 39, 1, 2, 2, 255, 253,
      0}, 
        {15, 223, 22, 37, 2, 512, 8, 42, 80, 229, 15, 1000, 1000, 79, 0, 0, 2, 255, 251,
      0}, 
        {16, 223, 22, 37, 2, 512, 9, 42, 80, 229, 15, 1000, 1000, 79, 0, 0, 2, 255, 249,
      2}, 
        {1, 207, 36, 37, 2, 512, 15, 27, 84, 229, 15, 1000, 1000, 79, 0, 0, 2, 255, 249,
      0}, 
        {19, 207, 36, 37, 3, 1024, 8, 53, 116, 229, 15, 1000, 1000, 76, 0, 0, 2, 255,
      254, 0}, 
        {14, 223, 22, 37, 2, 512, 8, 42, 80, 229, 15, 1000, 1000, 79, 0, 0, 2, 255, 251,
      0}, 
        {5, 223, 22, 37, 2, 512, 9, 42, 80, 229, 15, 1000, 1000, 79, 0, 0, 2, 255, 249,
      2}, 
        {17, 207, 36, 37, 2, 512, 15, 27, 84, 229, 15, 1000, 1000, 79, 0, 0, 2, 255,
      249, 0}, 
        {18, 207, 36, 37, 3, 1024, 8, 53, 116, 229, 15, 1000, 1000, 76, 0, 0, 2, 255,
      254, 0}, 
        {2, 223, 36, 37, 2, 512, 18, 27, 108, 229, 15, 1000, 1000, 79, 0, 0, 2, 255,
      240, 3}, 
        {1, 191, 50, 37, 2, 512, 15, 27, 84, 229, 15, 1000, 1000, 79, 0, 0, 2, 255, 249,
      0}, 
        {19, 191, 50, 37, 3, 1024, 8, 53, 116, 229, 15, 1000, 1000, 76, 0, 0, 2, 255,
      254, 0}};
PDRIVE_MEDIA_CONSTANTS DriveMediaConstants  ;
SENSE_DEVISE_STATUS_PTOS Result_Status3_PTOS[4]  ;
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath ) ;
void FloppyUnload(PDRIVER_OBJECT DriverObject ) ;
NTSTATUS FlConfigCallBack(PVOID Context , PUNICODE_STRING PathName , INTERFACE_TYPE BusType ,
                          ULONG BusNumber , PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                          CONFIGURATION_TYPE ControllerType , ULONG ControllerNumber ,
                          PKEY_VALUE_FULL_INFORMATION *ControllerInformation , CONFIGURATION_TYPE PeripheralType ,
                          ULONG PeripheralNumber , PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ;
NTSTATUS FlInitializeControllerHardware(PDISKETTE_EXTENSION DisketteExtension ) ;
NTSTATUS FloppyCreateClose(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS FloppyDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS FloppyReadWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS FlRecalibrateDrive(PDISKETTE_EXTENSION DisketteExtension ) ;
NTSTATUS FlDatarateSpecifyConfigure(PDISKETTE_EXTENSION DisketteExtension ) ;
NTSTATUS FlStartDrive(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN WriteOperation ,
                      BOOLEAN SetUpMedia , BOOLEAN IgnoreChange ) ;
void FlFinishOperation(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) ;
NTSTATUS FlDetermineMediaType(PDISKETTE_EXTENSION DisketteExtension ) ;
void FloppyThread(PVOID Context ) ;
NTSTATUS FlReadWrite(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN DriveStarted ) ;
NTSTATUS FlFormat(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) ;
NTSTATUS FlIssueCommand(PDISKETTE_EXTENSION DisketteExtension , PUCHAR FifoInBuffer ,
                        PUCHAR FifoOutBuffer , PMDL IoMdl , ULONG IoOffset , ULONG TransferBytes ) ;
BOOLEAN FlCheckFormatParameters(PDISKETTE_EXTENSION DisketteExtension , PFORMAT_PARAMETERS FormatParameters ) ;
NTSTATUS FlQueueIrpToThread(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) ;
NTSTATUS FlInterpretError(UCHAR StatusRegister1 , UCHAR StatusRegister2 ) ;
void FlAllocateIoBuffer(PDISKETTE_EXTENSION DisketteExtension , ULONG BufferSize ) ;
void FlFreeIoBuffer(PDISKETTE_EXTENSION DisketteExtension ) ;
void FlConsolidateMediaTypeWithBootSector(PDISKETTE_EXTENSION DisketteExtension ,
                                          PBOOT_SECTOR_INFO BootSector ) ;
void FlCheckBootSector(PDISKETTE_EXTENSION DisketteExtension ) ;
NTSTATUS FlReadWriteTrack(PDISKETTE_EXTENSION DisketteExtension , PMDL IoMdl , ULONG IoOffset ,
                          BOOLEAN WriteOperation , UCHAR Cylinder , UCHAR Head , UCHAR Sector ,
                          UCHAR NumberOfSectors , BOOLEAN NeedSeek ) ;
NTSTATUS FlFdcDeviceIo(PDEVICE_OBJECT DeviceObject , ULONG Ioctl , PVOID Data ) ;
NTSTATUS FloppyAddDevice(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PhysicalDeviceObject ) ;
NTSTATUS FloppyPnp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS FloppyPower(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS FloppyPnpComplete(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) ;
NTSTATUS FloppyQueueRequest(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) ;
NTSTATUS FloppyStartDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
void FloppyProcessQueuedRequests(PDISKETTE_EXTENSION DisketteExtension ) ;
void FloppyCancelQueuedRequest(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS FlAcpiConfigureFloppy(PDISKETTE_EXTENSION DisketteExtension , PFDC_INFO FdcInfo ) ;
NTSTATUS FlHdbit(PDISKETTE_EXTENSION DisketteExtension ) ;
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,FloppyAddDevice)
#pragma alloc_text(PAGE,FloppyPnp)
#pragma alloc_text(PAGE,FloppyPower)
#pragma alloc_text(PAGE,FlConfigCallBack)
#pragma alloc_text(PAGE,FlInitializeControllerHardware)
#pragma alloc_text(PAGE,FlInterpretError)
#pragma alloc_text(PAGE,FlDatarateSpecifyConfigure)
#pragma alloc_text(PAGE,FlRecalibrateDrive)
#pragma alloc_text(PAGE,FlDetermineMediaType)
#pragma alloc_text(PAGE,FlCheckBootSector)
#pragma alloc_text(PAGE,FlConsolidateMediaTypeWithBootSector)
#pragma alloc_text(PAGE,FlIssueCommand)
#pragma alloc_text(PAGE,FlReadWriteTrack)
#pragma alloc_text(PAGE,FlReadWrite)
#pragma alloc_text(PAGE,FlFormat)
#pragma alloc_text(PAGE,FlFinishOperation)
#pragma alloc_text(PAGE,FlStartDrive)
#pragma alloc_text(PAGE,FloppyThread)
#pragma alloc_text(PAGE,FlAllocateIoBuffer)
#pragma alloc_text(PAGE,FlFreeIoBuffer)
#pragma alloc_text(PAGE,FloppyCreateClose)
#pragma alloc_text(PAGE,FloppyDeviceControl)
#pragma alloc_text(PAGE,FloppyReadWrite)
#pragma alloc_text(PAGE,FlCheckFormatParameters)
#pragma alloc_text(PAGE,FlFdcDeviceIo)
#pragma alloc_text(PAGE,FlHdbit)
void errorFn(void) 
{ 

  {
  ERROR: assert(0);
  goto ERROR;
}
}
NTSTATUS myStatus  ;
int s  ;
int UNLOADED  ;
int NP  ;
int DC  ;
int SKIP1  ;
int SKIP2  ;
int MPR1  ;
int MPR3  ;
int IPC  ;
int pended  ;
NTSTATUS (*compFptr)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context )  ;
int compRegistered  ;
int lowerDriverReturn  ;
int setEventCalled  ;
int customIrp  ;
void _BLAST_init(void) 
{ 

  {
  UNLOADED = 0;
  NP = 1;
  DC = 2;
  SKIP1 = 3;
  SKIP2 = 4;
  MPR1 = 5;
  MPR3 = 6;
  IPC = 7;
  s = UNLOADED;
  pended = 0;
  compFptr = 0;
  compRegistered = 0;
  lowerDriverReturn = 0;
  setEventCalled = 0;
  customIrp = 0;
  return;
}
}
ULONG PagingReferenceCount  =    0;
PFAST_MUTEX PagingMutex  =    (void *)0;
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath ) 
{ NTSTATUS ntStatus ;
  PVOID tmp ;

  {
  ntStatus = 0L;
  {
  }
  {
  DriverObject->MajorFunction[0] = & FloppyCreateClose;
  DriverObject->MajorFunction[2] = & FloppyCreateClose;
  DriverObject->MajorFunction[3] = & FloppyReadWrite;
  DriverObject->MajorFunction[4] = & FloppyReadWrite;
  DriverObject->MajorFunction[14] = & FloppyDeviceControl;
  DriverObject->MajorFunction[27] = & FloppyPnp;
  DriverObject->MajorFunction[22] = & FloppyPower;
  DriverObject->DriverUnload = & FloppyUnload;
  (DriverObject->DriverExtension)->AddDevice = & FloppyAddDevice;
  tmp = ExAllocatePoolWithTag(0, sizeof(FAST_MUTEX ), 1886350406UL);
  PagingMutex = tmp;
  }
  if ((unsigned int )PagingMutex == (unsigned int )((void *)0)) {
    return (-1073741670L);
  } else {

  }
  {
  PagingMutex->Count = 1;
  PagingMutex->Contention = 0;
/*   KeInitializeEvent(& PagingMutex->Event, 1, 0); */ /* INLINED */
/* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
  }
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
    DriveMediaLimits = (struct _DRIVE_MEDIA_LIMITS *)(_DriveMediaLimits_NEC98);
  } else {
    DriveMediaLimits = _DriveMediaLimits;
  }
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
    DriveMediaConstants = _DriveMediaConstants_NEC98;
  } else {
    DriveMediaConstants = _DriveMediaConstants;
  }
  return (ntStatus);
}
}
void FloppyUnload(PDRIVER_OBJECT DriverObject ) 
{ 

  {
  {
  }
  {
/*   ExFreePool(PagingMutex); */ /* INLINED */
  }
  return;
}
}
NTSTATUS FloppyAddDevice(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PhysicalDeviceObject ) 
{ NTSTATUS ntStatus ;
  PDEVICE_OBJECT deviceObject ;
  PDISKETTE_EXTENSION disketteExtension ;
  FDC_INFO fdcInfo ;
  UCHAR arcNameBuffer[256] ;
  STRING arcNameString ;
  WCHAR deviceNameBuffer[20] ;
  UNICODE_STRING deviceName ;
  USHORT i ;
  USHORT tmp ;
  PVOID tmp___0 ;
  PCONFIGURATION_INFORMATION tmp___1 ;

  {
  ntStatus = 0L;
  {
  }
  {
  fdcInfo.BufferCount = 0;
  fdcInfo.BufferSize = 0;
  ntStatus = FlFdcDeviceIo(PhysicalDeviceObject, ((7 << 16) | (770 << 2)) | 3, & fdcInfo);
  }
  if (ntStatus >= 0L) {
    i = 0;
    {
    while (1) {
      while_3_continue: /* CIL Label */ ;
      {
      tmp = i;
      i = (USHORT )((int )i + 1);
      swprintf(deviceNameBuffer, "\\\000D\000e\000v\000i\000c\000e\000\\\000F\000l\000o\000p\000p\000y\000%\000d\000",
               tmp);
/*       RtlInitUnicodeString(& deviceName, deviceNameBuffer); */ /* INLINED */
      ntStatus = IoCreateDevice(DriverObject, sizeof(DISKETTE_EXTENSION ), & deviceName,
                                7, 261, 0, & deviceObject);
      }
      if (ntStatus == -1073741771L) {

      } else {
        goto while_3_break;
      }
    }
    while_3_break: /* CIL Label */ ;
    }
    if (ntStatus >= 0L) {
      disketteExtension = (DISKETTE_EXTENSION *)deviceObject->DeviceExtension;
      {
      }
      {
      tmp___0 = ExAllocatePoolWithTag(1, deviceName.Length, 1886350406UL);
      disketteExtension->DeviceName.Buffer = tmp___0;
      }
      if ((unsigned int )disketteExtension->DeviceName.Buffer == (unsigned int )((void *)0)) {
        {
/*         IoDeleteDevice(deviceObject); */ /* INLINED */
        }
        return (-1073741670L);
      } else {

      }
      {
      disketteExtension->DeviceName.Length = 0;
      disketteExtension->DeviceName.MaximumLength = deviceName.Length;
/*       RtlCopyUnicodeString(& disketteExtension->DeviceName, & deviceName); */ /* INLINED */
      tmp___1 = IoGetConfigurationInformation();
      tmp___1->FloppyCount += 1UL;
      sprintf(arcNameBuffer, "%s(%d)disk(%d)fdisk(%d)", "\\ArcName\\multi", fdcInfo.BusNumber,
              fdcInfo.ControllerNumber, fdcInfo.PeripheralNumber);
/*       RtlInitString(& arcNameString, arcNameBuffer); */ /* INLINED */
      ntStatus = RtlAnsiStringToUnicodeString(& disketteExtension->ArcName, & arcNameString,
                                              1);
      }
      if (ntStatus >= 0L) {
        {
        IoCreateSymbolicLink(& disketteExtension->ArcName, & deviceName);
        }
      } else {

      }
      deviceObject->Flags |= 8208UL;
      if (deviceObject->AlignmentRequirement < 1UL) {
        deviceObject->AlignmentRequirement = 1;
      } else {

      }
      deviceObject->Flags &= 4294967167UL;
      disketteExtension->DriverObject = DriverObject;
      disketteExtension->UnderlyingPDO = PhysicalDeviceObject;
      {
      }
      {
      disketteExtension->TargetObject = IoAttachDeviceToDeviceStack(deviceObject,
                                                                    PhysicalDeviceObject);
      }
      {
      }
      {
/*       KeInitializeSemaphore(& disketteExtension->RequestSemaphore, 0L, 2147483647); */ /* INLINED */
      disketteExtension->PowerDownMutex.Count = 1;
      disketteExtension->PowerDownMutex.Contention = 0;
/*       KeInitializeEvent(& disketteExtension->PowerDownMutex.Event, 1, 0); */ /* INLINED */
/*       KeInitializeSpinLock(& disketteExtension->ListSpinLock); */ /* INLINED */
      disketteExtension->ThreadReferenceMutex.Count = 1;
      disketteExtension->ThreadReferenceMutex.Contention = 0;
/*       KeInitializeEvent(& disketteExtension->ThreadReferenceMutex.Event, 1, 0); */ /* INLINED */
      disketteExtension->HoldNewReqMutex.Count = 1;
      disketteExtension->HoldNewReqMutex.Contention = 0;
/*       KeInitializeEvent(& disketteExtension->HoldNewReqMutex.Event, 1, 0); */ /* INLINED */
      disketteExtension->ListEntry.Blink = & disketteExtension->ListEntry;
      disketteExtension->ListEntry.Flink = disketteExtension->ListEntry.Blink;
      disketteExtension->ThreadReferenceCount = -1;
      disketteExtension->IsStarted = 0;
      disketteExtension->IsRemoved = 0;
      disketteExtension->HoldNewRequests = 0;
      disketteExtension->NewRequestQueue.Blink = & disketteExtension->NewRequestQueue;
      disketteExtension->NewRequestQueue.Flink = disketteExtension->NewRequestQueue.Blink;
/*       KeInitializeSpinLock(& disketteExtension->NewRequestQueueSpinLock); */ /* INLINED */
/*       KeInitializeSpinLock(& disketteExtension->FlCancelSpinLock); */ /* INLINED */
      disketteExtension->FloppyControllerAllocated = 0;
      disketteExtension->ReleaseFdcWithMotorRunning = 0;
      disketteExtension->DeviceObject = deviceObject;
      disketteExtension->IsReadOnly = 0;
      disketteExtension->MediaType = -1;
      }
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
        disketteExtension->ControllerConfigurable = 0;
      } else {
        disketteExtension->ControllerConfigurable = 1;
      }
    } else {

    }
  } else {

  }
  return (ntStatus);
}
}
NTSTATUS FlConfigCallBack(PVOID Context , PUNICODE_STRING PathName , INTERFACE_TYPE BusType ,
                          ULONG BusNumber , PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                          CONFIGURATION_TYPE ControllerType , ULONG ControllerNumber ,
                          PKEY_VALUE_FULL_INFORMATION *ControllerInformation , CONFIGURATION_TYPE PeripheralType ,
                          ULONG PeripheralNumber , PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) 
{ PDISKETTE_EXTENSION disketteExtension ;
  ULONG i ;
  PCM_FULL_RESOURCE_DESCRIPTOR peripheralData ;
  PCM_PARTIAL_RESOURCE_DESCRIPTOR partial ;
  PCM_FLOPPY_DEVICE_DATA fDeviceData ;
  UCHAR driveType ;
  PDRIVE_MEDIA_CONSTANTS biosDriveMediaConstants ;

  {
  disketteExtension = Context;
  if (! ((UCHAR *)*(PeripheralInformation + 1) + (*(PeripheralInformation + 1))->DataLength)) {
    return (-1073741811L);
  } else {

  }
  peripheralData = (struct _CM_FULL_RESOURCE_DESCRIPTOR *)((UCHAR *)*(PeripheralInformation + 1) + (*(PeripheralInformation + 1))->DataOffset);
  i = 0;
  {
  while (1) {
    while_7_continue: /* CIL Label */ ;
    if (i < peripheralData->PartialResourceList.Count) {

    } else {
      goto while_7_break;
    }
    partial = & peripheralData->PartialResourceList.PartialDescriptors[i];
    if ((int )partial->Type == 5) {
      biosDriveMediaConstants = & disketteExtension->BiosDriveMediaConstants;
      fDeviceData = (struct _CM_FLOPPY_DEVICE_DATA *)(partial + 1);
      if (fDeviceData->MaxDensity == 360) {
        goto switch_8_360;
      } else {
        if (fDeviceData->MaxDensity == 1200) {
          goto switch_8_1200;
        } else {
          if (fDeviceData->MaxDensity == 1185) {
            goto switch_8_1185;
          } else {
            if (fDeviceData->MaxDensity == 1423) {
              goto switch_8_1423;
            } else {
              if (fDeviceData->MaxDensity == 1440) {
                goto switch_8_1440;
              } else {
                if (fDeviceData->MaxDensity == 2880) {
                  goto switch_8_2880;
                } else {
                  if (fDeviceData->MaxDensity == 1201) {
                    goto switch_8_1201;
                  } else {
                    {
                    goto switch_8_default;
                    if (0) {
                      switch_8_360: /* CIL Label */ 
                      driveType = 0;
                      goto switch_8_break;
                      switch_8_1200: /* CIL Label */ 
                      driveType = 1;
                      goto switch_8_break;
                      switch_8_1185: /* CIL Label */ 
                      driveType = 1;
                      goto switch_8_break;
                      switch_8_1423: /* CIL Label */ 
                      driveType = 3;
                      goto switch_8_break;
                      switch_8_1440: /* CIL Label */ 
                      driveType = 3;
                      goto switch_8_break;
                      switch_8_2880: /* CIL Label */ 
                      driveType = 4;
                      goto switch_8_break;
                      switch_8_1201: /* CIL Label */ ;
                      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                        driveType = 5;
                        goto switch_8_break;
                      } else {

                      }
                      switch_8_default: /* CIL Label */ ;
                      {
                      }
                      driveType = 1;
                      {
                      }
                      goto switch_8_break;
                    } else {
                      switch_8_break: /* CIL Label */ ;
                    }
                    }
                  }
                }
              }
            }
          }
        }
      }
      disketteExtension->DriveType = driveType;
      *biosDriveMediaConstants = *(DriveMediaConstants + (DriveMediaLimits + driveType)->HighestDriveMediaType);
      if ((int )fDeviceData->Version >= 2) {
        biosDriveMediaConstants->StepRateHeadUnloadTime = fDeviceData->StepRateHeadUnloadTime;
        biosDriveMediaConstants->HeadLoadTime = fDeviceData->HeadLoadTime;
        biosDriveMediaConstants->MotorOffTime = fDeviceData->MotorOffTime;
        biosDriveMediaConstants->SectorLengthCode = fDeviceData->SectorLengthCode;
        if ((int )fDeviceData->SectorPerTrack == 0) {
          return (0L);
        } else {

        }
        if (fDeviceData->MaxDensity == 0UL) {
          return (0L);
        } else {

        }
        biosDriveMediaConstants->SectorsPerTrack = fDeviceData->SectorPerTrack;
        biosDriveMediaConstants->ReadWriteGapLength = fDeviceData->ReadWriteGapLength;
        biosDriveMediaConstants->FormatGapLength = fDeviceData->FormatGapLength;
        biosDriveMediaConstants->FormatFillCharacter = fDeviceData->FormatFillCharacter;
        biosDriveMediaConstants->HeadSettleTime = fDeviceData->HeadSettleTime;
        biosDriveMediaConstants->MotorSettleTimeRead = ((int )fDeviceData->MotorSettleTime * 1000) / 8;
        biosDriveMediaConstants->MotorSettleTimeWrite = ((int )fDeviceData->MotorSettleTime * 1000) / 8;
        if ((int )fDeviceData->MaximumTrackValue == 0) {
          return (0L);
        } else {

        }
        biosDriveMediaConstants->MaximumTrack = fDeviceData->MaximumTrackValue;
        biosDriveMediaConstants->DataLength = fDeviceData->DataTransferLength;
      } else {

      }
    } else {

    }
    i += 1UL;
  }
  while_7_break: /* CIL Label */ ;
  }
  return (0L);
}
}
NTSTATUS FlAcpiConfigureFloppy(PDISKETTE_EXTENSION DisketteExtension , PFDC_INFO FdcInfo ) 
{ UCHAR driveType ;
  PDRIVE_MEDIA_CONSTANTS biosDriveMediaConstants ;

  {
  biosDriveMediaConstants = & DisketteExtension->BiosDriveMediaConstants;
  if (! FdcInfo->AcpiFdiSupported) {
    return (-1073741823L);
  } else {

  }
  if ((enum _ACPI_FDI_DEVICE_TYPE )FdcInfo->AcpiFdiData.DeviceType == 1) {
    goto switch_11_1;
  } else {
    if ((enum _ACPI_FDI_DEVICE_TYPE )FdcInfo->AcpiFdiData.DeviceType == 2) {
      goto switch_11_2;
    } else {
      if ((enum _ACPI_FDI_DEVICE_TYPE )FdcInfo->AcpiFdiData.DeviceType == 3) {
        goto switch_11_3;
      } else {
        if ((enum _ACPI_FDI_DEVICE_TYPE )FdcInfo->AcpiFdiData.DeviceType == 4) {
          goto switch_11_4;
        } else {
          if ((enum _ACPI_FDI_DEVICE_TYPE )FdcInfo->AcpiFdiData.DeviceType == 5) {
            goto switch_11_5;
          } else {
            {
            goto switch_11_default;
            if (0) {
              switch_11_1: /* CIL Label */ 
              driveType = 0;
              goto switch_11_break;
              switch_11_2: /* CIL Label */ 
              driveType = 1;
              goto switch_11_break;
              switch_11_3: /* CIL Label */ 
              driveType = 2;
              goto switch_11_break;
              switch_11_4: /* CIL Label */ 
              driveType = 3;
              goto switch_11_break;
              switch_11_5: /* CIL Label */ 
              driveType = 4;
              goto switch_11_break;
              switch_11_default: /* CIL Label */ 
              driveType = 1;
              goto switch_11_break;
            } else {
              switch_11_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
  }
  DisketteExtension->DriveType = driveType;
  *biosDriveMediaConstants = *(DriveMediaConstants + (DriveMediaLimits + driveType)->HighestDriveMediaType);
  biosDriveMediaConstants->StepRateHeadUnloadTime = (unsigned char )FdcInfo->AcpiFdiData.StepRateHeadUnloadTime;
  biosDriveMediaConstants->HeadLoadTime = (unsigned char )FdcInfo->AcpiFdiData.HeadLoadTime;
  biosDriveMediaConstants->MotorOffTime = (unsigned char )FdcInfo->AcpiFdiData.MotorOffTime;
  biosDriveMediaConstants->SectorLengthCode = (unsigned char )FdcInfo->AcpiFdiData.SectorLengthCode;
  biosDriveMediaConstants->SectorsPerTrack = (unsigned char )FdcInfo->AcpiFdiData.SectorPerTrack;
  biosDriveMediaConstants->ReadWriteGapLength = (unsigned char )FdcInfo->AcpiFdiData.ReadWriteGapLength;
  biosDriveMediaConstants->FormatGapLength = (unsigned char )FdcInfo->AcpiFdiData.FormatGapLength;
  biosDriveMediaConstants->FormatFillCharacter = (unsigned char )FdcInfo->AcpiFdiData.FormatFillCharacter;
  biosDriveMediaConstants->HeadSettleTime = (unsigned char )FdcInfo->AcpiFdiData.HeadSettleTime;
  biosDriveMediaConstants->MotorSettleTimeRead = ((int )((unsigned char )FdcInfo->AcpiFdiData.MotorSettleTime) * 1000) / 8;
  biosDriveMediaConstants->MotorSettleTimeWrite = ((int )((unsigned short )FdcInfo->AcpiFdiData.MotorSettleTime) * 1000) / 8;
  biosDriveMediaConstants->MaximumTrack = (unsigned char )FdcInfo->AcpiFdiData.MaxCylinderNumber;
  biosDriveMediaConstants->DataLength = (unsigned char )FdcInfo->AcpiFdiData.DataTransferLength;
  return (0L);
}
}
NTSTATUS FlQueueIrpToThread(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS status ;
  HANDLE threadHandle ;
  PIO_STACK_LOCATION irpSp ;
  OBJECT_ATTRIBUTES ObjAttributes ;

  {
  {
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
/*   ExAcquireFastMutex(& DisketteExtension->PowerDownMutex); */ /* INLINED */
  }
  if ((int )DisketteExtension->PoweringDown == 1) {
    {
/*     ExReleaseFastMutex(& DisketteExtension->PowerDownMutex); */ /* INLINED */
    }
    {
    }
    myStatus = -1073741101L;
    Irp->IoStatus.__annonCompField4.Status = -1073741101L;
    Irp->IoStatus.Information = 0;
    return (-1073741101L);
  } else {

  }
  {
/*   ExReleaseFastMutex(& DisketteExtension->PowerDownMutex); */ /* INLINED */
  }
  {
  }
  {
/*   ExAcquireFastMutex(& DisketteExtension->ThreadReferenceMutex); */ /* INLINED */
  DisketteExtension->ThreadReferenceCount += 1L;
  }
  if (DisketteExtension->ThreadReferenceCount == 0L) {
    {
    DisketteExtension->ThreadReferenceCount += 1L;
/*     ExAcquireFastMutex(PagingMutex); */ /* INLINED */
    PagingReferenceCount += 1UL;
    }
    if (PagingReferenceCount == 1UL) {
      {
/*       MmResetDriverPaging(& DriverEntry); */ /* INLINED */
      }
    } else {

    }
    {
/*     ExReleaseFastMutex(PagingMutex); */ /* INLINED */
    ObjAttributes.Length = sizeof(OBJECT_ATTRIBUTES );
    ObjAttributes.RootDirectory = (void *)0;
    ObjAttributes.Attributes = 512L;
    ObjAttributes.ObjectName = (void *)0;
    ObjAttributes.SecurityDescriptor = (void *)0;
    ObjAttributes.SecurityQualityOfService = (void *)0;
    status = PsCreateSystemThread(& threadHandle, 0UL, & ObjAttributes, (void *)0L,
                                  (void *)0, & FloppyThread, DisketteExtension);
    }
    if (! (status >= 0L)) {
      {
      DisketteExtension->ThreadReferenceCount = -1;
/*       ExAcquireFastMutex(PagingMutex); */ /* INLINED */
      PagingReferenceCount -= 1UL;
      }
      if (PagingReferenceCount == 0UL) {
        {
/* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
        }
      } else {

      }
      {
/*       ExReleaseFastMutex(PagingMutex); */ /* INLINED */
/*       ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex); */ /* INLINED */
      }
      return (status);
    } else {

    }
    {
    status = ObReferenceObjectByHandle(threadHandle, 1048576L, (void *)0, 0, & DisketteExtension->FloppyThread,
                                       (void *)0);
    ZwClose(threadHandle);
/*     ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex); */ /* INLINED */
    }
    if (! (status >= 0L)) {
      return (status);
    } else {

    }
  } else {
    {
/*     ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex); */ /* INLINED */
    }
  }
  (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control = (int )(Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control | 1;
  if (pended == 0) {
    pended = 1;
  } else {
    {
    errorFn();
    }
  }
  {
  ExfInterlockedInsertTailList(& DisketteExtension->ListEntry, & Irp->Tail.Overlay.__annonCompField17.ListEntry,
                               & DisketteExtension->ListSpinLock);
  KeReleaseSemaphore(& DisketteExtension->RequestSemaphore, 0L, 1, 0);
  }
  return (259L);
}
}
NTSTATUS FloppyCreateClose(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ 

  {
  {
  }
  {
  myStatus = 0L;
  Irp->IoStatus.__annonCompField4.Status = 0L;
  Irp->IoStatus.Information = 1;
  IofCompleteRequest(Irp, 0);
  }
  return (0L);
}
}
NTSTATUS FloppyDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION irpSp ;
  PDISKETTE_EXTENSION disketteExtension ;
  PDISK_GEOMETRY outputBuffer ;
  NTSTATUS ntStatus ;
  ULONG outputBufferLength ;
  UCHAR i ;
  DRIVE_MEDIA_TYPE lowestDriveMediaType ;
  DRIVE_MEDIA_TYPE highestDriveMediaType ;
  ULONG formatExParametersSize ;
  PFORMAT_EX_PARAMETERS formatExParameters ;
  NTSTATUS tmp ;
  PMOUNTDEV_NAME mountName ;
  PMOUNTDEV_UNIQUE_ID uniqueId ;
  BOOLEAN tmp___0 ;
  PMOUNTDEV_SUGGESTED_LINK_NAME suggestedName ;
  WCHAR driveLetterNameBuffer[10] ;
  RTL_QUERY_REGISTRY_TABLE queryTable[2] ;
  PWSTR valueName ;
  UNICODE_STRING driveLetterName ;
  PVOID tmp___1 ;
  int tmp___2 ;

  {
  {
  }
  {
  disketteExtension = DeviceObject->DeviceExtension;
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
/*   ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
  }
  if (disketteExtension->HoldNewRequests) {
    if (irpSp->Parameters.DeviceIoControl.IoControlCode != (ULONG )((50 << 16) | (3 << 14))) {
      {
      ntStatus = FloppyQueueRequest(disketteExtension, Irp);
/*       ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
      }
      return (ntStatus);
    } else {

    }
  } else {

  }
  {
/*   ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
  }
  if (disketteExtension->IsRemoved) {
    {
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.__annonCompField4.Status = -1073741738L;
    myStatus = -1073741738L;
    IofCompleteRequest(Irp, 0);
    }
    return (-1073741738L);
  } else {

  }
  if (! disketteExtension->IsStarted) {
    if (s == NP) {
      s = SKIP1;
    } else {
      {
      errorFn();
      }
    }
    {
    Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
    Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
    tmp = IofCallDriver(disketteExtension->TargetObject, Irp);
    }
    return (tmp);
  } else {

  }
  if (irpSp->Parameters.DeviceIoControl.IoControlCode == ((77UL << 16) | (unsigned long )(2 << 2))) {
    goto switch_16_exp_0;
  } else {
    if (irpSp->Parameters.DeviceIoControl.IoControlCode == 77UL << 16) {
      goto switch_16_exp_1;
    } else {
      if (irpSp->Parameters.DeviceIoControl.IoControlCode == (((7 << 16) | (3 << 14)) | (6 << 2))) {
        goto switch_16_exp_2;
      } else {
        if (irpSp->Parameters.DeviceIoControl.IoControlCode == (((7 << 16) | (3 << 14)) | (11 << 2))) {
          goto switch_16_exp_3;
        } else {
          if (irpSp->Parameters.DeviceIoControl.IoControlCode == (((7 << 16) | (1 << 14)) | (512 << 2))) {
            goto switch_16_exp_4;
          } else {
            if (irpSp->Parameters.DeviceIoControl.IoControlCode == (((45 << 16) | (1 << 14)) | (512 << 2))) {
              goto switch_16_exp_5;
            } else {
              if (irpSp->Parameters.DeviceIoControl.IoControlCode == 7 << 16) {
                goto switch_16_exp_6;
              } else {
                if (irpSp->Parameters.DeviceIoControl.IoControlCode == ((7 << 16) | (9 << 2))) {
                  goto switch_16_exp_7;
                } else {
                  if (irpSp->Parameters.DeviceIoControl.IoControlCode == ((7 << 16) | (768 << 2))) {
                    goto switch_16_exp_8;
                  } else {
                    if (irpSp->Parameters.DeviceIoControl.IoControlCode == ((45 << 16) | (768 << 2))) {
                      goto switch_16_exp_9;
                    } else {
                      if (irpSp->Parameters.DeviceIoControl.IoControlCode == ((77UL << 16) | (unsigned long )(3 << 2))) {
                        goto switch_16_exp_10;
                      } else {
                        if (irpSp->Parameters.DeviceIoControl.IoControlCode == ((7 << 16) | (248 << 2))) {
                          goto switch_16_exp_11;
                        } else {
                          {
                          goto switch_16_default;
                          if (0) {
                            switch_16_exp_0: /* CIL Label */ ;
                            {
                            }
                            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )sizeof(MOUNTDEV_NAME )) {
                              ntStatus = -1073741811L;
                              goto switch_16_break;
                            } else {

                            }
                            mountName = Irp->AssociatedIrp.SystemBuffer;
                            mountName->NameLength = disketteExtension->DeviceName.Length;
                            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )(sizeof(USHORT ) + (unsigned int )mountName->NameLength)) {
                              ntStatus = -2147483643L;
                              Irp->IoStatus.Information = sizeof(MOUNTDEV_NAME );
                              goto switch_16_break;
                            } else {

                            }
                            {
                            memcpy(mountName->Name, disketteExtension->DeviceName.Buffer,
                                   mountName->NameLength);
                            ntStatus = 0L;
                            Irp->IoStatus.Information = sizeof(USHORT ) + (unsigned int )mountName->NameLength;
                            }
                            goto switch_16_break;
                            switch_16_exp_1: /* CIL Label */ ;
                            {
                            }
                            if (! disketteExtension->InterfaceString.Buffer) {
                              ntStatus = -1073741811L;
                              goto switch_16_break;
                            } else {
                              if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )sizeof(MOUNTDEV_UNIQUE_ID )) {
                                ntStatus = -1073741811L;
                                goto switch_16_break;
                              } else {

                              }
                            }
                            uniqueId = Irp->AssociatedIrp.SystemBuffer;
                            uniqueId->UniqueIdLength = disketteExtension->InterfaceString.Length;
                            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )(sizeof(USHORT ) + (unsigned int )uniqueId->UniqueIdLength)) {
                              ntStatus = -2147483643L;
                              Irp->IoStatus.Information = sizeof(MOUNTDEV_UNIQUE_ID );
                              goto switch_16_break;
                            } else {

                            }
                            {
                            memcpy(uniqueId->UniqueId, disketteExtension->InterfaceString.Buffer,
                                   uniqueId->UniqueIdLength);
                            ntStatus = 0L;
                            Irp->IoStatus.Information = sizeof(USHORT ) + (unsigned int )uniqueId->UniqueIdLength;
                            }
                            goto switch_16_break;
                            switch_16_exp_2: /* CIL Label */ ;
                            switch_16_exp_3: /* CIL Label */ ;
                            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < (ULONG )sizeof(FORMAT_PARAMETERS )) {
                              {
                              }
                              ntStatus = -1073741811L;
                              goto switch_16_break;
                            } else {

                            }
                            {
                            tmp___0 = FlCheckFormatParameters(disketteExtension, (struct _FORMAT_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer);
                            }
                            if (tmp___0) {

                            } else {
                              {
                              }
                              ntStatus = -1073741811L;
                              goto switch_16_break;
                            }
                            if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((7 << 16) | (3 << 14)) | (11 << 2))) {
                              if (irpSp->Parameters.DeviceIoControl.InputBufferLength < (ULONG )sizeof(FORMAT_EX_PARAMETERS )) {
                                ntStatus = -1073741811L;
                                goto switch_16_break;
                              } else {

                              }
                              formatExParameters = (struct _FORMAT_EX_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;
                              formatExParametersSize = (unsigned long )((long )(& ((FORMAT_EX_PARAMETERS *)0)->SectorNumber)) + (unsigned long )((unsigned int )formatExParameters->SectorsPerTrack * sizeof(USHORT ));
                              if (irpSp->Parameters.DeviceIoControl.InputBufferLength < formatExParametersSize) {
                                ntStatus = -1073741811L;
                                goto switch_16_break;
                              } else {
                                if ((int )formatExParameters->FormatGapLength >= 256) {
                                  ntStatus = -1073741811L;
                                  goto switch_16_break;
                                } else {
                                  if ((int )formatExParameters->SectorsPerTrack >= 256) {
                                    ntStatus = -1073741811L;
                                    goto switch_16_break;
                                  } else {

                                  }
                                }
                              }
                            } else {

                            }
                            switch_16_exp_4: /* CIL Label */ ;
                            switch_16_exp_5: /* CIL Label */ ;
                            switch_16_exp_6: /* CIL Label */ ;
                            switch_16_exp_7: /* CIL Label */ ;
                            {
                            }
                            {
                            ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
                            }
                            goto switch_16_break;
                            switch_16_exp_8: /* CIL Label */ ;
                            switch_16_exp_9: /* CIL Label */ ;
                            {
                            }
                            lowestDriveMediaType = (DriveMediaLimits + disketteExtension->DriveType)->LowestDriveMediaType;
                            highestDriveMediaType = (DriveMediaLimits + disketteExtension->DriveType)->HighestDriveMediaType;
                            outputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
                            if (outputBufferLength < (ULONG )sizeof(DISK_GEOMETRY )) {
                              {
                              }
                              ntStatus = -1073741789L;
                              goto switch_16_break;
                            } else {

                            }
                            ntStatus = 0L;
                            if (outputBufferLength < (ULONG )(sizeof(DISK_GEOMETRY ) * (unsigned int )(((int )highestDriveMediaType - (int )lowestDriveMediaType) + 1))) {
                              {
                              }
                              ntStatus = -2147483643L;
                              highestDriveMediaType = (enum _DRIVE_MEDIA_TYPE )((ULONG )((int )lowestDriveMediaType - 1) + outputBufferLength / (ULONG )sizeof(DISK_GEOMETRY ));
                            } else {

                            }
                            outputBuffer = (struct _DISK_GEOMETRY *)Irp->AssociatedIrp.SystemBuffer;
                            i = (unsigned char )lowestDriveMediaType;
                            {
                            while (1) {
                              while_25_continue: /* CIL Label */ ;
                              if ((int )i <= (int )((unsigned char )highestDriveMediaType)) {

                              } else {
                                goto while_25_break;
                              }
                              outputBuffer->MediaType = (DriveMediaConstants + i)->MediaType;
                              outputBuffer->Cylinders.__annonCompField1.LowPart = (int )(DriveMediaConstants + i)->MaximumTrack + 1;
                              outputBuffer->Cylinders.__annonCompField1.HighPart = 0;
                              outputBuffer->TracksPerCylinder = (DriveMediaConstants + i)->NumberOfHeads;
                              outputBuffer->SectorsPerTrack = (DriveMediaConstants + i)->SectorsPerTrack;
                              outputBuffer->BytesPerSector = (DriveMediaConstants + i)->BytesPerSector;
                              {
                              }
                              outputBuffer += 1;
                              Irp->IoStatus.Information += (ULONG_PTR )sizeof(DISK_GEOMETRY );
                              i = (UCHAR )((int )i + 1);
                            }
                            while_25_break: /* CIL Label */ ;
                            }
                            goto switch_16_break;
                            switch_16_exp_10: /* CIL Label */ ;
                            if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                              {
                              }
                              if (! (DeviceObject->Characteristics & 1UL)) {
                                ntStatus = -1073741275L;
                                goto switch_16_break;
                              } else {

                              }
                              if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )sizeof(MOUNTDEV_SUGGESTED_LINK_NAME )) {
                                ntStatus = -1073741811L;
                                goto switch_16_break;
                              } else {

                              }
                              {
                              tmp___1 = ExAllocatePoolWithTag(1, sizeof(WCHAR ) * 64U,
                                                              1886350406UL);
                              valueName = tmp___1;
                              }
                              if (! valueName) {
                                ntStatus = -1073741670L;
                                goto switch_16_break;
                              } else {

                              }
                              {
                              memset(valueName, 0, sizeof(WCHAR ) * 64U);
                              memcpy(valueName, disketteExtension->DeviceName.Buffer,
                                     disketteExtension->DeviceName.Length);
                              driveLetterName.Buffer = driveLetterNameBuffer;
                              driveLetterName.MaximumLength = 20;
                              driveLetterName.Length = 0;
                              memset(queryTable, 0, 2U * sizeof(RTL_QUERY_REGISTRY_TABLE ));
                              queryTable[0].Flags = 36;
                              queryTable[0].Name = valueName;
                              queryTable[0].EntryContext = & driveLetterName;
                              ntStatus = RtlQueryRegistryValues(0, "\\\000R\000e\000g\000i\000s\000t\000r\000y\000\\\000M\000a\000c\000h\000i\000n\000e\000\\\000S\000y\000s\000t\000e\000m\000\\\000D\000I\000S\000K\000",
                                                                queryTable, (void *)0,
                                                                (void *)0);
                              }
                              if (! (ntStatus >= 0L)) {
                                {
/*                                 ExFreePool(valueName); */ /* INLINED */
                                }
                                goto switch_16_break;
                              } else {

                              }
                              if ((int )driveLetterName.Length != 4) {
                                {
                                ntStatus = -1073741275L;
/*                                 ExFreePool(valueName); */ /* INLINED */
                                }
                                goto switch_16_break;
                              } else {
                                if ((int )*(driveLetterName.Buffer + 0) < 65) {
                                  {
                                  ntStatus = -1073741275L;
/*                                   ExFreePool(valueName); */ /* INLINED */
                                  }
                                  goto switch_16_break;
                                } else {
                                  if ((int )*(driveLetterName.Buffer + 0) > 90) {
                                    {
                                    ntStatus = -1073741275L;
/*                                     ExFreePool(valueName); */ /* INLINED */
                                    }
                                    goto switch_16_break;
                                  } else {
                                    if ((int )*(driveLetterName.Buffer + 1) != 58) {
                                      {
                                      ntStatus = -1073741275L;
/*                                       ExFreePool(valueName); */ /* INLINED */
                                      }
                                      goto switch_16_break;
                                    } else {

                                    }
                                  }
                                }
                              }
                              suggestedName = Irp->AssociatedIrp.SystemBuffer;
                              suggestedName->UseOnlyIfThereAreNoOtherLinks = 1;
                              suggestedName->NameLength = 28;
                              Irp->IoStatus.Information = (long )(& ((MOUNTDEV_SUGGESTED_LINK_NAME *)0)->Name) + 28L;
                              if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < Irp->IoStatus.Information) {
                                {
                                Irp->IoStatus.Information = sizeof(MOUNTDEV_SUGGESTED_LINK_NAME );
                                ntStatus = -2147483643L;
/*                                 ExFreePool(valueName); */ /* INLINED */
                                }
                                goto switch_16_break;
                              } else {

                              }
                              {
                              RtlDeleteRegistryValue(0, "\\\000R\000e\000g\000i\000s\000t\000r\000y\000\\\000M\000a\000c\000h\000i\000n\000e\000\\\000S\000y\000s\000t\000e\000m\000\\\000D\000I\000S\000K\000",
                                                     valueName);
/*                               ExFreePool(valueName); */ /* INLINED */
                              memcpy(suggestedName->Name, "\\\000D\000o\000s\000D\000e\000v\000i\000c\000e\000s\000\\\000",
                                     24);
                              suggestedName->Name[12] = *(driveLetterName.Buffer + 0);
                              suggestedName->Name[13] = ':';
                              }
                              goto switch_16_break;
                            } else {

                            }
                            switch_16_exp_11: /* CIL Label */ ;
                            if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                              {
                              }
                              if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )sizeof(SENSE_DEVISE_STATUS_PTOS )) {
                                {
                                }
                                ntStatus = -1073741811L;
                                goto switch_16_break;
                              } else {

                              }
                              {
                              }
                              {
                              ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
                              }
                              goto switch_16_break;
                            } else {

                            }
                            switch_16_default: /* CIL Label */ ;
                            if (s == NP) {
                              s = SKIP1;
                            } else {
                              {
                              errorFn();
                              }
                            }
                            {
                            Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
                            Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
                            ntStatus = IofCallDriver(disketteExtension->TargetObject,
                                                     Irp);
                            }
                            return (ntStatus);
                          } else {
                            switch_16_break: /* CIL Label */ ;
                          }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (ntStatus != 259L) {
    Irp->IoStatus.__annonCompField4.Status = ntStatus;
    myStatus = ntStatus;
    if (! (ntStatus >= 0L)) {
      if (ntStatus == -1073741661L) {
        tmp___2 = 1;
      } else {
        if (ntStatus == -1073741643L) {
          tmp___2 = 1;
        } else {
          if (ntStatus == -1073741662L) {
            tmp___2 = 1;
          } else {
            if (ntStatus == -1073741805L) {
              tmp___2 = 1;
            } else {
              if (ntStatus == -2147483626L) {
                tmp___2 = 1;
              } else {
                if (ntStatus == -1073741804L) {
                  tmp___2 = 1;
                } else {
                  if (ntStatus == -1073741806L) {
                    tmp___2 = 1;
                  } else {
                    tmp___2 = 0;
                  }
                }
              }
            }
          }
        }
      }
      if ((unsigned char )tmp___2) {
        {
/*         IoSetHardErrorOrVerifyDevice(Irp, DeviceObject); */ /* INLINED */
        }
      } else {

      }
    } else {

    }
    {
    IofCompleteRequest(Irp, 0);
    }
  } else {

  }
  return (ntStatus);
}
}
NTSTATUS FloppyPnp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION irpSp ;
  PDISKETTE_EXTENSION disketteExtension ;
  NTSTATUS ntStatus ;
  KEVENT doneEvent ;
  PIO_STACK_LOCATION irpSp___0 ;
  PIO_STACK_LOCATION nextIrpSp ;
  PIO_STACK_LOCATION irpSp___1 ;
  PCONFIGURATION_INFORMATION tmp ;

  {
  ntStatus = 0L;
  {
  }
  {
/*   ExAcquireFastMutex(PagingMutex); */ /* INLINED */
  PagingReferenceCount += 1UL;
  }
  if (PagingReferenceCount == 1UL) {
    {
/*     MmResetDriverPaging(& DriverEntry); */ /* INLINED */
    }
  } else {

  }
  {
/*   ExReleaseFastMutex(PagingMutex); */ /* INLINED */
  disketteExtension = DeviceObject->DeviceExtension;
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
  }
  if (disketteExtension->IsRemoved) {
    {
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.__annonCompField4.Status = -1073741738L;
    myStatus = -1073741738L;
    IofCompleteRequest(Irp, 0);
    }
    return (-1073741738L);
  } else {

  }
  if (irpSp->MinorFunction == 0) {
    goto switch_32_0;
  } else {
    if (irpSp->MinorFunction == 5) {
      goto switch_32_5;
    } else {
      if (irpSp->MinorFunction == 1) {
        goto switch_32_1;
      } else {
        if (irpSp->MinorFunction == 6) {
          goto switch_32_6;
        } else {
          if (irpSp->MinorFunction == 3) {
            goto switch_32_3;
          } else {
            if (irpSp->MinorFunction == 4) {
              goto switch_32_4;
            } else {
              if (irpSp->MinorFunction == 2) {
                goto switch_32_2;
              } else {
                {
                goto switch_32_default;
                if (0) {
                  switch_32_0: /* CIL Label */ 
                  {
                  ntStatus = FloppyStartDevice(DeviceObject, Irp);
                  }
                  goto switch_32_break;
                  switch_32_5: /* CIL Label */ ;
                  switch_32_1: /* CIL Label */ ;
                  if ((int )irpSp->MinorFunction == 5) {
                    {
                    }
                  } else {
                    {
                    }
                  }
                  if (! disketteExtension->IsStarted) {
                    if (s == NP) {
                      s = SKIP1;
                    } else {
                      {
                      errorFn();
                      }
                    }
                    {
                    Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
                    Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
                    ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                    }
                    return (ntStatus);
                  } else {

                  }
                  {
/*                   ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
                  disketteExtension->HoldNewRequests = 1;
/*                   ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
                  ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
                  }
                  if (ntStatus == 259L) {
                    {
                    KeWaitForSingleObject(disketteExtension->FloppyThread, 0, 0, 0,
                                          (void *)0);
                    }
                    if ((unsigned int )disketteExtension->FloppyThread != (unsigned int )((void *)0)) {
                      {
/*                       ObfDereferenceObject(disketteExtension->FloppyThread); */ /* INLINED */
                      }
                    } else {

                    }
                    disketteExtension->FloppyThread = (void *)0;
                    Irp->IoStatus.__annonCompField4.Status = 0L;
                    myStatus = 0L;
                    if (s == NP) {
                      s = SKIP1;
                    } else {
                      {
                      errorFn();
                      }
                    }
                    {
                    Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
                    Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
                    ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                    }
                  } else {
                    {
                    ntStatus = -1073741823L;
                    Irp->IoStatus.__annonCompField4.Status = ntStatus;
                    myStatus = ntStatus;
                    Irp->IoStatus.Information = 0;
                    IofCompleteRequest(Irp, 0);
                    }
                  }
                  goto switch_32_break;
                  switch_32_6: /* CIL Label */ ;
                  switch_32_3: /* CIL Label */ ;
                  if ((int )irpSp->MinorFunction == 6) {
                    {
                    }
                  } else {
                    {
                    }
                  }
                  if (! disketteExtension->IsStarted) {
                    Irp->IoStatus.__annonCompField4.Status = 0L;
                    myStatus = 0L;
                    if (s == NP) {
                      s = SKIP1;
                    } else {
                      {
                      errorFn();
                      }
                    }
                    {
                    Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
                    Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
                    ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                    }
                  } else {
                    {
                    Irp->IoStatus.__annonCompField4.Status = 0L;
                    myStatus = 0L;
                    irpSp___0 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
                    nextIrpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
                    memcpy(nextIrpSp, irpSp___0, (long )(& ((IO_STACK_LOCATION *)0)->CompletionRoutine));
                    nextIrpSp->Control = 0;
/*                     KeInitializeEvent(& doneEvent, 1, 0); */ /* INLINED */
                    }
                    if (s != NP) {
                      {
                      errorFn();
                      }
                    } else {
                      if (compRegistered != 0) {
                        {
                        errorFn();
                        }
                      } else {
                        compRegistered = 1;
                        compFptr = & FloppyPnpComplete;
                      }
                    }
                    {
                    irpSp___1 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
                    irpSp___1->CompletionRoutine = & FloppyPnpComplete;
                    irpSp___1->Context = & doneEvent;
                    irpSp___1->Control = 0;
                    irpSp___1->Control = 64;
                    irpSp___1->Control = (int )irpSp___1->Control | 128;
                    irpSp___1->Control = (int )irpSp___1->Control | 32;
                    ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                    }
                    if (ntStatus == 259L) {
                      {
                      KeWaitForSingleObject(& doneEvent, 0, 0, 0, (void *)0);
                      ntStatus = myStatus;
                      }
                    } else {

                    }
                    {
/*                     ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
                    disketteExtension->HoldNewRequests = 0;
/*                     ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
                    FloppyProcessQueuedRequests(disketteExtension);
                    Irp->IoStatus.__annonCompField4.Status = ntStatus;
                    myStatus = ntStatus;
                    Irp->IoStatus.Information = 0;
                    IofCompleteRequest(Irp, 0);
                    }
                  }
                  goto switch_32_break;
                  switch_32_4: /* CIL Label */ ;
                  {
                  }
                  disketteExtension->IsStarted = 0;
                  Irp->IoStatus.__annonCompField4.Status = 0L;
                  myStatus = 0L;
                  if (s == NP) {
                    s = SKIP1;
                  } else {
                    {
                    errorFn();
                    }
                  }
                  {
                  Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
                  Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
                  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                  }
                  goto switch_32_break;
                  switch_32_2: /* CIL Label */ ;
                  {
                  }
                  {
/*                   ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
                  disketteExtension->HoldNewRequests = 0;
/*                   ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
                  disketteExtension->IsStarted = 0;
                  disketteExtension->IsRemoved = 1;
                  FloppyProcessQueuedRequests(disketteExtension);
                  }
                  if (s == NP) {
                    s = SKIP1;
                  } else {
                    {
                    errorFn();
                    }
                  }
                  {
                  Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
                  Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
                  Irp->IoStatus.__annonCompField4.Status = 0L;
                  myStatus = 0L;
                  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                  }
                  if ((unsigned int )disketteExtension->InterfaceString.Buffer != (unsigned int )((void *)0)) {
                    {
                    IoSetDeviceInterfaceState(& disketteExtension->InterfaceString,
                                              0);
/*                     RtlFreeUnicodeString(& disketteExtension->InterfaceString); */ /* INLINED */
/*                     RtlInitUnicodeString(& disketteExtension->InterfaceString, (void *)0); */ /* INLINED */
                    }
                  } else {

                  }
                  {
/*                   RtlFreeUnicodeString(& disketteExtension->DeviceName); */ /* INLINED */
/*                   RtlInitUnicodeString(& disketteExtension->DeviceName, (void *)0); */ /* INLINED */
                  }
                  if ((int )disketteExtension->ArcName.Length != 0) {
                    {
                    IoDeleteSymbolicLink(& disketteExtension->ArcName);
/*                     RtlFreeUnicodeString(& disketteExtension->ArcName); */ /* INLINED */
/*                     RtlInitUnicodeString(& disketteExtension->ArcName, (void *)0); */ /* INLINED */
                    }
                  } else {

                  }
                  {
/*                   IoDetachDevice(disketteExtension->TargetObject); */ /* INLINED */
/*                   IoDeleteDevice(DeviceObject); */ /* INLINED */
                  tmp = IoGetConfigurationInformation();
                  tmp->FloppyCount -= 1UL;
                  }
                  goto switch_32_break;
                  switch_32_default: /* CIL Label */ ;
                  {
                  }
                  if (s == NP) {
                    s = SKIP1;
                  } else {
                    {
                    errorFn();
                    }
                  }
                  {
                  Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
                  Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
                  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                  }
                } else {
                  switch_32_break: /* CIL Label */ ;
                }
                }
              }
            }
          }
        }
      }
    }
  }
  {
/*   ExAcquireFastMutex(PagingMutex); */ /* INLINED */
  PagingReferenceCount -= 1UL;
  }
  if (PagingReferenceCount == 0UL) {
    {
/* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
    }
  } else {

  }
  {
/*   ExReleaseFastMutex(PagingMutex); */ /* INLINED */
  }
  return (ntStatus);
}
}
NTSTATUS FloppyStartDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ NTSTATUS ntStatus ;
  NTSTATUS pnpStatus ;
  KEVENT doneEvent ;
  FDC_INFO fdcInfo ;
  CONFIGURATION_TYPE Dc ;
  CONFIGURATION_TYPE Fp ;
  PDISKETTE_EXTENSION disketteExtension ;
  PIO_STACK_LOCATION irpSp ;
  PIO_STACK_LOCATION irpSp___0 ;
  PIO_STACK_LOCATION nextIrpSp ;
  PIO_STACK_LOCATION irpSp___1 ;
  INTERFACE_TYPE InterfaceType ;

  {
  Dc = 13;
  Fp = 26;
  disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
  {
  }
  {
  }
  {
  }
  {
/*   KeInitializeEvent(& doneEvent, 0, 0); */ /* INLINED */
  irpSp___0 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
  nextIrpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
  memcpy(nextIrpSp, irpSp___0, (long )(& ((IO_STACK_LOCATION *)0)->CompletionRoutine));
  nextIrpSp->Control = 0;
  }
  if (s != NP) {
    {
    errorFn();
    }
  } else {
    if (compRegistered != 0) {
      {
      errorFn();
      }
    } else {
      compRegistered = 1;
      compFptr = & FloppyPnpComplete;
    }
  }
  {
  irpSp___1 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
  irpSp___1->CompletionRoutine = & FloppyPnpComplete;
  irpSp___1->Context = & doneEvent;
  irpSp___1->Control = 0;
  irpSp___1->Control = 64;
  irpSp___1->Control = (int )irpSp___1->Control | 128;
  irpSp___1->Control = (int )irpSp___1->Control | 32;
  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
  }
  if (ntStatus == 259L) {
    {
    ntStatus = KeWaitForSingleObject(& doneEvent, 0, 0, 0, (void *)0);
    ntStatus = myStatus;
    }
  } else {

  }
  {
  fdcInfo.BufferCount = 0;
  fdcInfo.BufferSize = 0;
  ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject, ((7 << 16) | (770 << 2)) | 3,
                           & fdcInfo);
  }
  if (ntStatus >= 0L) {
    disketteExtension->MaxTransferSize = fdcInfo.MaxTransferSize;
    if (fdcInfo.AcpiBios) {
      if (fdcInfo.AcpiFdiSupported) {
        {
        ntStatus = FlAcpiConfigureFloppy(disketteExtension, & fdcInfo);
        }
        if ((int )disketteExtension->DriveType == 4) {
          disketteExtension->PerpendicularMode = (int )disketteExtension->PerpendicularMode | (1 << fdcInfo.PeripheralNumber);
        } else {

        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if ((int )disketteExtension->DriveType == 4) {
        disketteExtension->PerpendicularMode = (int )disketteExtension->PerpendicularMode | (1 << fdcInfo.PeripheralNumber);
      } else {

      }
      InterfaceType = 0;
      {
      while (1) {
        while_43_continue: /* CIL Label */ ;
        if ((int )InterfaceType < 16) {

        } else {
          goto while_43_break;
        }
        {
        fdcInfo.BusType = InterfaceType;
        ntStatus = IoQueryDeviceDescription(& fdcInfo.BusType, & fdcInfo.BusNumber,
                                            & Dc, & fdcInfo.ControllerNumber, & Fp,
                                            & fdcInfo.PeripheralNumber, & FlConfigCallBack,
                                            disketteExtension);
        }
        if (ntStatus >= 0L) {
          {
          }
          goto while_43_break;
        } else {

        }
        InterfaceType = (INTERFACE_TYPE )((int )InterfaceType + 1);
      }
      while_43_break: /* CIL Label */ ;
      }
    }
    if (ntStatus >= 0L) {
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
        disketteExtension->DeviceUnit = (unsigned char )fdcInfo.UnitNumber;
        disketteExtension->DriveOnValue = (unsigned char )fdcInfo.UnitNumber;
      } else {
        disketteExtension->DeviceUnit = (unsigned char )fdcInfo.PeripheralNumber;
        disketteExtension->DriveOnValue = (unsigned char )(fdcInfo.PeripheralNumber | (unsigned long )(16 << fdcInfo.PeripheralNumber));
      }
      {
      pnpStatus = IoRegisterDeviceInterface(disketteExtension->UnderlyingPDO, (GUID *)(& MOUNTDEV_MOUNTED_DEVICE_GUID),
                                            (void *)0, & disketteExtension->InterfaceString);
      }
      if (pnpStatus >= 0L) {
        {
        pnpStatus = IoSetDeviceInterfaceState(& disketteExtension->InterfaceString,
                                              1);
        }
      } else {

      }
      {
      disketteExtension->IsStarted = 1;
/*       ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
      disketteExtension->HoldNewRequests = 0;
/*       ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
      FloppyProcessQueuedRequests(disketteExtension);
      }
    } else {

    }
  } else {

  }
  {
  Irp->IoStatus.__annonCompField4.Status = ntStatus;
  myStatus = ntStatus;
  IofCompleteRequest(Irp, 0);
  }
  return (ntStatus);
}
}
NTSTATUS FloppyPnpComplete(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) 
{ 

  {
  {
  KeSetEvent((struct _KEVENT *)Context, 1, 0);
  }
  return (-1073741802L);
}
}
NTSTATUS FloppyPower(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDISKETTE_EXTENSION disketteExtension ;
  NTSTATUS ntStatus ;
  PIO_STACK_LOCATION irpSp ;
  POWER_STATE_TYPE type ;
  POWER_STATE state ;
  BOOLEAN WaitForCompletion ;

  {
  ntStatus = myStatus;
  WaitForCompletion = 1;
  {
  }
  disketteExtension = DeviceObject->DeviceExtension;
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
  type = irpSp->Parameters.Power.Type;
  state = irpSp->Parameters.Power.State;
  if (irpSp->MinorFunction == 3) {
    goto switch_46_3;
  } else {
    if (irpSp->MinorFunction == 2) {
      goto switch_46_2;
    } else {
      {
      goto switch_46_default;
      if (0) {
        switch_46_3: /* CIL Label */ ;
        {
        }
        if ((int )type == 0) {
          if ((int )state.SystemState > 5) {
            ntStatus = 0L;
            goto switch_46_break;
          } else {

          }
        } else {

        }
        {
/*         ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
        }
        if (disketteExtension->ThreadReferenceCount >= 0L) {
          {
/*           ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
          }
          {
          }
          {
/*           PoStartNextPowerIrp(Irp); */ /* INLINED */
          Irp->IoStatus.Information = 0;
          Irp->IoStatus.__annonCompField4.Status = -2147483631L;
          myStatus = -2147483631L;
          IofCompleteRequest(Irp, 0);
          }
          return (-2147483631L);
        } else {

        }
        {
/*         ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
        ntStatus = 0L;
        }
        goto switch_46_break;
        switch_46_2: /* CIL Label */ ;
        if ((int )type == 0) {
          {
/*           ExAcquireFastMutex(& disketteExtension->PowerDownMutex); */ /* INLINED */
          }
          if ((int )state.SystemState == 1) {
            {
            }
            disketteExtension->PoweringDown = 0;
            WaitForCompletion = 0;
          } else {
            {
            }
            WaitForCompletion = 1;
            disketteExtension->PoweringDown = 1;
          }
          {
/*           ExReleaseFastMutex(& disketteExtension->PowerDownMutex); */ /* INLINED */
          }
          if ((unsigned int )disketteExtension->FloppyThread != (unsigned int )((void *)0)) {
            if ((int )WaitForCompletion == 1) {
              {
              KeWaitForSingleObject(disketteExtension->FloppyThread, 0, 0, 0, (void *)0);
              }
            } else {

            }
          } else {

          }
        } else {

        }
        {
        }
        ntStatus = 0L;
        goto switch_46_break;
        switch_46_default: /* CIL Label */ ;
        goto switch_46_break;
      } else {
        switch_46_break: /* CIL Label */ ;
      }
      }
    }
  }
  {
/*   PoStartNextPowerIrp(Irp); */ /* INLINED */
  }
  if (s == NP) {
    s = SKIP1;
  } else {
    {
    errorFn();
    }
  }
  {
  Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
  Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
  ntStatus = PoCallDriver(disketteExtension->TargetObject, Irp);
  }
  return (ntStatus);
}
}
NTSTATUS FloppyReadWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION irpSp ;
  NTSTATUS ntStatus ;
  PDISKETTE_EXTENSION disketteExtension ;

  {
  {
  }
  {
  disketteExtension = DeviceObject->DeviceExtension;
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
/*   ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
  }
  if (disketteExtension->HoldNewRequests) {
    {
    ntStatus = FloppyQueueRequest(disketteExtension, Irp);
/*     ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
    }
    return (ntStatus);
  } else {

  }
  {
/*   ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex); */ /* INLINED */
  }
  if (disketteExtension->IsRemoved) {
    goto _L;
  } else {
    if (! disketteExtension->IsStarted) {
      _L: /* CIL Label */ 
      if (disketteExtension->IsRemoved) {
        ntStatus = -1073741738L;
      } else {
        ntStatus = -1073741823L;
      }
      {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.__annonCompField4.Status = ntStatus;
      myStatus = ntStatus;
      IofCompleteRequest(Irp, 0);
      }
      return (ntStatus);
    } else {

    }
  }
  if ((int )disketteExtension->MediaType > 0) {
    if (irpSp->Parameters.Read.ByteOffset.__annonCompField1.LowPart + irpSp->Parameters.Read.Length > disketteExtension->ByteCapacity) {
      goto _L___1;
    } else {
      if ((irpSp->Parameters.Read.Length & (disketteExtension->BytesPerSector - 1UL)) != 0UL) {
        _L___1: /* CIL Label */ 
        {
        }
        {
        }
        ntStatus = -1073741811L;
      } else {
        goto _L___0;
      }
    }
  } else {
    _L___0: /* CIL Label */ 
    if (irpSp->Parameters.Read.Length) {
      {
      }
      {
      ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
      }
    } else {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.__annonCompField4.Status = 0L;
      myStatus = 0L;
      {
      }
      {
      IofCompleteRequest(Irp, 0);
      }
      return (0L);
    }
  }
  if (ntStatus != 259L) {
    Irp->IoStatus.__annonCompField4.Status = ntStatus;
    myStatus = ntStatus;
    {
    }
    {
    IofCompleteRequest(Irp, 0);
    }
  } else {

  }
  return (ntStatus);
}
}
NTSTATUS FlInterpretError(UCHAR StatusRegister1 , UCHAR StatusRegister2 ) 
{ 

  {
  if ((int )StatusRegister1 & 32) {
    goto _L;
  } else {
    if ((int )StatusRegister2 & 32) {
      _L: /* CIL Label */ 
      {
      }
      return (-1073741761L);
    } else {

    }
  }
  if ((int )StatusRegister1 & 16) {
    {
    }
    return (-1073741764L);
  } else {

  }
  if ((int )StatusRegister1 & 4) {
    goto _L___0;
  } else {
    if ((int )StatusRegister1 & 128) {
      _L___0: /* CIL Label */ 
      {
      }
      return (-1073741803L);
    } else {

    }
  }
  if ((int )StatusRegister2 & 1) {
    goto _L___1;
  } else {
    if ((int )StatusRegister2 & 2) {
      goto _L___1;
    } else {
      if ((int )StatusRegister2 & 64) {
        _L___1: /* CIL Label */ 
        {
        }
        return (-1073741668L);
      } else {

      }
    }
  }
  if ((int )StatusRegister1 & 2) {
    {
    }
    return (-1073741662L);
  } else {

  }
  if ((int )StatusRegister1 & 1) {
    {
    }
    return (-1073741467L);
  } else {

  }
  if ((int )StatusRegister2 & 16) {
    {
    }
    return (-1073741466L);
  } else {

  }
  {
  }
  return (-1073741465L);
}
}
void FlFinishOperation(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;
  int tmp ;

  {
  {
  }
  if (myStatus != 0L) {
    if (DisketteExtension->HardwareFailed) {
      DisketteExtension->HardwareFailCount = (UCHAR )((int )DisketteExtension->HardwareFailCount + 1);
      if ((int )DisketteExtension->HardwareFailCount < 2) {
        {
        ntStatus = FlInitializeControllerHardware(DisketteExtension);
        }
        if (ntStatus >= 0L) {
          {
          }
          DisketteExtension->MediaType = -1;
          {
          }
          {
/*           ExAcquireFastMutex(& DisketteExtension->ThreadReferenceMutex); */ /* INLINED */
          DisketteExtension->ThreadReferenceCount += 1L;
/*           ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex); */ /* INLINED */
          ExfInterlockedInsertHeadList(& DisketteExtension->ListEntry, & Irp->Tail.Overlay.__annonCompField17.ListEntry,
                                       & DisketteExtension->ListSpinLock);
          }
          return;
        } else {

        }
        {
        }
      } else {

      }
    } else {

    }
  } else {

  }
  DisketteExtension->HardwareFailCount = 0;
  if (! (myStatus >= 0L)) {
    if (myStatus == -1073741661L) {
      tmp = 1;
    } else {
      if (myStatus == -1073741643L) {
        tmp = 1;
      } else {
        if (myStatus == -1073741662L) {
          tmp = 1;
        } else {
          if (myStatus == -1073741805L) {
            tmp = 1;
          } else {
            if (myStatus == -2147483626L) {
              tmp = 1;
            } else {
              if (myStatus == -1073741804L) {
                tmp = 1;
              } else {
                if (myStatus == -1073741806L) {
                  tmp = 1;
                } else {
                  tmp = 0;
                }
              }
            }
          }
        }
      }
    }
    if ((unsigned char )tmp) {
      {
/*       IoSetHardErrorOrVerifyDevice(Irp, DisketteExtension->DeviceObject); */ /* INLINED */
      }
    } else {

    }
  } else {

  }
  if (myStatus != 0L) {
    if (myStatus != -2147483626L) {
      if (myStatus != -1073741805L) {
        {
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
    }
  }
  {
  }
  {
  }
  {
  IofCompleteRequest(Irp, 1);
  }
  return;
}
}
NTSTATUS FlStartDrive(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN WriteOperation ,
                      BOOLEAN SetUpMedia , BOOLEAN IgnoreChange ) 
{ LARGE_INTEGER delay ;
  BOOLEAN motorStarted ;
  UCHAR driveStatus ;
  NTSTATUS ntStatus ;
  FDC_ENABLE_PARMS fdcEnableParms ;
  FDC_DISK_CHANGE_PARMS fdcDiskChangeParms ;

  {
  ntStatus = 0L;
  {
  }
  *(DriveMediaConstants + (DriveMediaLimits + DisketteExtension->DriveType)->HighestDriveMediaType) = DisketteExtension->BiosDriveMediaConstants;
  if ((int )DisketteExtension->MediaType == -1) {
    DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + 0);
  } else {
    if ((int )DisketteExtension->MediaType == 0) {
      DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + 0);
    } else {

    }
  }
  fdcEnableParms.DriveOnValue = DisketteExtension->DriveOnValue;
  if (WriteOperation) {
    fdcEnableParms.TimeToWait = DisketteExtension->DriveMediaConstants.MotorSettleTimeWrite;
  } else {
    fdcEnableParms.TimeToWait = DisketteExtension->DriveMediaConstants.MotorSettleTimeRead;
  }
  {
  ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, ((7 << 16) | (774 << 2)) | 3,
                           & fdcEnableParms);
  motorStarted = fdcEnableParms.MotorStarted;
  }
  if (ntStatus >= 0L) {
    {
    fdcDiskChangeParms.DriveOnValue = DisketteExtension->DriveOnValue;
    ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, ((7 << 16) | (776 << 2)) | 3,
                             & fdcDiskChangeParms);
    driveStatus = fdcDiskChangeParms.DriveStatus;
    }
  } else {

  }
  if (! (ntStatus >= 0L)) {
    return (ntStatus);
  } else {

  }
  if ((int )DisketteExtension->DriveType == 0) {
    if (motorStarted) {
      goto _L___1;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    if ((int )DisketteExtension->DriveType != 0) {
      if ((int )driveStatus & 128) {
        _L___1: /* CIL Label */ 
        {
        }
        DisketteExtension->MediaType = -1;
        if ((int )((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
          if (Irp) {
            {
/*             IoSetHardErrorOrVerifyDevice(Irp, DisketteExtension->DeviceObject); */ /* INLINED */
            }
          } else {

          }
          (DisketteExtension->DeviceObject)->Flags |= 2UL;
        } else {

        }
        if ((int )DisketteExtension->DriveType != 0) {
          if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
            {
            DisketteExtension->FifoBuffer[0] = 14;
            DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
            ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                      DisketteExtension->FifoBuffer, (void *)0, 0,
                                      0);
            }
            if (! (ntStatus >= 0L)) {
              {
              }
              return (ntStatus);
            } else {

            }
            if ((int )DisketteExtension->FifoBuffer[0] & 32) {
              driveStatus = 127;
            } else {
              driveStatus = 128;
            }
            if ((int )driveStatus & 128) {
              {
              }
              if ((int )((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
                (DisketteExtension->DeviceObject)->Flags &= 4294967293UL;
              } else {

              }
              return (-1073741805L);
            } else {

            }
          } else {

          }
          {
          DisketteExtension->FifoBuffer[0] = 16;
          DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
          DisketteExtension->FifoBuffer[2] = 1;
          ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                    DisketteExtension->FifoBuffer, (void *)0, 0, 0);
          }
          if (! (ntStatus >= 0L)) {
            {
            }
            return (ntStatus);
          } else {
            if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
              goto _L;
            } else {
              if ((int )DisketteExtension->FifoBuffer[1] != 1) {
                _L: /* CIL Label */ 
                {
                }
                DisketteExtension->HardwareFailed = 1;
                return (-1073741464L);
              } else {

              }
            }
          }
          {
          DisketteExtension->FifoBuffer[0] = 16;
          DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
          DisketteExtension->FifoBuffer[2] = 0;
          delay.__annonCompField1.LowPart = 4294966396UL;
          delay.__annonCompField1.HighPart = -1;
          KeDelayExecutionThread(0, 0, & delay);
          ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                    DisketteExtension->FifoBuffer, (void *)0, 0, 0);
          delay.__annonCompField1.LowPart = 4294967291UL;
          delay.__annonCompField1.HighPart = -1;
          KeDelayExecutionThread(0, 0, & delay);
          }
          if (! (ntStatus >= 0L)) {
            {
            }
            return (ntStatus);
          } else {
            if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
              goto _L___0;
            } else {
              if ((int )DisketteExtension->FifoBuffer[1] != 0) {
                _L___0: /* CIL Label */ 
                {
                }
                DisketteExtension->HardwareFailed = 1;
                return (-1073741464L);
              } else {

              }
            }
          }
          if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
            {
            DisketteExtension->FifoBuffer[0] = 14;
            DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
            ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                      DisketteExtension->FifoBuffer, (void *)0, 0,
                                      0);
            }
            if (! (ntStatus >= 0L)) {
              {
              }
              return (ntStatus);
            } else {

            }
            if ((int )DisketteExtension->FifoBuffer[0] & 32) {
              driveStatus = 127;
            } else {
              driveStatus = 128;
            }
          } else {
            {
            ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, ((7 << 16) | (776 << 2)) | 3,
                                     & fdcDiskChangeParms);
            driveStatus = fdcDiskChangeParms.DriveStatus;
            }
            if (! (ntStatus >= 0L)) {
              return (ntStatus);
            } else {

            }
          }
          if ((int )driveStatus & 128) {
            {
            }
            if ((int )((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
              (DisketteExtension->DeviceObject)->Flags &= 4294967293UL;
            } else {

            }
            return (-1073741805L);
          } else {

          }
        } else {

        }
        if ((int )IgnoreChange == 0) {
          if ((int )((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
            {
            }
            return (-2147483626L);
          } else {
            return (-1073741435L);
          }
        } else {

        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
        {
        FlHdbit(DisketteExtension);
        }
      } else {

      }
    }
  }
  if (SetUpMedia) {
    if ((int )DisketteExtension->MediaType == -1) {
      {
      ntStatus = FlDetermineMediaType(DisketteExtension);
      }
    } else {
      if ((int )DisketteExtension->MediaType == 0) {
        {
        }
        return (-1073741804L);
      } else {
        if ((int )DisketteExtension->DriveMediaType != (int )DisketteExtension->LastDriveMediaType) {
          {
          ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
          }
          if (! (ntStatus >= 0L)) {
            {
            }
          } else {

          }
        } else {

        }
      }
    }
  } else {

  }
  if (WriteOperation) {
    if (ntStatus >= 0L) {
      {
      DisketteExtension->FifoBuffer[0] = 14;
      DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
      ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                DisketteExtension->FifoBuffer, (void *)0, 0, 0);
      }
      if (! (ntStatus >= 0L)) {
        {
        }
        return (ntStatus);
      } else {

      }
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
        if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
          {
          }
          return (-1073741805L);
        } else {

        }
      } else {

      }
      if ((int )DisketteExtension->FifoBuffer[0] & 64) {
        {
        }
        return (-1073741662L);
      } else {

      }
    } else {

    }
  } else {

  }
  return (ntStatus);
}
}
NTSTATUS FlDatarateSpecifyConfigure(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;

  {
  ntStatus = 0L;
  if (DisketteExtension->ControllerConfigurable) {
    DisketteExtension->FifoBuffer[0] = 17;
    DisketteExtension->FifoBuffer[1] = 0;
    DisketteExtension->FifoBuffer[2] = 15;
    DisketteExtension->FifoBuffer[2] = (int )DisketteExtension->FifoBuffer[2] + 16;
    if (! DisketteExtension->DriveMediaConstants.CylinderShift) {
      DisketteExtension->FifoBuffer[2] = (int )DisketteExtension->FifoBuffer[2] + 64;
    } else {

    }
    {
    DisketteExtension->FifoBuffer[3] = 0;
    ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer, DisketteExtension->FifoBuffer,
                              (void *)0, 0, 0);
    }
    if (ntStatus == -1073741661L) {
      DisketteExtension->ControllerConfigurable = 0;
      ntStatus = 0L;
    } else {

    }
  } else {

  }
  if (ntStatus >= 0L) {
    goto _L;
  } else {
    if (ntStatus == -1073741661L) {
      _L: /* CIL Label */ 
      {
      DisketteExtension->FifoBuffer[0] = 13;
      DisketteExtension->FifoBuffer[1] = DisketteExtension->DriveMediaConstants.StepRateHeadUnloadTime;
      DisketteExtension->FifoBuffer[2] = DisketteExtension->DriveMediaConstants.HeadLoadTime;
      ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                DisketteExtension->FifoBuffer, (void *)0, 0, 0);
      }
      if (ntStatus >= 0L) {
        {
        ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, ((7 << 16) | (777 << 2)) | 3,
                                 & DisketteExtension->DriveMediaConstants.DataTransferRate);
        }
        if (ntStatus >= 0L) {
          {
          ntStatus = FlRecalibrateDrive(DisketteExtension);
          }
        } else {

        }
      } else {
        {
        }
      }
    } else {
      {
      }
    }
  }
  if (ntStatus >= 0L) {
    DisketteExtension->LastDriveMediaType = DisketteExtension->DriveMediaType;
  } else {
    DisketteExtension->LastDriveMediaType = 0;
    {
    }
  }
  return (ntStatus);
}
}
NTSTATUS FlRecalibrateDrive(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;
  UCHAR recalibrateCount ;
  UCHAR fifoBuffer[2] ;

  {
  recalibrateCount = 0;
  {
  while (1) {
    while_93_continue: /* CIL Label */ ;
    {
    DisketteExtension->FifoBuffer[0] = 11;
    DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
    ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer, DisketteExtension->FifoBuffer,
                              (void *)0, 0, 0);
    }
    if (! (ntStatus >= 0L)) {
      {
      }
    } else {

    }
    if (ntStatus >= 0L) {
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
        {
        fifoBuffer[0] = DisketteExtension->FifoBuffer[0];
        fifoBuffer[1] = DisketteExtension->FifoBuffer[1];
        DisketteExtension->FifoBuffer[0] = 14;
        DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
        ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                  DisketteExtension->FifoBuffer, (void *)0, 0, 0);
        }
        if (! (ntStatus >= 0L)) {
          {
          }
          return (ntStatus);
        } else {

        }
        DisketteExtension->FifoBuffer[0] = fifoBuffer[0];
        DisketteExtension->FifoBuffer[1] = fifoBuffer[1];
      } else {

      }
      if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
        goto _L;
      } else {
        if ((int )DisketteExtension->FifoBuffer[1] != 0) {
          _L: /* CIL Label */ 
          {
          }
          DisketteExtension->HardwareFailed = 1;
          ntStatus = -1073741464L;
        } else {

        }
      }
    } else {

    }
    recalibrateCount = (UCHAR )((int )recalibrateCount + 1);
    if (! (ntStatus >= 0L)) {
      if ((int )recalibrateCount < 2) {

      } else {
        goto while_93_break;
      }
    } else {
      goto while_93_break;
    }
  }
  while_93_break: /* CIL Label */ ;
  }
  {
  }
  return (ntStatus);
}
}
NTSTATUS FlDetermineMediaType(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  BOOLEAN mediaTypesExhausted ;
  ULONG retries ;
  USHORT sectorLengthCode ;
  PBOOT_SECTOR_INFO bootSector ;
  LARGE_INTEGER offset ;
  PIRP irp ;
  int tmp ;
  PVOID tmp___0 ;
  int tmp___1 ;

  {
  retries = 0;
  {
  }
  DisketteExtension->IsReadOnly = 0;
  retries = 0;
  {
  while (1) {
    while_99_continue: /* CIL Label */ ;
    if (retries < 3UL) {

    } else {
      goto while_99_break;
    }
    if (retries) {
      {
      }
      {
      FlInitializeControllerHardware(DisketteExtension);
      }
    } else {

    }
    DisketteExtension->DriveMediaType = (DriveMediaLimits + DisketteExtension->DriveType)->HighestDriveMediaType;
    DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + DisketteExtension->DriveMediaType);
    mediaTypesExhausted = 0;
    {
    while (1) {
      while_101_continue: /* CIL Label */ ;
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
        {
        sectorLengthCode = (DriveMediaConstants + DisketteExtension->DriveMediaType)->SectorLengthCode;
        FlHdbit(DisketteExtension);
        }
      } else {

      }
      {
      ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
      }
      if (! (ntStatus >= 0L)) {
        {
        }
        mediaTypesExhausted = 1;
      } else {
        {
        driveMediaConstants = DriveMediaConstants + DisketteExtension->DriveMediaType;
        DisketteExtension->FifoBuffer[1] = (unsigned char )((int )DisketteExtension->DeviceUnit | (((int )driveMediaConstants->NumberOfHeads - 1) << 2));
        DisketteExtension->FifoBuffer[0] = 84;
        ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                  DisketteExtension->FifoBuffer, (void *)0, 0, 0);
        }
        if (! (ntStatus >= 0L)) {
          goto _L;
        } else {
          if (((int )DisketteExtension->FifoBuffer[0] & -33) != (int )((unsigned char )((int )DisketteExtension->DeviceUnit | (((int )driveMediaConstants->NumberOfHeads - 1) << 2)))) {
            goto _L;
          } else {
            if ((int )DisketteExtension->FifoBuffer[1] != 0) {
              goto _L;
            } else {
              if ((int )DisketteExtension->FifoBuffer[2] != 0) {
                goto _L;
              } else {
                if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                  if ((int )DisketteExtension->FifoBuffer[6] != (int )sectorLengthCode) {
                    _L: /* CIL Label */ 
                    {
                    }
                    DisketteExtension->DriveMediaType = (DRIVE_MEDIA_TYPE )((int )DisketteExtension->DriveMediaType - 1);
                    DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + DisketteExtension->DriveMediaType);
                    if (ntStatus != -1073741661L) {
                      ntStatus = -1073741804L;
                    } else {

                    }
                    if ((int )((char )DisketteExtension->DriveMediaType) < (int )((char )(DriveMediaLimits + DisketteExtension->DriveType)->LowestDriveMediaType)) {
                      DisketteExtension->MediaType = 0;
                      mediaTypesExhausted = 1;
                      {
                      }
                    } else {

                    }
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: /* CIL Label */ 
                  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                    DisketteExtension->MediaType = driveMediaConstants->MediaType;
                    DisketteExtension->BytesPerSector = driveMediaConstants->BytesPerSector;
                    {
                    }
                    DisketteExtension->ByteCapacity = (((int )driveMediaConstants->BytesPerSector * (int )driveMediaConstants->SectorsPerTrack) * (1 + (int )driveMediaConstants->MaximumTrack)) * (int )driveMediaConstants->NumberOfHeads;
                    DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + DisketteExtension->DriveMediaType);
                    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                      tmp = 1024;
                    } else {
                      tmp = 512;
                    }
                    {
                    tmp___0 = ExAllocatePoolWithTag(4, tmp, 1886350406UL);
                    bootSector = tmp___0;
                    }
                    if (! bootSector) {
                      return (-1073741670L);
                    } else {

                    }
                    offset.__annonCompField1.HighPart = 0;
                    offset.__annonCompField1.LowPart = offset.__annonCompField1.HighPart;
                    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                      tmp___1 = 1024;
                    } else {
                      tmp___1 = 512;
                    }
                    {
                    irp = IoBuildAsynchronousFsdRequest(3, DisketteExtension->DeviceObject,
                                                        bootSector, tmp___1, & offset,
                                                        (void *)0);
                    }
                    if (! irp) {
                      {
                      }
                      {
/*                       ExFreePool(bootSector); */ /* INLINED */
                      }
                      return (-1073741670L);
                    } else {

                    }
                    {
                    irp->CurrentLocation = (CHAR )((int )irp->CurrentLocation - 1);
                    irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation -= 1;
                    ntStatus = FlReadWrite(DisketteExtension, irp, 1);
                    }
                    {
                    }
                    {
/*                     MmUnlockPages(irp->MdlAddress); */ /* INLINED */
/*                     IoFreeMdl(irp->MdlAddress); */ /* INLINED */
/*                     IoFreeIrp(irp); */ /* INLINED */
/*                     ExFreePool(bootSector); */ /* INLINED */
                    }
                    if (! (ntStatus >= 0L)) {
                      {
                      }
                      DisketteExtension->DriveMediaType = (DRIVE_MEDIA_TYPE )((int )DisketteExtension->DriveMediaType - 1);
                      DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + DisketteExtension->DriveMediaType);
                      if (ntStatus != -1073741661L) {
                        ntStatus = -1073741804L;
                      } else {

                      }
                      if ((int )((char )DisketteExtension->DriveMediaType) < (int )((char )(DriveMediaLimits + DisketteExtension->DriveType)->LowestDriveMediaType)) {
                        DisketteExtension->MediaType = 0;
                        mediaTypesExhausted = 1;
                        {
                        }
                      } else {

                      }
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
          }
        }
      }
      if (! (ntStatus >= 0L)) {
        if (! mediaTypesExhausted) {

        } else {
          goto while_101_break;
        }
      } else {
        goto while_101_break;
      }
    }
    while_101_break: /* CIL Label */ ;
    }
    if (ntStatus >= 0L) {
      {
      }
      goto while_99_break;
    } else {

    }
    retries += 1UL;
  }
  while_99_break: /* CIL Label */ ;
  }
  if (! (ntStatus >= 0L)) {
    goto _L___1;
  } else {
    if (mediaTypesExhausted) {
      _L___1: /* CIL Label */ 
      {
      }
      return (ntStatus);
    } else {

    }
  }
  DisketteExtension->MediaType = driveMediaConstants->MediaType;
  DisketteExtension->BytesPerSector = driveMediaConstants->BytesPerSector;
  DisketteExtension->ByteCapacity = (((int )driveMediaConstants->BytesPerSector * (int )driveMediaConstants->SectorsPerTrack) * (1 + (int )driveMediaConstants->MaximumTrack)) * (int )driveMediaConstants->NumberOfHeads;
  {
  }
  {
  DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + DisketteExtension->DriveMediaType);
  FlCheckBootSector(DisketteExtension);
  }
  return (ntStatus);
}
}
void FlAllocateIoBuffer(PDISKETTE_EXTENSION DisketteExtension , ULONG BufferSize ) 
{ BOOLEAN allocateContiguous ;
  LARGE_INTEGER maxDmaAddress ;
  PVOID tmp ;
  PVOID tmp___0 ;

  {
  if (DisketteExtension->IoBuffer) {
    if (DisketteExtension->IoBufferSize >= BufferSize) {
      return;
    } else {

    }
    {
    FlFreeIoBuffer(DisketteExtension);
    }
  } else {

  }
  if (BufferSize > DisketteExtension->MaxTransferSize) {
    allocateContiguous = 1;
  } else {
    allocateContiguous = 0;
  }
  if (allocateContiguous) {
    {
    maxDmaAddress.QuadPart = 16777215;
    tmp = MmAllocateContiguousMemory(BufferSize, maxDmaAddress);
    DisketteExtension->IoBuffer = tmp;
    }
  } else {
    {
    tmp___0 = ExAllocatePoolWithTag(4, BufferSize, 1886350406UL);
    DisketteExtension->IoBuffer = tmp___0;
    }
  }
  if (! DisketteExtension->IoBuffer) {
    return;
  } else {

  }
  {
  DisketteExtension->IoBufferMdl = IoAllocateMdl(DisketteExtension->IoBuffer, BufferSize,
                                                 0, 0, (void *)0);
  }
  if (! DisketteExtension->IoBufferMdl) {
    if (allocateContiguous) {
      {
/*       MmFreeContiguousMemory(DisketteExtension->IoBuffer); */ /* INLINED */
      }
    } else {
      {
/*       ExFreePool(DisketteExtension->IoBuffer); */ /* INLINED */
      }
    }
    DisketteExtension->IoBuffer = (void *)0;
    return;
  } else {

  }
  {
  MmProbeAndLockPages(DisketteExtension->IoBufferMdl, 0, 2);
  }
  {
  }
  if (allocateContiguous) {
    {
/*     MmFreeContiguousMemory(DisketteExtension->IoBuffer); */ /* INLINED */
    }
  } else {
    {
/*     ExFreePool(DisketteExtension->IoBuffer); */ /* INLINED */
    }
  }
  DisketteExtension->IoBuffer = (void *)0;
  return;
  DisketteExtension->IoBufferSize = BufferSize;
}
}
void FlFreeIoBuffer(PDISKETTE_EXTENSION DisketteExtension ) 
{ BOOLEAN contiguousBuffer ;

  {
  if (! DisketteExtension->IoBuffer) {
    return;
  } else {

  }
  if (DisketteExtension->IoBufferSize > DisketteExtension->MaxTransferSize) {
    contiguousBuffer = 1;
  } else {
    contiguousBuffer = 0;
  }
  {
  DisketteExtension->IoBufferSize = 0;
/*   MmUnlockPages(DisketteExtension->IoBufferMdl); */ /* INLINED */
/*   IoFreeMdl(DisketteExtension->IoBufferMdl); */ /* INLINED */
  DisketteExtension->IoBufferMdl = (void *)0;
  }
  if (contiguousBuffer) {
    {
/*     MmFreeContiguousMemory(DisketteExtension->IoBuffer); */ /* INLINED */
    }
  } else {
    {
/*     ExFreePool(DisketteExtension->IoBuffer); */ /* INLINED */
    }
  }
  DisketteExtension->IoBuffer = (void *)0;
  return;
}
}
void FloppyThread(PVOID Context ) 
{ PIRP irp ;
  PIO_STACK_LOCATION irpSp ;
  PLIST_ENTRY request ;
  PDISKETTE_EXTENSION disketteExtension ;
  NTSTATUS ntStatus ;
  NTSTATUS waitStatus ;
  LARGE_INTEGER queueWait ;
  LARGE_INTEGER acquireWait ;
  PKTHREAD tmp ;
  PDISK_GEOMETRY outputBuffer ;
  PSENSE_DEVISE_STATUS_PTOS outputBuffer___0 ;

  {
  {
  disketteExtension = Context;
  ntStatus = 0L;
  tmp = KeGetCurrentThread();
  KeSetPriorityThread(tmp, 16);
  queueWait.QuadPart = -30000000;
  acquireWait.QuadPart = -150000000;
  }
  {
  while (1) {
    while_114_continue: /* CIL Label */ ;
    {
    waitStatus = KeWaitForSingleObject((void *)(& disketteExtension->RequestSemaphore),
                                       0, 0, 0, & queueWait);
    }
    if (waitStatus == 258L) {
      if (! ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1)) {
        if (disketteExtension->FloppyControllerAllocated) {
          {
          }
          {
          FlFdcDeviceIo(disketteExtension->TargetObject, ((7 << 16) | (775 << 2)) | 3,
                        (void *)0);
          FlFdcDeviceIo(disketteExtension->TargetObject, ((7 << 16) | (769 << 2)) | 3,
                        disketteExtension->DeviceObject);
          disketteExtension->FloppyControllerAllocated = 0;
          }
        } else {

        }
      } else {

      }
      {
/*       ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
      }
      if (disketteExtension->ThreadReferenceCount == 0L) {
        disketteExtension->ThreadReferenceCount = -1;
        if ((unsigned int )disketteExtension->FloppyThread != (unsigned int )((void *)0)) {
          {
/*           ObfDereferenceObject(disketteExtension->FloppyThread); */ /* INLINED */
          disketteExtension->FloppyThread = (void *)0;
          }
        } else {

        }
        {
/*         ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
        }
        if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
          if (disketteExtension->ReleaseFdcWithMotorRunning) {
            {
            ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject, ((7 << 16) | (768 << 2)) | 3,
                                     & acquireWait);
            FlFdcDeviceIo(disketteExtension->TargetObject, ((7 << 16) | (775 << 2)) | 3,
                          (void *)0);
            FlFdcDeviceIo(disketteExtension->TargetObject, ((7 << 16) | (769 << 2)) | 3,
                          disketteExtension->DeviceObject);
            disketteExtension->FloppyControllerAllocated = 0;
            disketteExtension->ReleaseFdcWithMotorRunning = 0;
            }
          } else {

          }
        } else {

        }
        {
/*         ExAcquireFastMutex(PagingMutex); */ /* INLINED */
        PagingReferenceCount -= 1UL;
        }
        if (PagingReferenceCount == 0UL) {
          {
/* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
          }
        } else {

        }
        {
/*         ExReleaseFastMutex(PagingMutex); */ /* INLINED */
        }
        {
        }
        {
        PsTerminateSystemThread(0L);
        }
      } else {

      }
      {
/*       ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
      }
      goto __Cont;
    } else {

    }
    {
    while (1) {
      while_117_continue: /* CIL Label */ ;
      {
      request = (void *)0; /* ExfInterlockedRemoveHeadList(& disketteExtension->ListEntry, & disketteExtension->ListSpinLock); */ /* INLINED */
      }
      if (request) {

      } else {
        goto while_117_break;
      }
      {
/*       ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
      disketteExtension->ThreadReferenceCount -= 1L;
/*       ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
      disketteExtension->HardwareFailed = 0;
      irp = (IRP *)((CHAR *)request - (unsigned long )(& ((IRP *)0)->Tail.Overlay.__annonCompField17.ListEntry));
/*       ExAcquireFastMutex(& disketteExtension->PowerDownMutex); */ /* INLINED */
      }
      if ((int )disketteExtension->PoweringDown == 1) {
        {
/*         ExReleaseFastMutex(& disketteExtension->PowerDownMutex); */ /* INLINED */
        }
        {
        }
        {
        irp = (IRP *)((CHAR *)request - (unsigned long )(& ((IRP *)0)->Tail.Overlay.__annonCompField17.ListEntry));
        irp->IoStatus.__annonCompField4.Status = -1073741101L;
        irp->IoStatus.Information = 0;
        IofCompleteRequest(irp, 0);
        }
        goto while_117_continue;
      } else {

      }
      {
/*       ExReleaseFastMutex(& disketteExtension->PowerDownMutex); */ /* INLINED */
      }
      {
      }
      irpSp = irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
      {
      }
      if (irpSp->MajorFunction == 27) {
        goto switch_121_27;
      } else {
        if (irpSp->MajorFunction == 3) {
          goto switch_121_3;
        } else {
          if (irpSp->MajorFunction == 4) {
            goto switch_121_4;
          } else {
            if (irpSp->MajorFunction == 14) {
              goto switch_121_14;
            } else {
              {
              goto switch_121_default;
              if (0) {
                switch_121_27: /* CIL Label */ ;
                {
                }
                if ((int )irpSp->MinorFunction == 1) {
                  goto _L;
                } else {
                  if ((int )irpSp->MinorFunction == 5) {
                    _L: /* CIL Label */ 
                    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                      if (disketteExtension->ReleaseFdcWithMotorRunning) {
                        {
                        FlFdcDeviceIo(disketteExtension->TargetObject, ((7 << 16) | (768 << 2)) | 3,
                                      & acquireWait);
                        disketteExtension->ReleaseFdcWithMotorRunning = 0;
                        disketteExtension->FloppyControllerAllocated = 1;
                        }
                      } else {

                      }
                    } else {

                    }
                    if (disketteExtension->FloppyControllerAllocated) {
                      {
                      FlFdcDeviceIo(disketteExtension->TargetObject, ((7 << 16) | (775 << 2)) | 3,
                                    (void *)0);
                      FlFdcDeviceIo(disketteExtension->TargetObject, ((7 << 16) | (769 << 2)) | 3,
                                    disketteExtension->DeviceObject);
                      disketteExtension->FloppyControllerAllocated = 0;
                      }
                    } else {

                    }
                    {
/*                     ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
                    disketteExtension->ThreadReferenceCount = -1;
/*                     ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
/*                     ExAcquireFastMutex(PagingMutex); */ /* INLINED */
                    PagingReferenceCount -= 1UL;
                    }
                    if (PagingReferenceCount == 0UL) {
                      {
/* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
                      }
                    } else {

                    }
                    {
/*                     ExReleaseFastMutex(PagingMutex); */ /* INLINED */
                    PsTerminateSystemThread(0L);
                    }
                  } else {
                    ntStatus = -1073741808L;
                  }
                }
                goto switch_121_break;
                switch_121_3: /* CIL Label */ ;
                switch_121_4: /* CIL Label */ ;
                if (! disketteExtension->FloppyControllerAllocated) {
                  {
                  ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject, ((7 << 16) | (768 << 2)) | 3,
                                           & acquireWait);
                  }
                  if (ntStatus >= 0L) {
                    disketteExtension->FloppyControllerAllocated = 1;
                    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                      disketteExtension->ReleaseFdcWithMotorRunning = 0;
                    } else {

                    }
                  } else {
                    goto switch_121_break;
                  }
                } else {

                }
                if ((disketteExtension->DeviceObject)->Flags & 2UL) {
                  if (! ((int )irpSp->Flags & 2)) {
                    {
                    }
                    ntStatus = -2147483626L;
                  } else {
                    {
                    ntStatus = FlReadWrite(disketteExtension, irp, 0);
                    }
                  }
                } else {
                  {
                  ntStatus = FlReadWrite(disketteExtension, irp, 0);
                  }
                }
                goto switch_121_break;
                switch_121_14: /* CIL Label */ ;
                if (! disketteExtension->FloppyControllerAllocated) {
                  {
                  ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject, ((7 << 16) | (768 << 2)) | 3,
                                           & acquireWait);
                  }
                  if (ntStatus >= 0L) {
                    disketteExtension->FloppyControllerAllocated = 1;
                    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                      disketteExtension->ReleaseFdcWithMotorRunning = 0;
                    } else {

                    }
                  } else {
                    goto switch_121_break;
                  }
                } else {

                }
                if ((disketteExtension->DeviceObject)->Flags & 2UL) {
                  if (! ((int )irpSp->Flags & 2)) {
                    {
                    }
                    ntStatus = -2147483626L;
                  } else {
                    goto _L___2;
                  }
                } else {
                  _L___2: /* CIL Label */ 
                  if (irpSp->Parameters.DeviceIoControl.IoControlCode == (((45 << 16) | (1 << 14)) | (512 << 2))) {
                    goto switch_125_exp_12;
                  } else {
                    if (irpSp->Parameters.DeviceIoControl.IoControlCode == (((7 << 16) | (1 << 14)) | (512 << 2))) {
                      goto switch_125_exp_13;
                    } else {
                      if (irpSp->Parameters.DeviceIoControl.IoControlCode == ((7 << 16) | (9 << 2))) {
                        goto switch_125_exp_14;
                      } else {
                        if (irpSp->Parameters.DeviceIoControl.IoControlCode == 7 << 16) {
                          goto switch_125_exp_15;
                        } else {
                          if (irpSp->Parameters.DeviceIoControl.IoControlCode == (((7 << 16) | (3 << 14)) | (11 << 2))) {
                            goto switch_125_exp_16;
                          } else {
                            if (irpSp->Parameters.DeviceIoControl.IoControlCode == (((7 << 16) | (3 << 14)) | (6 << 2))) {
                              goto switch_125_exp_17;
                            } else {
                              if (irpSp->Parameters.DeviceIoControl.IoControlCode == ((7 << 16) | (248 << 2))) {
                                goto switch_125_exp_18;
                              } else {
                                if (0) {
                                  switch_125_exp_12: /* CIL Label */ ;
                                  switch_125_exp_13: /* CIL Label */ ;
                                  {
                                  }
                                  {
                                  ntStatus = FlStartDrive(disketteExtension, irp,
                                                          0, 0, (unsigned char )(! (! ((int )irpSp->Flags & 2))));
                                  }
                                  goto switch_125_break;
                                  switch_125_exp_14: /* CIL Label */ ;
                                  {
                                  }
                                  if (disketteExtension->IsReadOnly) {
                                    ntStatus = -1073741811L;
                                  } else {
                                    {
                                    ntStatus = FlStartDrive(disketteExtension, irp,
                                                            1, 0, 1);
                                    }
                                  }
                                  goto switch_125_break;
                                  switch_125_exp_15: /* CIL Label */ ;
                                  {
                                  }
                                  if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )sizeof(DISK_GEOMETRY )) {
                                    ntStatus = -1073741811L;
                                  } else {
                                    {
                                    ntStatus = FlStartDrive(disketteExtension, irp,
                                                            0, 1, (unsigned char )(! (! ((int )irpSp->Flags & 2))));
                                    }
                                  }
                                  if (ntStatus >= 0L) {
                                    goto _L___0;
                                  } else {
                                    if (ntStatus == -1073741804L) {
                                      _L___0: /* CIL Label */ 
                                      outputBuffer = (struct _DISK_GEOMETRY *)irp->AssociatedIrp.SystemBuffer;
                                      ntStatus = 0L;
                                      outputBuffer->MediaType = disketteExtension->MediaType;
                                      if ((int )disketteExtension->MediaType == 0) {
                                        {
                                        }
                                        outputBuffer->Cylinders.__annonCompField1.LowPart = 0;
                                        outputBuffer->Cylinders.__annonCompField1.HighPart = 0;
                                        outputBuffer->TracksPerCylinder = 0;
                                        outputBuffer->SectorsPerTrack = 0;
                                        outputBuffer->BytesPerSector = 0;
                                      } else {
                                        {
                                        }
                                        outputBuffer->Cylinders.__annonCompField1.LowPart = (int )disketteExtension->DriveMediaConstants.MaximumTrack + 1;
                                        outputBuffer->Cylinders.__annonCompField1.HighPart = 0;
                                        outputBuffer->TracksPerCylinder = disketteExtension->DriveMediaConstants.NumberOfHeads;
                                        outputBuffer->SectorsPerTrack = disketteExtension->DriveMediaConstants.SectorsPerTrack;
                                        outputBuffer->BytesPerSector = disketteExtension->DriveMediaConstants.BytesPerSector;
                                      }
                                      {
                                      }
                                    } else {

                                    }
                                  }
                                  irp->IoStatus.Information = sizeof(DISK_GEOMETRY );
                                  goto switch_125_break;
                                  switch_125_exp_16: /* CIL Label */ ;
                                  switch_125_exp_17: /* CIL Label */ ;
                                  {
                                  }
                                  {
                                  ntStatus = FlStartDrive(disketteExtension, irp,
                                                          1, 0, 0);
                                  }
                                  if (ntStatus >= 0L) {
                                    goto _L___1;
                                  } else {
                                    if (ntStatus == -1073741804L) {
                                      _L___1: /* CIL Label */ 
                                      {
                                      FlAllocateIoBuffer(disketteExtension, 4096);
                                      }
                                      if (disketteExtension->IoBuffer) {
                                        {
                                        ntStatus = FlFormat(disketteExtension, irp);
                                        }
                                      } else {
                                        ntStatus = -1073741670L;
                                      }
                                    } else {

                                    }
                                  }
                                  goto switch_125_break;
                                  switch_125_exp_18: /* CIL Label */ ;
                                  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                                    {
                                    disketteExtension->FifoBuffer[0] = 14;
                                    disketteExtension->FifoBuffer[1] = disketteExtension->DeviceUnit;
                                    ntStatus = FlIssueCommand(disketteExtension, disketteExtension->FifoBuffer,
                                                              disketteExtension->FifoBuffer,
                                                              (void *)0, 0, 0);
                                    }
                                    if (ntStatus >= 0L) {
                                      outputBuffer___0 = (struct _SENSE_DEVISE_STATUS_PTOS *)irp->AssociatedIrp.SystemBuffer;
                                      outputBuffer___0->ST3_PTOS = Result_Status3_PTOS[0].ST3_PTOS;
                                      irp->IoStatus.Information = sizeof(SENSE_DEVISE_STATUS_PTOS );
                                    } else {

                                    }
                                    goto switch_125_break;
                                  } else {

                                  }
                                } else {
                                  switch_125_break: /* CIL Label */ ;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                goto switch_121_break;
                switch_121_default: /* CIL Label */ ;
                {
                }
                ntStatus = -1073741822L;
              } else {
                switch_121_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
      if (ntStatus == -2147483631L) {
        {
        while (1) {
          while_134_continue: /* CIL Label */ ;
          {
          disketteExtension->HardwareFailed = 0;
          irp->IoStatus.__annonCompField4.Status = -2147483631L;
          IofCompleteRequest(irp, 1);
          request = (void *)0; /* ExfInterlockedRemoveHeadList(& disketteExtension->ListEntry, & disketteExtension->ListSpinLock); */ /* INLINED */
          }
          if (! request) {
            goto while_134_break;
          } else {

          }
          {
/*           ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
          disketteExtension->ThreadReferenceCount -= 1L;
/*           ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex); */ /* INLINED */
          irp = (IRP *)((CHAR *)request - (unsigned long )(& ((IRP *)0)->Tail.Overlay.__annonCompField17.ListEntry));
          }
        }
        while_134_break: /* CIL Label */ ;
        }
      } else {
        irp->IoStatus.__annonCompField4.Status = ntStatus;
        if (disketteExtension->IoBuffer) {
          {
          FlFreeIoBuffer(disketteExtension);
          }
        } else {

        }
        {
        FlFinishOperation(irp, disketteExtension);
        }
      }
    }
    while_117_break: /* CIL Label */ ;
    }
    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
      if (disketteExtension->FloppyControllerAllocated) {
        {
        FlFdcDeviceIo(disketteExtension->TargetObject, ((7 << 16) | (769 << 2)) | 3,
                      disketteExtension->DeviceObject);
        disketteExtension->FloppyControllerAllocated = 0;
        disketteExtension->ReleaseFdcWithMotorRunning = 1;
        }
      } else {

      }
    } else {

    }
    __Cont: /* CIL Label */ ;
  }
  while_114_break: /* CIL Label */ ;
  }
}
}
void FlConsolidateMediaTypeWithBootSector(PDISKETTE_EXTENSION DisketteExtension ,
                                          PBOOT_SECTOR_INFO BootSector ) 
{ USHORT bpbNumberOfSectors ;
  USHORT bpbNumberOfHeads ;
  USHORT bpbSectorsPerTrack ;
  USHORT bpbBytesPerSector ;
  USHORT bpbMediaByte ;
  USHORT bpbMaximumTrack ;
  MEDIA_TYPE bpbMediaType ;
  ULONG i ;
  ULONG n ;
  PDRIVE_MEDIA_CONSTANTS readidDriveMediaConstants ;
  BOOLEAN changeToBpbMedia ;
  int tmp ;
  SIZE_T tmp___0 ;

  {
  {
  }
  if ((int )BootSector->JumpByte[0] != 235) {
    if ((int )BootSector->JumpByte[0] != 233) {
      return;
    } else {

    }
  } else {

  }
  bpbNumberOfSectors = (int )BootSector->NumberOfSectors[1] * 256 + (int )BootSector->NumberOfSectors[0];
  bpbNumberOfHeads = (int )BootSector->NumberOfHeads[1] * 256 + (int )BootSector->NumberOfHeads[0];
  bpbSectorsPerTrack = (int )BootSector->SectorsPerTrack[1] * 256 + (int )BootSector->SectorsPerTrack[0];
  bpbBytesPerSector = (int )BootSector->BytesPerSector[1] * 256 + (int )BootSector->BytesPerSector[0];
  bpbMediaByte = BootSector->MediaByte[0];
  if (! bpbNumberOfHeads) {
    return;
  } else {
    if (! bpbSectorsPerTrack) {
      return;
    } else {

    }
  }
  bpbMaximumTrack = ((int )bpbNumberOfSectors / (int )bpbNumberOfHeads) / (int )bpbSectorsPerTrack - 1;
  bpbMediaType = 0;
  i = 0;
  {
  while (1) {
    while_136_continue: /* CIL Label */ ;
    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
      tmp = 21;
    } else {
      tmp = 17;
    }
    if (i < (unsigned long )tmp) {

    } else {
      goto while_136_break;
    }
    if ((int )bpbBytesPerSector == (int )(DriveMediaConstants + i)->BytesPerSector) {
      if ((int )bpbSectorsPerTrack == (int )(DriveMediaConstants + i)->SectorsPerTrack) {
        if ((int )bpbMaximumTrack == (int )(DriveMediaConstants + i)->MaximumTrack) {
          if ((int )bpbNumberOfHeads == (int )(DriveMediaConstants + i)->NumberOfHeads) {
            if ((int )bpbMediaByte == (int )(DriveMediaConstants + i)->MediaByte) {
              bpbMediaType = (DriveMediaConstants + i)->MediaType;
              goto while_136_break;
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    i += 1UL;
  }
  while_136_break: /* CIL Label */ ;
  }
  if ((int )DisketteExtension->DriveType == 3) {
    if (bpbMediaType == 15) {
      goto switch_137_15;
    } else {
      if (bpbMediaType == 16) {
        goto switch_137_16;
      } else {
        if (bpbMediaType == 1) {
          goto switch_137_1;
        } else {
          if (bpbMediaType == 19) {
            goto switch_137_19;
          } else {
            {
            goto switch_137_default;
            if (0) {
              switch_137_15: /* CIL Label */ 
              bpbMediaType = 14;
              goto switch_137_break;
              switch_137_16: /* CIL Label */ 
              bpbMediaType = 5;
              goto switch_137_break;
              switch_137_1: /* CIL Label */ 
              bpbMediaType = 17;
              goto switch_137_break;
              switch_137_19: /* CIL Label */ 
              bpbMediaType = 18;
              goto switch_137_break;
              switch_137_default: /* CIL Label */ ;
              goto switch_137_break;
            } else {
              switch_137_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
  } else {

  }
  {
  }
  {
  }
  if ((int )bpbMediaType == (int )DisketteExtension->MediaType) {
    changeToBpbMedia = 0;
    {
    }
  } else {
    readidDriveMediaConstants = & DisketteExtension->DriveMediaConstants;
    if ((int )bpbBytesPerSector == (int )readidDriveMediaConstants->BytesPerSector) {
      if ((int )bpbSectorsPerTrack < 256) {
        if ((int )bpbMaximumTrack == (int )readidDriveMediaConstants->MaximumTrack) {
          if ((int )bpbNumberOfHeads <= (int )readidDriveMediaConstants->NumberOfHeads) {
            changeToBpbMedia = 1;
          } else {
            changeToBpbMedia = 0;
          }
        } else {
          changeToBpbMedia = 0;
        }
      } else {
        changeToBpbMedia = 0;
      }
    } else {
      changeToBpbMedia = 0;
    }
    {
    }
    if ((int )bpbMediaType == 0) {
      bpbMediaType = readidDriveMediaConstants->MediaType;
      DisketteExtension->DriveMediaConstants.SkewDelta = 0;
    } else {

    }
  }
  if (changeToBpbMedia) {
    i = (DriveMediaLimits + DisketteExtension->DriveType)->LowestDriveMediaType;
    n = (DriveMediaLimits + DisketteExtension->DriveType)->HighestDriveMediaType;
    {
    while (1) {
      while_142_continue: /* CIL Label */ ;
      if (i <= n) {

      } else {
        goto while_142_break;
      }
      if ((int )bpbMediaType == (int )(DriveMediaConstants + i)->MediaType) {
        DisketteExtension->DriveMediaType = i;
        goto while_142_break;
      } else {

      }
      i += 1UL;
    }
    while_142_break: /* CIL Label */ ;
    }
    {
    DisketteExtension->MediaType = bpbMediaType;
    DisketteExtension->ByteCapacity = (int )bpbNumberOfSectors * (int )bpbBytesPerSector;
    DisketteExtension->DriveMediaConstants.SectorsPerTrack = (unsigned char )bpbSectorsPerTrack;
    DisketteExtension->DriveMediaConstants.NumberOfHeads = (unsigned char )bpbNumberOfHeads;
    tmp___0 = RtlCompareMemory(BootSector->OemData, "MSDMF3.", 7);
    }
    if (tmp___0 == 7UL) {
      DisketteExtension->IsReadOnly = 1;
    } else {

    }
  } else {

  }
  return;
}
}
void FlCheckBootSector(PDISKETTE_EXTENSION DisketteExtension ) 
{ PBOOT_SECTOR_INFO bootSector ;
  LARGE_INTEGER offset ;
  PIRP irp ;
  NTSTATUS status ;
  int tmp ;
  PVOID tmp___0 ;
  int tmp___1 ;

  {
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
    tmp = 1024;
  } else {
    tmp = 512;
  }
  {
  tmp___0 = ExAllocatePoolWithTag(4, tmp, 1886350406UL);
  bootSector = tmp___0;
  }
  if (! bootSector) {
    return;
  } else {

  }
  offset.__annonCompField1.HighPart = 0;
  offset.__annonCompField1.LowPart = offset.__annonCompField1.HighPart;
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
    tmp___1 = 1024;
  } else {
    tmp___1 = 512;
  }
  {
  irp = IoBuildAsynchronousFsdRequest(3, DisketteExtension->DeviceObject, bootSector,
                                      tmp___1, & offset, (void *)0);
  }
  if (! irp) {
    {
/*     ExFreePool(bootSector); */ /* INLINED */
    }
    return;
  } else {

  }
  {
  irp->CurrentLocation = (CHAR )((int )irp->CurrentLocation - 1);
  irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation -= 1;
  status = FlReadWrite(DisketteExtension, irp, 1);
/*   MmUnlockPages(irp->MdlAddress); */ /* INLINED */
/*   IoFreeMdl(irp->MdlAddress); */ /* INLINED */
/*   IoFreeIrp(irp); */ /* INLINED */
/*   ExFreePool(bootSector); */ /* INLINED */
  }
  return;
}
}
NTSTATUS FlReadWriteTrack(PDISKETTE_EXTENSION DisketteExtension , PMDL IoMdl , ULONG IoOffset ,
                          BOOLEAN WriteOperation , UCHAR Cylinder , UCHAR Head , UCHAR Sector ,
                          UCHAR NumberOfSectors , BOOLEAN NeedSeek ) 
{ PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  ULONG byteToSectorShift ;
  ULONG transferBytes ;
  LARGE_INTEGER headSettleTime ;
  NTSTATUS status ;
  ULONG seekRetry ;
  ULONG ioRetry ;
  BOOLEAN recalibrateDrive ;
  UCHAR i ;

  {
  recalibrateDrive = 0;
  {
  }
  driveMediaConstants = & DisketteExtension->DriveMediaConstants;
  byteToSectorShift = 7 + (int )driveMediaConstants->SectorLengthCode;
  transferBytes = (unsigned long )NumberOfSectors << byteToSectorShift;
  headSettleTime.__annonCompField1.LowPart = - (10000 * (int )driveMediaConstants->HeadSettleTime);
  headSettleTime.__annonCompField1.HighPart = -1;
  seekRetry = 0;
  ioRetry = 0;
  {
  while (1) {
    while_144_continue: /* CIL Label */ ;
    if (seekRetry < 3UL) {

    } else {
      goto while_144_break;
    }
    if (recalibrateDrive) {
      {
      }
      {
      FlRecalibrateDrive(DisketteExtension);
      }
    } else {

    }
    if (recalibrateDrive) {
      goto _L___0;
    } else {
      if (NeedSeek) {
        if (! DisketteExtension->ControllerConfigurable) {
          goto _L___0;
        } else {
          if ((int )driveMediaConstants->CylinderShift != 0) {
            _L___0: /* CIL Label */ 
            {
            DisketteExtension->FifoBuffer[0] = 16;
            DisketteExtension->FifoBuffer[1] = ((int )Head << 2) | (int )DisketteExtension->DeviceUnit;
            DisketteExtension->FifoBuffer[2] = (int )Cylinder << (int )driveMediaConstants->CylinderShift;
            status = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                    DisketteExtension->FifoBuffer, (void *)0, 0, 0);
            }
            if (status >= 0L) {
              if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
                DisketteExtension->HardwareFailed = 1;
                status = -1073741464L;
              } else {
                if ((int )DisketteExtension->FifoBuffer[1] != (int )Cylinder << (int )driveMediaConstants->CylinderShift) {
                  DisketteExtension->HardwareFailed = 1;
                  status = -1073741464L;
                } else {

                }
              }
              if (status >= 0L) {
                {
                KeDelayExecutionThread(0, 0, & headSettleTime);
                DisketteExtension->FifoBuffer[0] = 84;
                DisketteExtension->FifoBuffer[1] = ((int )Head << 2) | (int )DisketteExtension->DeviceUnit;
                status = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                        DisketteExtension->FifoBuffer, (void *)0,
                                        0, 0);
                }
                if (status >= 0L) {
                  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                    if ((int )DisketteExtension->FifoBuffer[0] & 8) {
                      return (-1073741661L);
                    } else {

                    }
                  } else {

                  }
                  if ((int )DisketteExtension->FifoBuffer[0] != (((int )Head << 2) | (int )DisketteExtension->DeviceUnit)) {
                    {
                    DisketteExtension->HardwareFailed = 1;
                    status = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
                    }
                  } else {
                    if ((int )DisketteExtension->FifoBuffer[1] != 0) {
                      {
                      DisketteExtension->HardwareFailed = 1;
                      status = FlInterpretError(DisketteExtension->FifoBuffer[1],
                                                DisketteExtension->FifoBuffer[2]);
                      }
                    } else {
                      if ((int )DisketteExtension->FifoBuffer[2] != 0) {
                        {
                        DisketteExtension->HardwareFailed = 1;
                        status = FlInterpretError(DisketteExtension->FifoBuffer[1],
                                                  DisketteExtension->FifoBuffer[2]);
                        }
                      } else {
                        if ((int )DisketteExtension->FifoBuffer[3] != (int )Cylinder) {
                          {
                          DisketteExtension->HardwareFailed = 1;
                          status = FlInterpretError(DisketteExtension->FifoBuffer[1],
                                                    DisketteExtension->FifoBuffer[2]);
                          }
                        } else {

                        }
                      }
                    }
                  }
                } else {
                  {
                  }
                }
              } else {

              }
            } else {
              {
              }
            }
          } else {
            status = 0L;
          }
        }
      } else {
        status = 0L;
      }
    }
    if (! (status >= 0L)) {
      {
      }
      recalibrateDrive = 1;
      goto __Cont;
    } else {

    }
    {
    while (1) {
      while_149_continue: /* CIL Label */ ;
      DisketteExtension->FifoBuffer[1] = ((int )Head << 2) | (int )DisketteExtension->DeviceUnit;
      DisketteExtension->FifoBuffer[2] = Cylinder;
      DisketteExtension->FifoBuffer[3] = Head;
      DisketteExtension->FifoBuffer[4] = (int )Sector + 1;
      DisketteExtension->FifoBuffer[5] = driveMediaConstants->SectorLengthCode;
      DisketteExtension->FifoBuffer[6] = (int )Sector + (int )NumberOfSectors;
      DisketteExtension->FifoBuffer[7] = driveMediaConstants->ReadWriteGapLength;
      DisketteExtension->FifoBuffer[8] = driveMediaConstants->DataLength;
      if (WriteOperation) {
        DisketteExtension->FifoBuffer[0] = 66;
      } else {
        DisketteExtension->FifoBuffer[0] = 64;
      }
      {
      status = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer, DisketteExtension->FifoBuffer,
                              IoMdl, IoOffset, transferBytes);
      }
      if (status >= 0L) {
        if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
          if ((int )DisketteExtension->FifoBuffer[0] & 8) {
            return (-1073741661L);
          } else {

          }
        } else {

        }
        if (((int )DisketteExtension->FifoBuffer[0] & 192) != 0) {
          if (((int )DisketteExtension->FifoBuffer[0] & 192) != 64) {
            {
            DisketteExtension->HardwareFailed = 1;
            status = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
            }
          } else {
            if ((int )DisketteExtension->FifoBuffer[1] != 128) {
              {
              DisketteExtension->HardwareFailed = 1;
              status = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
              }
            } else {
              if ((int )DisketteExtension->FifoBuffer[2] != 0) {
                {
                DisketteExtension->HardwareFailed = 1;
                status = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
                }
              } else {
                goto _L___1;
              }
            }
          }
        } else {
          _L___1: /* CIL Label */ 
          if ((int )DisketteExtension->FifoBuffer[5] != 1) {
            DisketteExtension->HardwareFailed = 1;
            status = -1073741465L;
          } else {

          }
        }
      } else {
        {
        }
      }
      if (status >= 0L) {
        goto while_149_break;
      } else {

      }
      if (ioRetry >= 2UL) {
        {
        }
        goto while_149_break;
      } else {

      }
      ioRetry += 1UL;
    }
    while_149_break: /* CIL Label */ ;
    }
    if (status >= 0L) {
      goto while_144_break;
    } else {

    }
    recalibrateDrive = 1;
    __Cont: /* CIL Label */ 
    seekRetry += 1UL;
  }
  while_144_break: /* CIL Label */ ;
  }
  if (! (status >= 0L)) {
    if ((int )NumberOfSectors > 1) {
      {
      }
      i = 0;
      {
      while (1) {
        while_153_continue: /* CIL Label */ ;
        if ((int )i < (int )NumberOfSectors) {

        } else {
          goto while_153_break;
        }
        {
        status = FlReadWriteTrack(DisketteExtension, IoMdl, IoOffset + ((unsigned long )i << byteToSectorShift),
                                  WriteOperation, Cylinder, Head, (unsigned char )((int )Sector + (int )i),
                                  1, 0);
        }
        if (! (status >= 0L)) {
          {
          }
          DisketteExtension->HardwareFailed = 1;
          goto while_153_break;
        } else {

        }
        i = (UCHAR )((int )i + 1);
      }
      while_153_break: /* CIL Label */ ;
      }
    } else {

    }
  } else {

  }
  return (status);
}
}
NTSTATUS FlReadWrite(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN DriveStarted ) 
{ PIO_STACK_LOCATION irpSp ;
  BOOLEAN writeOperation ;
  NTSTATUS status ;
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  ULONG byteToSectorShift ;
  ULONG currentSector ;
  ULONG firstSector ;
  ULONG lastSector ;
  ULONG trackSize ;
  UCHAR sectorsPerTrack ;
  UCHAR numberOfHeads ;
  UCHAR currentHead ;
  UCHAR currentCylinder ;
  UCHAR trackSector ;
  PCHAR userBuffer ;
  UCHAR skew ;
  UCHAR skewDelta ;
  UCHAR numTransferSectors ;
  PMDL mdl ;
  PCHAR ioBuffer ;
  ULONG ioOffset ;
  PVOID tmp___0 ;

  {
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
  {
  }
  if ((int )irpSp->MajorFunction == 4) {
    if (DisketteExtension->IsReadOnly) {
      {
      }
      return (-1073741811L);
    } else {

    }
    writeOperation = 1;
  } else {
    writeOperation = 0;
  }
  {
  }
  if (DriveStarted) {
    status = 0L;
  } else {
    {
    status = FlStartDrive(DisketteExtension, Irp, writeOperation, 1, (unsigned char )(! (! ((int )irpSp->Flags & 2))));
    }
  }
  if (! (status >= 0L)) {
    {
    }
    return (status);
  } else {

  }
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
    {
    FlHdbit(DisketteExtension);
    }
  } else {

  }
  if ((int )DisketteExtension->MediaType == 0) {
    {
    }
    return (-1073741804L);
  } else {

  }
  driveMediaConstants = & DisketteExtension->DriveMediaConstants;
  byteToSectorShift = 7 + (int )driveMediaConstants->SectorLengthCode;
  firstSector = irpSp->Parameters.Read.ByteOffset.__annonCompField1.LowPart >> byteToSectorShift;
  lastSector = firstSector + (irpSp->Parameters.Read.Length >> byteToSectorShift);
  sectorsPerTrack = driveMediaConstants->SectorsPerTrack;
  numberOfHeads = driveMediaConstants->NumberOfHeads;
  if ((int )(Irp->MdlAddress)->MdlFlags & 5) {
    userBuffer = (Irp->MdlAddress)->MappedSystemVa;
  } else {
    {
    tmp___0 = (void *)0; /* MmMapLockedPagesSpecifyCache(Irp->MdlAddress, 0, 1, (void *)0, 0, 32); */ /* INLINED */
    userBuffer = tmp___0;
    }
  }
  if ((unsigned int )userBuffer == (unsigned int )((void *)0)) {
    {
    }
    return (-1073741670L);
  } else {

  }
  trackSize = (unsigned long )sectorsPerTrack << byteToSectorShift;
  skew = 0;
  skewDelta = driveMediaConstants->SkewDelta;
  currentSector = firstSector;
  {
  while (1) {
    while_161_continue: /* CIL Label */ ;
    if (currentSector < lastSector) {

    } else {
      goto while_161_break;
    }
    currentCylinder = (unsigned char )((currentSector / (ULONG )sectorsPerTrack) / (ULONG )numberOfHeads);
    trackSector = (unsigned char )(currentSector % (unsigned long )sectorsPerTrack);
    currentHead = (unsigned char )((currentSector / (ULONG )sectorsPerTrack) % (unsigned long )numberOfHeads);
    numTransferSectors = (int )sectorsPerTrack - (int )trackSector;
    if (lastSector - currentSector < (ULONG )numTransferSectors) {
      numTransferSectors = (unsigned char )(lastSector - currentSector);
    } else {

    }
    if (trackSize > DisketteExtension->MaxTransferSize) {
      {
      }
      {
      FlAllocateIoBuffer(DisketteExtension, trackSize);
      }
      if (! DisketteExtension->IoBuffer) {
        {
        }
        return (-1073741670L);
      } else {

      }
      mdl = DisketteExtension->IoBufferMdl;
      ioBuffer = DisketteExtension->IoBuffer;
      ioOffset = 0;
      if (writeOperation) {
        {
        memmove(ioBuffer, userBuffer + ((currentSector - firstSector) << byteToSectorShift),
                (unsigned long )numTransferSectors << byteToSectorShift);
        }
      } else {

      }
    } else {
      mdl = Irp->MdlAddress;
      ioOffset = (currentSector - firstSector) << byteToSectorShift;
    }
    if ((int )skew >= (int )numTransferSectors + (int )trackSector) {
      skew = 0;
    } else {

    }
    if ((int )skew < (int )trackSector) {
      skew = trackSector;
    } else {

    }
    {
    status = FlReadWriteTrack(DisketteExtension, mdl, ioOffset + (((unsigned long )skew - (unsigned long )trackSector) << byteToSectorShift),
                              writeOperation, currentCylinder, currentHead, skew,
                              (unsigned char )(((int )numTransferSectors + (int )trackSector) - (int )skew),
                              1);
    }
    if (status >= 0L) {
      if ((int )skew > (int )trackSector) {
        {
        status = FlReadWriteTrack(DisketteExtension, mdl, ioOffset, writeOperation,
                                  currentCylinder, currentHead, trackSector, (unsigned char )((int )skew - (int )trackSector),
                                  0);
        }
      } else {
        skew = ((int )numTransferSectors + (int )trackSector) % (int )sectorsPerTrack;
      }
    } else {
      skew = ((int )numTransferSectors + (int )trackSector) % (int )sectorsPerTrack;
    }
    if (! (status >= 0L)) {
      goto while_161_break;
    } else {

    }
    if (! writeOperation) {
      if (trackSize > DisketteExtension->MaxTransferSize) {
        {
        memmove(userBuffer + ((currentSector - firstSector) << byteToSectorShift),
                ioBuffer, (unsigned long )numTransferSectors << byteToSectorShift);
        }
      } else {

      }
    } else {

    }
    skew = ((int )skew + (int )skewDelta) % (int )sectorsPerTrack;
    currentSector += (ULONG )numTransferSectors;
  }
  while_161_break: /* CIL Label */ ;
  }
  Irp->IoStatus.Information = (currentSector - firstSector) << byteToSectorShift;
  if (status >= 0L) {
    if (firstSector == 0UL) {
      {
      FlConsolidateMediaTypeWithBootSector(DisketteExtension, (struct _BOOT_SECTOR_INFO *)userBuffer);
      }
    } else {

    }
  } else {

  }
  {
  }
  return (status);
}
}
NTSTATUS FlFormat(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) 
{ LARGE_INTEGER headSettleTime ;
  PIO_STACK_LOCATION irpSp ;
  PBAD_TRACK_NUMBER badTrackBuffer ;
  PFORMAT_PARAMETERS formatParameters ;
  PFORMAT_EX_PARAMETERS formatExParameters ;
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  NTSTATUS ntStatus ;
  ULONG badTrackBufferLength ;
  DRIVE_MEDIA_TYPE driveMediaType ;
  UCHAR driveStatus ;
  UCHAR numberOfBadTracks ;
  UCHAR currentTrack ;
  UCHAR endTrack ;
  UCHAR whichSector ;
  UCHAR retryCount ;
  BOOLEAN bufferOverflow ;
  FDC_DISK_CHANGE_PARMS fdcDiskChangeParms ;
  ULONG length ;
  UCHAR tmp ;

  {
  numberOfBadTracks = 0;
  bufferOverflow = 0;
  {
  }
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
  formatParameters = (struct _FORMAT_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;
  if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((7 << 16) | (3 << 14)) | (11 << 2))) {
    formatExParameters = (struct _FORMAT_EX_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;
  } else {
    formatExParameters = (void *)0;
  }
  {
  }
  badTrackBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
  driveMediaType = (DriveMediaLimits + DisketteExtension->DriveType)->HighestDriveMediaType;
  {
  while (1) {
    while_167_continue: /* CIL Label */ ;
    if ((int )(DriveMediaConstants + driveMediaType)->MediaType != (int )formatParameters->MediaType) {
      if ((int )driveMediaType > (int )(DriveMediaLimits + DisketteExtension->DriveType)->LowestDriveMediaType) {

      } else {
        goto while_167_break;
      }
    } else {
      goto while_167_break;
    }
    driveMediaType = (DRIVE_MEDIA_TYPE )((int )driveMediaType - 1);
  }
  while_167_break: /* CIL Label */ ;
  }
  driveMediaConstants = DriveMediaConstants + driveMediaType;
  DisketteExtension->MediaType = formatParameters->MediaType;
  DisketteExtension->DriveMediaType = driveMediaType;
  DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + driveMediaType);
  if (formatExParameters) {
    DisketteExtension->DriveMediaConstants.SectorsPerTrack = (unsigned char )formatExParameters->SectorsPerTrack;
    DisketteExtension->DriveMediaConstants.FormatGapLength = (unsigned char )formatExParameters->FormatGapLength;
  } else {

  }
  driveMediaConstants = & DisketteExtension->DriveMediaConstants;
  DisketteExtension->BytesPerSector = driveMediaConstants->BytesPerSector;
  DisketteExtension->ByteCapacity = (((int )driveMediaConstants->BytesPerSector * (int )driveMediaConstants->SectorsPerTrack) * (1 + (int )driveMediaConstants->MaximumTrack)) * (int )driveMediaConstants->NumberOfHeads;
  currentTrack = (unsigned char )(formatParameters->StartCylinderNumber * (ULONG )driveMediaConstants->NumberOfHeads + formatParameters->StartHeadNumber);
  endTrack = (unsigned char )(formatParameters->EndCylinderNumber * (ULONG )driveMediaConstants->NumberOfHeads + formatParameters->EndHeadNumber);
  {
  }
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
    {
    FlHdbit(DisketteExtension);
    }
  } else {

  }
  if ((int )DisketteExtension->LastDriveMediaType != (int )driveMediaType) {
    {
    ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
    }
    if (! (ntStatus >= 0L)) {
      return (ntStatus);
    } else {

    }
  } else {

  }
  DisketteExtension->IsReadOnly = 0;
  {
  while (1) {
    while_169_continue: /* CIL Label */ ;
    DisketteExtension->FifoBuffer[0] = 16;
    DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
    DisketteExtension->FifoBuffer[2] = (unsigned char )((int )currentTrack / (int )driveMediaConstants->NumberOfHeads << (int )driveMediaConstants->CylinderShift);
    {
    }
    {
    ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer, DisketteExtension->FifoBuffer,
                              (void *)0, 0, 0);
    }
    if (ntStatus >= 0L) {
      if ((int )DisketteExtension->FifoBuffer[0] & 32) {
        if ((int )DisketteExtension->FifoBuffer[1] == (int )((unsigned char )((int )currentTrack / (int )driveMediaConstants->NumberOfHeads << (int )driveMediaConstants->CylinderShift))) {
          {
          headSettleTime.__annonCompField1.LowPart = - (10000 * (int )driveMediaConstants->HeadSettleTime);
          headSettleTime.__annonCompField1.HighPart = -1;
          KeDelayExecutionThread(0, 0, & headSettleTime);
          }
          if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {

          } else {
            {
            DisketteExtension->FifoBuffer[0] = 84;
            DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
            ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                      DisketteExtension->FifoBuffer, (void *)0, 0,
                                      0);
            }
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
        }
        DisketteExtension->HardwareFailed = 1;
        ntStatus = -1073741464L;
      }
    } else {

    }
    if (! (ntStatus >= 0L)) {
      {
      }
      return (ntStatus);
    } else {

    }
    whichSector = 0;
    {
    while (1) {
      while_173_continue: /* CIL Label */ ;
      if ((int )whichSector < (int )driveMediaConstants->SectorsPerTrack) {

      } else {
        goto while_173_break;
      }
      *(DisketteExtension->IoBuffer + (int )whichSector * 4) = (int )currentTrack / (int )driveMediaConstants->NumberOfHeads;
      *(DisketteExtension->IoBuffer + ((int )whichSector * 4 + 1)) = (int )currentTrack % (int )driveMediaConstants->NumberOfHeads;
      if (formatExParameters) {
        *(DisketteExtension->IoBuffer + ((int )whichSector * 4 + 2)) = (unsigned char )formatExParameters->SectorNumber[whichSector];
      } else {
        *(DisketteExtension->IoBuffer + ((int )whichSector * 4 + 2)) = (int )whichSector + 1;
      }
      *(DisketteExtension->IoBuffer + ((int )whichSector * 4 + 3)) = driveMediaConstants->SectorLengthCode;
      {
      }
      whichSector = (UCHAR )((int )whichSector + 1);
    }
    while_173_break: /* CIL Label */ ;
    }
    retryCount = 0;
    {
    while (1) {
      while_175_continue: /* CIL Label */ ;
      length = driveMediaConstants->BytesPerSector;
      DisketteExtension->FifoBuffer[0] = 71;
      DisketteExtension->FifoBuffer[1] = (unsigned char )(((int )currentTrack % (int )driveMediaConstants->NumberOfHeads << 2) | (int )DisketteExtension->DeviceUnit);
      DisketteExtension->FifoBuffer[2] = driveMediaConstants->SectorLengthCode;
      DisketteExtension->FifoBuffer[3] = driveMediaConstants->SectorsPerTrack;
      DisketteExtension->FifoBuffer[4] = driveMediaConstants->FormatGapLength;
      DisketteExtension->FifoBuffer[5] = driveMediaConstants->FormatFillCharacter;
      {
      }
      {
      ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                DisketteExtension->FifoBuffer, DisketteExtension->IoBufferMdl,
                                0, length);
      }
      if (! (ntStatus >= 0L)) {
        {
        }
      } else {

      }
      if (ntStatus >= 0L) {
        if ((int )DisketteExtension->FifoBuffer[0] & 208) {
          goto _L___0;
        } else {
          if ((int )DisketteExtension->FifoBuffer[1] & 16) {
            goto _L___0;
          } else {
            if ((int )DisketteExtension->FifoBuffer[2] != 0) {
              _L___0: /* CIL Label */ 
              {
              }
              {
              DisketteExtension->HardwareFailed = 1;
              ntStatus = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
              }
            } else {

            }
          }
        }
      } else {

      }
      if (! (ntStatus >= 0L)) {
        tmp = retryCount;
        retryCount = (UCHAR )((int )retryCount + 1);
        if (tmp < 3) {

        } else {
          goto while_175_break;
        }
      } else {
        goto while_175_break;
      }
    }
    while_175_break: /* CIL Label */ ;
    }
    if (! (ntStatus >= 0L)) {
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
        {
        DisketteExtension->FifoBuffer[0] = 14;
        DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
        ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                  DisketteExtension->FifoBuffer, (void *)0, 0, 0);
        }
        if (! (ntStatus >= 0L)) {
          {
          }
          return (ntStatus);
        } else {

        }
        if ((int )DisketteExtension->FifoBuffer[0] & 32) {
          driveStatus = 127;
        } else {
          driveStatus = 128;
        }
      } else {
        {
        ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, ((7 << 16) | (776 << 2)) | 3,
                                 & fdcDiskChangeParms);
        driveStatus = fdcDiskChangeParms.DriveStatus;
        }
      }
      if ((int )DisketteExtension->DriveType != 0) {
        if ((int )driveStatus & 128) {
          return (-1073741805L);
        } else {

        }
      } else {

      }
      {
      }
      if (badTrackBufferLength >= (unsigned long )((unsigned int )((int )numberOfBadTracks + 1) * sizeof(BAD_TRACK_NUMBER ))) {
        badTrackBuffer = (USHORT *)Irp->AssociatedIrp.SystemBuffer;
        *(badTrackBuffer + numberOfBadTracks) = (unsigned short )currentTrack;
      } else {
        bufferOverflow = 1;
      }
      numberOfBadTracks = (UCHAR )((int )numberOfBadTracks + 1);
    } else {

    }
    currentTrack = (UCHAR )((int )currentTrack + 1);
    if ((int )currentTrack <= (int )endTrack) {

    } else {
      goto while_169_break;
    }
  }
  while_169_break: /* CIL Label */ ;
  }
  if (ntStatus >= 0L) {
    if (bufferOverflow) {
      ntStatus = -2147483643L;
    } else {

    }
  } else {

  }
  return (ntStatus);
}
}
BOOLEAN FlCheckFormatParameters(PDISKETTE_EXTENSION DisketteExtension , PFORMAT_PARAMETERS FormatParameters ) 
{ PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  DRIVE_MEDIA_TYPE driveMediaType ;

  {
  driveMediaType = (DriveMediaLimits + DisketteExtension->DriveType)->HighestDriveMediaType;
  {
  while (1) {
    while_181_continue: /* CIL Label */ ;
    if ((int )(DriveMediaConstants + driveMediaType)->MediaType != (int )FormatParameters->MediaType) {
      if ((int )driveMediaType > (int )(DriveMediaLimits + DisketteExtension->DriveType)->LowestDriveMediaType) {

      } else {
        goto while_181_break;
      }
    } else {
      goto while_181_break;
    }
    driveMediaType = (DRIVE_MEDIA_TYPE )((int )driveMediaType - 1);
  }
  while_181_break: /* CIL Label */ ;
  }
  if ((int )(DriveMediaConstants + driveMediaType)->MediaType != (int )FormatParameters->MediaType) {
    return (0);
  } else {
    driveMediaConstants = DriveMediaConstants + driveMediaType;
    if (FormatParameters->StartHeadNumber > (unsigned long )((int )driveMediaConstants->NumberOfHeads - 1)) {
      return (0);
    } else {
      if (FormatParameters->EndHeadNumber > (unsigned long )((int )driveMediaConstants->NumberOfHeads - 1)) {
        return (0);
      } else {
        if (FormatParameters->StartCylinderNumber > (ULONG )driveMediaConstants->MaximumTrack) {
          return (0);
        } else {
          if (FormatParameters->EndCylinderNumber > (ULONG )driveMediaConstants->MaximumTrack) {
            return (0);
          } else {
            if (FormatParameters->EndCylinderNumber < FormatParameters->StartCylinderNumber) {
              return (0);
            } else {
              if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                if ((int )FormatParameters->MediaType == 6) {
                  return (0);
                } else {
                  if ((int )FormatParameters->MediaType == 7) {
                    return (0);
                  } else {
                    if ((int )FormatParameters->MediaType == 8) {
                      return (0);
                    } else {
                      if ((int )FormatParameters->MediaType == 9) {
                        return (0);
                      } else {
                        if ((int )FormatParameters->MediaType == 10) {
                          return (0);
                        } else {

                        }
                      }
                    }
                  }
                }
              } else {

              }
              return (1);
            }
          }
        }
      }
    }
  }
}
}
NTSTATUS FlIssueCommand(PDISKETTE_EXTENSION DisketteExtension , PUCHAR FifoInBuffer ,
                        PUCHAR FifoOutBuffer , PMDL IoMdl , ULONG IoOffset , ULONG TransferBytes ) 
{ NTSTATUS ntStatus ;
  ISSUE_FDC_COMMAND_PARMS issueCommandParms ;

  {
  issueCommandParms.FifoInBuffer = FifoInBuffer;
  issueCommandParms.FifoOutBuffer = FifoOutBuffer;
  issueCommandParms.IoHandle = (void *)IoMdl;
  issueCommandParms.IoOffset = IoOffset;
  issueCommandParms.TransferBytes = TransferBytes;
  issueCommandParms.TimeOut = 4;
  {
  }
  {
  ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, ((7 << 16) | (771 << 2)) | 3,
                           & issueCommandParms);
  }
  if (ntStatus == -1073741661L) {
    DisketteExtension->HardwareFailed = 1;
  } else {
    if (ntStatus == -1073741464L) {
      DisketteExtension->HardwareFailed = 1;
    } else {

    }
  }
  return (ntStatus);
}
}
NTSTATUS FlInitializeControllerHardware(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;

  {
  {
  ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, ((7 << 16) | (773 << 2)) | 3,
                           (void *)0);
  }
  if (ntStatus >= 0L) {
    if ((int )DisketteExtension->PerpendicularMode != 0) {
      {
      DisketteExtension->FifoBuffer[0] = 21;
      DisketteExtension->FifoBuffer[1] = (unsigned char )(128 | ((int )DisketteExtension->PerpendicularMode << 2));
      ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                DisketteExtension->FifoBuffer, (void *)0, 0, 0);
      }
    } else {

    }
  } else {

  }
  return (ntStatus);
}
}
NTSTATUS FlFdcDeviceIo(PDEVICE_OBJECT DeviceObject , ULONG Ioctl , PVOID Data ) 
{ NTSTATUS ntStatus ;
  PIRP irp ;
  PIO_STACK_LOCATION irpStack ;
  KEVENT doneEvent ;
  IO_STATUS_BLOCK ioStatus ;

  {
  {
  }
  {
/*   KeInitializeEvent(& doneEvent, 0, 0); */ /* INLINED */
  irp = IoBuildDeviceIoControlRequest(Ioctl, DeviceObject, (void *)0, 0, (void *)0,
                                      0, 1, & doneEvent, & ioStatus);
  }
  if ((unsigned int )irp == (unsigned int )((void *)0)) {
    {
    }
    return (-1073741670L);
  } else {

  }
  {
  irpStack = irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
  irpStack->Parameters.DeviceIoControl.Type3InputBuffer = Data;
  ntStatus = IofCallDriver(DeviceObject, irp);
  }
  if (ntStatus == 259L) {
    {
    KeWaitForSingleObject(& doneEvent, 5, 0, 0, (void *)0);
    ntStatus = ioStatus.__annonCompField4.Status;
    }
  } else {

  }
  return (ntStatus);
}
}
NTSTATUS FlHdbit(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;
  SHORT st5 ;
  BOOLEAN media144MB ;
  BOOLEAN mediaUpTo120MB ;
  BOOLEAN supportDrive ;
  SET_HD_BIT_PARMS setHdBitParameter ;

  {
  st5 = 0;
  media144MB = 0;
  mediaUpTo120MB = 0;
  supportDrive = 1;
  {
  }
  if (DisketteExtension->DriveMediaType == 18) {
    goto switch_186_18;
  } else {
    if (DisketteExtension->DriveMediaType == 16) {
      goto switch_186_16;
    } else {
      if (DisketteExtension->DriveMediaType == 17) {
        goto switch_186_17;
      } else {
        if (DisketteExtension->DriveMediaType == 12) {
          goto switch_186_12;
        } else {
          if (DisketteExtension->DriveMediaType == 13) {
            goto switch_186_13;
          } else {
            if (DisketteExtension->DriveMediaType == 19) {
              goto switch_186_19;
            } else {
              if (DisketteExtension->DriveMediaType == 20) {
                goto switch_186_20;
              } else {
                if (DisketteExtension->DriveMediaType == 0) {
                  goto switch_186_0;
                } else {
                  if (DisketteExtension->DriveMediaType == 1) {
                    goto switch_186_1;
                  } else {
                    if (DisketteExtension->DriveMediaType == 2) {
                      goto switch_186_2;
                    } else {
                      if (DisketteExtension->DriveMediaType == 3) {
                        goto switch_186_3;
                      } else {
                        if (DisketteExtension->DriveMediaType == 4) {
                          goto switch_186_4;
                        } else {
                          if (DisketteExtension->DriveMediaType == 5) {
                            goto switch_186_5;
                          } else {
                            if (DisketteExtension->DriveMediaType == 6) {
                              goto switch_186_6;
                            } else {
                              if (DisketteExtension->DriveMediaType == 7) {
                                goto switch_186_7;
                              } else {
                                if (DisketteExtension->DriveMediaType == 8) {
                                  goto switch_186_8;
                                } else {
                                  if (DisketteExtension->DriveMediaType == 9) {
                                    goto switch_186_9;
                                  } else {
                                    if (DisketteExtension->DriveMediaType == 10) {
                                      goto switch_186_10;
                                    } else {
                                      if (DisketteExtension->DriveMediaType == 11) {
                                        goto switch_186_11;
                                      } else {
                                        if (DisketteExtension->DriveMediaType == 14) {
                                          goto switch_186_14;
                                        } else {
                                          if (DisketteExtension->DriveMediaType == 15) {
                                            goto switch_186_15;
                                          } else {
                                            {
                                            goto switch_186_default;
                                            if (0) {
                                              switch_186_18: /* CIL Label */ 
                                              media144MB = 1;
                                              switch_186_16: /* CIL Label */ ;
                                              switch_186_17: /* CIL Label */ ;
                                              switch_186_12: /* CIL Label */ ;
                                              switch_186_13: /* CIL Label */ ;
                                              switch_186_19: /* CIL Label */ ;
                                              switch_186_20: /* CIL Label */ 
                                              mediaUpTo120MB = 1;
                                              switch_186_0: /* CIL Label */ ;
                                              switch_186_1: /* CIL Label */ ;
                                              switch_186_2: /* CIL Label */ ;
                                              switch_186_3: /* CIL Label */ ;
                                              switch_186_4: /* CIL Label */ ;
                                              switch_186_5: /* CIL Label */ ;
                                              switch_186_6: /* CIL Label */ ;
                                              switch_186_7: /* CIL Label */ ;
                                              switch_186_8: /* CIL Label */ ;
                                              switch_186_9: /* CIL Label */ ;
                                              switch_186_10: /* CIL Label */ ;
                                              switch_186_11: /* CIL Label */ ;
                                              switch_186_14: /* CIL Label */ ;
                                              switch_186_15: /* CIL Label */ ;
                                              goto switch_186_break;
                                              switch_186_default: /* CIL Label */ 
                                              mediaUpTo120MB = 1;
                                              goto switch_186_break;
                                            } else {
                                              switch_186_break: /* CIL Label */ ;
                                            }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  setHdBitParameter.Media144MB = media144MB;
  setHdBitParameter.More120MB = mediaUpTo120MB;
  setHdBitParameter.DeviceUnit = DisketteExtension->DeviceUnit;
  if ((int )DisketteExtension->DriveType == 3) {
    setHdBitParameter.DriveType144MB = 1;
  } else {
    setHdBitParameter.DriveType144MB = 0;
  }
  {
  ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, ((7 << 16) | (785 << 2)) | 3,
                           & setHdBitParameter);
  }
  if (! (ntStatus >= 0L)) {
    return (ntStatus);
  } else {

  }
  if (setHdBitParameter.ChangedHdBit) {
    {
    ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
    }
  } else {

  }
  return (ntStatus);
}
}
NTSTATUS FloppyQueueRequest(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) 
{ KIRQL oldIrql ;
  NTSTATUS ntStatus ;
  LONG tmp ;

  {
  {
/*   ExAcquireFastMutex(PagingMutex); */ /* INLINED */
  PagingReferenceCount += 1UL;
  }
  if (PagingReferenceCount == 1UL) {
    {
/*     MmResetDriverPaging(& DriverEntry); */ /* INLINED */
    }
  } else {

  }
  {
/*   ExReleaseFastMutex(PagingMutex); */ /* INLINED */
  oldIrql = KfAcquireSpinLock(& DisketteExtension->FlCancelSpinLock);
  InterlockedExchange((LONG *)((PVOID *)(& Irp->CancelRoutine)), (long )((void *)(& FloppyCancelQueuedRequest)));
  }
  if (Irp->Cancel) {
    {
    tmp = InterlockedExchange((LONG *)((PVOID *)(& Irp->CancelRoutine)), (long )((void *)0));
    }
    if ((void (*)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ))((void *)tmp)) {
      {
      Irp->IoStatus.__annonCompField4.Status = -1073741536L;
      myStatus = -1073741536L;
      Irp->IoStatus.Information = 0;
/*       KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql); */ /* INLINED */
      IofCompleteRequest(Irp, 0);
/*       ExAcquireFastMutex(PagingMutex); */ /* INLINED */
      PagingReferenceCount -= 1UL;
      }
      if (PagingReferenceCount == 0UL) {
        {
/* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
        }
      } else {

      }
      {
/*       ExReleaseFastMutex(PagingMutex); */ /* INLINED */
      ntStatus = -1073741536L;
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    Irp->IoStatus.__annonCompField4.Status = 259L;
    myStatus = 259L;
    (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control = (int )(Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control | 1;
    if (pended == 0) {
      pended = 1;
    } else {
      {
      errorFn();
      }
    }
    {
    ExfInterlockedInsertTailList(& DisketteExtension->NewRequestQueue, & Irp->Tail.Overlay.__annonCompField17.ListEntry,
                                 & DisketteExtension->NewRequestQueueSpinLock);
/*     KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql); */ /* INLINED */
    ntStatus = 259L;
    }
  }
  return (ntStatus);
}
}
void FloppyCancelQueuedRequest(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDISKETTE_EXTENSION disketteExtension ;
  KIRQL oldIrql ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_Flink ;

  {
  disketteExtension = DeviceObject->DeviceExtension;
  {
  }
  {
  oldIrql = KfAcquireSpinLock(& disketteExtension->FlCancelSpinLock);
  Irp->IoStatus.__annonCompField4.Status = -1073741536L;
  myStatus = -1073741536L;
  Irp->IoStatus.Information = 0;
  }
  if (Irp->Tail.Overlay.__annonCompField17.ListEntry.Flink) {
    _EX_Flink = Irp->Tail.Overlay.__annonCompField17.ListEntry.Flink;
    _EX_Blink = Irp->Tail.Overlay.__annonCompField17.ListEntry.Blink;
    _EX_Blink->Flink = _EX_Flink;
    _EX_Flink->Blink = _EX_Blink;
  } else {

  }
  {
/*   KfReleaseSpinLock(& disketteExtension->FlCancelSpinLock, oldIrql); */ /* INLINED */
/*   IoReleaseCancelSpinLock(Irp->CancelIrql); */ /* INLINED */
  IofCompleteRequest(Irp, 0);
/*   ExAcquireFastMutex(PagingMutex); */ /* INLINED */
  PagingReferenceCount -= 1UL;
  }
  if (PagingReferenceCount == 0UL) {
    {
/* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
    }
  } else {

  }
  {
/*   ExReleaseFastMutex(PagingMutex); */ /* INLINED */
  }
  return;
}
}
void FloppyProcessQueuedRequests(PDISKETTE_EXTENSION DisketteExtension ) 
{ KIRQL oldIrql ;
  PLIST_ENTRY headOfList ;
  PIRP currentIrp ;
  PIO_STACK_LOCATION irpSp ;
  LONG tmp ;

  {
  {
  oldIrql = KfAcquireSpinLock(& DisketteExtension->FlCancelSpinLock);
  }
  {
  while (1) {
    while_188_continue: /* CIL Label */ ;
    {
    headOfList = ExfInterlockedRemoveHeadList(& DisketteExtension->NewRequestQueue,
                                              & DisketteExtension->NewRequestQueueSpinLock);
    }
    if ((unsigned int )headOfList != (unsigned int )((void *)0)) {

    } else {
      goto while_188_break;
    }
    {
    currentIrp = (IRP *)((CHAR *)headOfList - (unsigned long )(& ((IRP *)0)->Tail.Overlay.__annonCompField17.ListEntry));
    tmp = InterlockedExchange((LONG *)((PVOID *)(& currentIrp->CancelRoutine)), (long )((void *)0));
    }
    if ((void (*)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ))((void *)tmp)) {
      irpSp = currentIrp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
    } else {
      currentIrp->Tail.Overlay.__annonCompField17.ListEntry.Flink = (void *)0;
      currentIrp = (void *)0;
    }
    {
/*     KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql); */ /* INLINED */
    }
    if (currentIrp) {
      if (DisketteExtension->IsRemoved) {
        {
        currentIrp->IoStatus.Information = 0;
        currentIrp->IoStatus.__annonCompField4.Status = -1073741738L;
        IofCompleteRequest(currentIrp, 0);
        }
      } else {
        if (irpSp->MajorFunction == 3) {
          goto switch_189_3;
        } else {
          if (irpSp->MajorFunction == 4) {
            goto switch_189_4;
          } else {
            if (irpSp->MajorFunction == 14) {
              goto switch_189_14;
            } else {
              {
              goto switch_189_default;
              if (0) {
                switch_189_3: /* CIL Label */ ;
                switch_189_4: /* CIL Label */ 
                {
                FloppyReadWrite(DisketteExtension->DeviceObject, currentIrp);
                }
                goto switch_189_break;
                switch_189_14: /* CIL Label */ 
                {
                FloppyDeviceControl(DisketteExtension->DeviceObject, currentIrp);
                }
                goto switch_189_break;
                switch_189_default: /* CIL Label */ 
                {
                currentIrp->IoStatus.Information = 0;
                currentIrp->IoStatus.__annonCompField4.Status = -1073741823L;
                IofCompleteRequest(currentIrp, 0);
                }
              } else {
                switch_189_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
    } else {

    }
    if (currentIrp) {
      {
/*       ExAcquireFastMutex(PagingMutex); */ /* INLINED */
      PagingReferenceCount -= 1UL;
      }
      if (PagingReferenceCount == 0UL) {
        {
/* MmPageEntireDriver(& DriverEntry); */ /* INLINED */
        }
      } else {

      }
      {
/*       ExReleaseFastMutex(PagingMutex); */ /* INLINED */
      }
    } else {

    }
    {
    oldIrql = KfAcquireSpinLock(& DisketteExtension->FlCancelSpinLock);
    }
  }
  while_188_break: /* CIL Label */ ;
  }
  {
/*   KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql); */ /* INLINED */
  }
  return;
}
}
#pragma once
#pragma once
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable:4035)
#pragma warning(pop)
#pragma once
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(push)
#pragma warning(disable:4035)
#pragma warning(pop)
#pragma warning(disable:4035)
#pragma warning(push)
#pragma warning(disable:4164)
#pragma function(_enable)
#pragma function(_disable)
#pragma warning(pop)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4103)
#pragma warning(disable:4200)
#pragma warning(default:4200)
IRP *pirp  ;
void stub_driver_init(void) 
{ 

  {
  s = NP;
  pended = 0;
  compFptr = 0;
  compRegistered = 0;
  lowerDriverReturn = 0;
  setEventCalled = 0;
  customIrp = 0;
  return;
}
}
int main(void) 
{ DRIVER_OBJECT d ;
  UNICODE_STRING u ;
  NTSTATUS status ;
  int we_should_unload = __VERIFIER_nondet_int() ;
  IRP irp ;
  int __BLAST_NONDET = __VERIFIER_nondet_int() ;
  int irp_choice = __VERIFIER_nondet_int() ;
  DEVICE_OBJECT devobj ;
  d.DriverExtension = malloc(sizeof (struct _DRIVER_EXTENSION));

  {
  {
  status = 0;
  pirp = & irp;
  _BLAST_init();
  status = DriverEntry(& d, & u);
  }
  if (status >= 0L) {
    s = NP;
    customIrp = 0;
    setEventCalled = customIrp;
    lowerDriverReturn = setEventCalled;
    compRegistered = lowerDriverReturn;
    compFptr = compRegistered;
    pended = compFptr;
    pirp->IoStatus.__annonCompField4.Status = 0L;
    myStatus = 0L;
    if (irp_choice == 0) {
      pirp->IoStatus.__annonCompField4.Status = -1073741637L;
      myStatus = -1073741637L;
    } else {

    }
    {
    stub_driver_init();
    }
    if (! (status >= 0L)) {
      return (-1);
    } else {

    }
    if (__BLAST_NONDET == 0) {
      goto switch_190_0;
    } else {
      if (__BLAST_NONDET == 1) {
        goto switch_190_1;
      } else {
        if (__BLAST_NONDET == 2) {
          goto switch_190_2;
        } else {
          if (__BLAST_NONDET == 3) {
            goto switch_190_3;
          } else {
            if (__BLAST_NONDET == 4) {
              goto switch_190_4;
            } else {
              {
              goto switch_190_default;
              if (0) {
                switch_190_0: /* CIL Label */ 
                {
                status = FloppyCreateClose(& devobj, pirp);
                }
                goto switch_190_break;
                switch_190_1: /* CIL Label */ 
                {
                status = FloppyCreateClose(& devobj, pirp);
                }
                goto switch_190_break;
                switch_190_2: /* CIL Label */ 
                {
                status = FloppyDeviceControl(& devobj, pirp);
                }
                goto switch_190_break;
                switch_190_3: /* CIL Label */ 
                {
                status = FloppyPnp(& devobj, pirp);
                }
                goto switch_190_break;
                switch_190_4: /* CIL Label */ 
                {
                status = FloppyPower(& devobj, pirp);
                }
                goto switch_190_break;
                switch_190_default: /* CIL Label */ ;
                return (-1);
              } else {
                switch_190_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
    }
    if (we_should_unload) {
      {
      FloppyUnload(& d);
      }
    } else {

    }
  } else {

  }
  if (pended == 1) {
    if (s == NP) {
      s = NP;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    if (pended == 1) {
      if (s == MPR3) {
        s = MPR3;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (s == UNLOADED) {

      } else {
        if (status == -1L) {

        } else {
          if (s != SKIP2) {
            if (s != IPC) {
              if (s != DC) {
                {
                errorFn();
                }
              } else {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            if (pended == 1) {
              if (status != 259L) {
                status = 0;
              } else {

              }
            } else {
              if (s == DC) {
                if (status == 259L) {
                  {
                  errorFn();
                  }
                } else {

                }
              } else {
                if (status != (NTSTATUS )lowerDriverReturn) {
                  {
                  errorFn();
                  }
                } else {

                }
              }
            }
          }
        }
      }
    }
  }
  status = 0;
  return (status);
}
}
char _SLAM_alloc_dummy  ;
  void ExAcquireFastMutex(PFAST_MUTEX FastMutex ) ;
void ExAcquireFastMutex(PFAST_MUTEX FastMutex ) 
{ 

  {
  return;
}
}
  void ExReleaseFastMutex(PFAST_MUTEX FastMutex ) ;
void ExReleaseFastMutex(PFAST_MUTEX FastMutex ) 
{ 

  {
  return;
}
}
  PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType ,
                                                                                            SIZE_T NumberOfBytes ,
                                                                                            ULONG Tag ) ;
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType , SIZE_T NumberOfBytes ,
                                                            ULONG Tag ) 
{ PVOID x ;
  char *tmp ;

  {
  {
  tmp = malloc(NumberOfBytes);
  x = tmp;
  }
  return (x);
}
}
  void ExFreePool(PVOID P ) ;
void ExFreePool(PVOID P ) 
{ 

  {
  return;
}
}
  PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead ,
                                                                                                          PLIST_ENTRY ListEntry ,
                                                                                                          PKSPIN_LOCK Lock ) ;
PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead ,
                                                                          PLIST_ENTRY ListEntry ,
                                                                          PKSPIN_LOCK Lock ) 
{ 

  {
  return ((void *)0);
}
}
  PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead ,
                                                                                                          PLIST_ENTRY ListEntry ,
                                                                                                          PKSPIN_LOCK Lock ) ;
PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead ,
                                                                          PLIST_ENTRY ListEntry ,
                                                                          PKSPIN_LOCK Lock ) 
{ 

  {
  return ((void *)0);
}
}
  PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead ,
                                                                                                          PKSPIN_LOCK Lock ) ;
PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead ,
                                                                          PKSPIN_LOCK Lock ) 
{ 

  {
  return ((void *)0);
}
}
  PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length ,
                                                   BOOLEAN SecondaryBuffer , BOOLEAN ChargeQuota ,
                                                   PIRP Irp ) ;
PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length , BOOLEAN SecondaryBuffer ,
                   BOOLEAN ChargeQuota , PIRP Irp ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;
  char *tmp ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_191_0;
  } else {
    {
    goto switch_191_default;
    if (0) {
      switch_191_0: /* CIL Label */ 
      {
      tmp = & _SLAM_alloc_dummy; /* malloc(sizeof(MDL )); */ /* INLINED */
      }
      return ((void *)tmp);
      switch_191_default: /* CIL Label */ ;
      return ((void *)0);
    } else {
      switch_191_break: /* CIL Label */ ;
    }
    }
  }
}
}
  PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice ,
                                                                           PDEVICE_OBJECT TargetDevice ) ;
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice , PDEVICE_OBJECT TargetDevice ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_192_0;
  } else {
    {
    goto switch_192_default;
    if (0) {
      switch_192_0: /* CIL Label */ ;
      return (TargetDevice);
      switch_192_default: /* CIL Label */ ;
      return ((void *)0);
    } else {
      switch_192_break: /* CIL Label */ ;
    }
    }
  }
}
}
  PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction ,
                                                                   PDEVICE_OBJECT DeviceObject ,
                                                                   PVOID Buffer ,
                                                                   ULONG Length ,
                                                                   PLARGE_INTEGER StartingOffset ,
                                                                   PIO_STATUS_BLOCK IoStatusBlock ) ;
PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction , PDEVICE_OBJECT DeviceObject ,
                                   PVOID Buffer , ULONG Length , PLARGE_INTEGER StartingOffset ,
                                   PIO_STATUS_BLOCK IoStatusBlock ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;
  char *tmp ;

  {
  customIrp = 1;
  if (__BLAST_NONDET == 0) {
    goto switch_193_0;
  } else {
    {
    goto switch_193_default;
    if (0) {
      switch_193_0: /* CIL Label */ 
      {
      tmp = & _SLAM_alloc_dummy; /* malloc(sizeof(IRP )); */ /* INLINED */
      }
      return ((void *)tmp);
      switch_193_default: /* CIL Label */ ;
      return ((void *)0);
    } else {
      switch_193_break: /* CIL Label */ ;
    }
    }
  }
}
}
  PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode ,
                                                                   PDEVICE_OBJECT DeviceObject ,
                                                                   PVOID InputBuffer ,
                                                                   ULONG InputBufferLength ,
                                                                   PVOID OutputBuffer ,
                                                                   ULONG OutputBufferLength ,
                                                                   BOOLEAN InternalDeviceIoControl ,
                                                                   PKEVENT Event ,
                                                                   PIO_STATUS_BLOCK IoStatusBlock ) ;
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode , PDEVICE_OBJECT DeviceObject ,
                                   PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                   ULONG OutputBufferLength , BOOLEAN InternalDeviceIoControl ,
                                   PKEVENT Event , PIO_STATUS_BLOCK IoStatusBlock ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;
  char *tmp ;

  {
  customIrp = 1;
  if (__BLAST_NONDET == 0) {
    goto switch_194_0;
  } else {
    {
    goto switch_194_default;
    if (0) {
      switch_194_0: /* CIL Label */ 
      {
      tmp = & _SLAM_alloc_dummy; /* malloc(sizeof(IRP )); */ /* INLINED */
      }
      return ((void *)tmp);
      switch_194_default: /* CIL Label */ ;
      return ((void *)0);
    } else {
      switch_194_break: /* CIL Label */ ;
    }
    }
  }
}
}
  NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject ,
                                                        ULONG DeviceExtensionSize ,
                                                        PUNICODE_STRING DeviceName ,
                                                        ULONG DeviceType , ULONG DeviceCharacteristics ,
                                                        BOOLEAN Exclusive , PDEVICE_OBJECT *DeviceObject ) ;
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject , ULONG DeviceExtensionSize ,
                        PUNICODE_STRING DeviceName , ULONG DeviceType , ULONG DeviceCharacteristics ,
                        BOOLEAN Exclusive , PDEVICE_OBJECT *DeviceObject ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;
  char *tmp ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_195_0;
  } else {
    {
    goto switch_195_default;
    if (0) {
      switch_195_0: /* CIL Label */ 
      {
      tmp = & _SLAM_alloc_dummy; /* malloc(sizeof(DEVICE_OBJECT )); */ /* INLINED */
      *DeviceObject = (void *)tmp;
      }
      return (0L);
      switch_195_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_195_break: /* CIL Label */ ;
    }
    }
  }
}
}
  NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName ,
                                                              PUNICODE_STRING DeviceName ) ;
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName , PUNICODE_STRING DeviceName ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_196_0;
  } else {
    {
    goto switch_196_default;
    if (0) {
      switch_196_0: /* CIL Label */ ;
      return (0L);
      switch_196_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_196_break: /* CIL Label */ ;
    }
    }
  }
}
}
  void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) ;
void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) 
{ 

  {
  return;
}
}
  NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) ;
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_197_0;
  } else {
    {
    goto switch_197_default;
    if (0) {
      switch_197_0: /* CIL Label */ ;
      return (0L);
      switch_197_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_197_break: /* CIL Label */ ;
    }
    }
  }
}
}
  void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) ;
void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) 
{ 

  {
  return;
}
}
  void IoFreeIrp(PIRP Irp ) ;
void IoFreeIrp(PIRP Irp ) 
{ 

  {
  return;
}
}
  void IoFreeMdl(PMDL Mdl ) ;
void IoFreeMdl(PMDL Mdl ) 
{ 

  {
  return;
}
}
  PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) ;
PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) 
{ char *tmp ;

  {
  {
  tmp = & _SLAM_alloc_dummy; /* malloc(sizeof(CONFIGURATION_INFORMATION )); */ /* INLINED */
  }
  return ((void *)tmp);
}
}
  NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType ,
                                                                  PULONG BusNumber ,
                                                                  PCONFIGURATION_TYPE ControllerType ,
                                                                  PULONG ControllerNumber ,
                                                                  PCONFIGURATION_TYPE PeripheralType ,
                                                                  PULONG PeripheralNumber ,
                                                                  NTSTATUS (*CalloutRoutine)(PVOID Context ,
                                                                                             PUNICODE_STRING PathName ,
                                                                                             INTERFACE_TYPE BusType ,
                                                                                             ULONG BusNumber ,
                                                                                             PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                                                                                             CONFIGURATION_TYPE ControllerType ,
                                                                                             ULONG ControllerNumber ,
                                                                                             PKEY_VALUE_FULL_INFORMATION *ControllerInformation ,
                                                                                             CONFIGURATION_TYPE PeripheralType ,
                                                                                             ULONG PeripheralNumber ,
                                                                                             PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ,
                                                                  PVOID Context ) ;
NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType , PULONG BusNumber , PCONFIGURATION_TYPE ControllerType ,
                                  PULONG ControllerNumber , PCONFIGURATION_TYPE PeripheralType ,
                                  PULONG PeripheralNumber , NTSTATUS (*CalloutRoutine)(PVOID Context ,
                                                                                       PUNICODE_STRING PathName ,
                                                                                       INTERFACE_TYPE BusType ,
                                                                                       ULONG BusNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                                                                                       CONFIGURATION_TYPE ControllerType ,
                                                                                       ULONG ControllerNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *ControllerInformation ,
                                                                                       CONFIGURATION_TYPE PeripheralType ,
                                                                                       ULONG PeripheralNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ,
                                  PVOID Context ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_198_0;
  } else {
    {
    goto switch_198_default;
    if (0) {
      switch_198_0: /* CIL Label */ ;
      return (0L);
      switch_198_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_198_break: /* CIL Label */ ;
    }
    }
  }
}
}
  NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject ,
                                                                                                   GUID const   *InterfaceClassGuid ,
                                                                                                   PUNICODE_STRING ReferenceString ,
                                                                                                   PUNICODE_STRING SymbolicLinkName ) ;
NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject ,
                                                                   GUID const   *InterfaceClassGuid ,
                                                                   PUNICODE_STRING ReferenceString ,
                                                                   PUNICODE_STRING SymbolicLinkName ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_199_0;
  } else {
    {
    goto switch_199_default;
    if (0) {
      switch_199_0: /* CIL Label */ ;
      return (0L);
      switch_199_default: /* CIL Label */ ;
      return (-1073741808L);
    } else {
      switch_199_break: /* CIL Label */ ;
    }
    }
  }
}
}
  void IoReleaseCancelSpinLock(KIRQL Irql ) ;
void IoReleaseCancelSpinLock(KIRQL Irql ) 
{ 

  {
  return;
}
}
  NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName ,
                                                                   BOOLEAN Enable ) ;
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName , BOOLEAN Enable ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_200_0;
  } else {
    {
    goto switch_200_default;
    if (0) {
      switch_200_0: /* CIL Label */ ;
      return (0L);
      switch_200_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_200_break: /* CIL Label */ ;
    }
    }
  }
}
}
  void IoSetHardErrorOrVerifyDevice(PIRP Irp , PDEVICE_OBJECT DeviceObject ) ;
void IoSetHardErrorOrVerifyDevice(PIRP Irp , PDEVICE_OBJECT DeviceObject ) 
{ 

  {
  return;
}
}
void stubMoreProcessingRequired(void) 
{ 

  {
  if (s == NP) {
    s = MPR1;
  } else {
    {
    errorFn();
    }
  }
  return;
}
}
  NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject ,
                                                                                        PIRP Irp ) ;
NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject ,
                                                        PIRP Irp ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;
  NTSTATUS returnVal2 ;
  int compRetStatus1 ;
  PVOID lcontext = __VERIFIER_nondet_pointer() ;
  NTSTATUS tmp ;

  {
  if (compRegistered) {
    {
    tmp = FloppyPnpComplete(DeviceObject, Irp, lcontext);
    compRetStatus1 = tmp;
    }
    if ((long )compRetStatus1 == -1073741802L) {
      {
      stubMoreProcessingRequired();
      }
    } else {

    }
  } else {

  }
  if (__BLAST_NONDET == 0) {
    goto switch_201_0;
  } else {
    if (__BLAST_NONDET == 1) {
      goto switch_201_1;
    } else {
      {
      goto switch_201_default;
      if (0) {
        switch_201_0: /* CIL Label */ 
        returnVal2 = 0L;
        goto switch_201_break;
        switch_201_1: /* CIL Label */ 
        returnVal2 = -1073741823L;
        goto switch_201_break;
        switch_201_default: /* CIL Label */ 
        returnVal2 = 259L;
        goto switch_201_break;
      } else {
        switch_201_break: /* CIL Label */ ;
      }
      }
    }
  }
  if (s == NP) {
    s = IPC;
    lowerDriverReturn = returnVal2;
  } else {
    if (s == MPR1) {
      if (returnVal2 == 259L) {
        s = MPR3;
        lowerDriverReturn = returnVal2;
      } else {
        s = NP;
        lowerDriverReturn = returnVal2;
      }
    } else {
      if (s == SKIP1) {
        s = SKIP2;
        lowerDriverReturn = returnVal2;
      } else {
        {
        errorFn();
        }
      }
    }
  }
  return (returnVal2);
}
}
  void IofCompleteRequest(PIRP Irp ,
                                                                                         CCHAR PriorityBoost ) ;
void IofCompleteRequest(PIRP Irp , CCHAR PriorityBoost ) 
{ 

  {
  if (s == NP) {
    s = DC;
  } else {
    {
    errorFn();
    }
  }
  return;
}
}
  KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock ) ;
KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock ) 
{ 

  {
  return ((unsigned char)0);
}
}
  NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode ,
                                                                BOOLEAN Alertable ,
                                                                PLARGE_INTEGER Interval ) ;
NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode , BOOLEAN Alertable , PLARGE_INTEGER Interval ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_202_0;
  } else {
    {
    goto switch_202_default;
    if (0) {
      switch_202_0: /* CIL Label */ ;
      return (0L);
      switch_202_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_202_break: /* CIL Label */ ;
    }
    }
  }
}
}
  void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type ,
                                                       BOOLEAN State ) ;
void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type , BOOLEAN State ) 
{ 

  {
  return;
}
}
  void KeInitializeSemaphore(PRKSEMAPHORE Semaphore ,
                                                           LONG Count , LONG Limit ) ;
void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG Count , LONG Limit ) 
{ 

  {
  return;
}
}
  void KeInitializeSpinLock(PKSPIN_LOCK SpinLock ) ;
void KeInitializeSpinLock(PKSPIN_LOCK SpinLock ) 
{ 

  {
  return;
}
}
  LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment ,
                                                        LONG Adjustment , BOOLEAN Wait ) ;
LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment , LONG Adjustment ,
                        BOOLEAN Wait ) 
{ LONG r = __VERIFIER_nondet_long() ;

  {
  return (r);
}
}
  void KfReleaseSpinLock(PKSPIN_LOCK SpinLock ,
                                                                                        KIRQL NewIrql ) ;
void KfReleaseSpinLock(PKSPIN_LOCK SpinLock , KIRQL NewIrql ) 
{ 

  {
  return;
}
}
  LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment ,
                                                BOOLEAN Wait ) ;
LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment , BOOLEAN Wait ) 
{ LONG l = __VERIFIER_nondet_long() ;

  {
  setEventCalled = 1;
  return (l);
}
}
  NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason ,
                                                               KPROCESSOR_MODE WaitMode ,
                                                               BOOLEAN Alertable ,
                                                               PLARGE_INTEGER Timeout ) ;
NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason , KPROCESSOR_MODE WaitMode ,
                               BOOLEAN Alertable , PLARGE_INTEGER Timeout ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (s == MPR3) {
    if (setEventCalled == 1) {
      s = NP;
      setEventCalled = 0;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (customIrp == 1) {
      s = NP;
      customIrp = 0;
    } else {
      if (s == MPR3) {
        {
        errorFn();
        }
      } else {

      }
    }
  }
  if (__BLAST_NONDET == 0) {
    goto switch_203_0;
  } else {
    {
    goto switch_203_default;
    if (0) {
      switch_203_0: /* CIL Label */ ;
      return (0L);
      switch_203_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_203_break: /* CIL Label */ ;
    }
    }
  }
}
}
  PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes ,
                                                                 PHYSICAL_ADDRESS HighestAcceptableAddress ) ;
PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes , PHYSICAL_ADDRESS HighestAcceptableAddress ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;
  char *tmp ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_204_0;
  } else {
    if (__BLAST_NONDET == 1) {
      goto switch_204_1;
    } else {
      if (0) {
        switch_204_0: /* CIL Label */ 
        {
        tmp = & _SLAM_alloc_dummy; /* malloc(NumberOfBytes); */ /* INLINED */
        }
        return (tmp);
        switch_204_1: /* CIL Label */ ;
        return ((void *)0);
      } else {
        switch_204_break: /* CIL Label */ ;
      }
    }
  }
  return ((void *)0);
}
}
  void MmFreeContiguousMemory(PVOID BaseAddress ) ;
void MmFreeContiguousMemory(PVOID BaseAddress ) 
{ 

  {
  return;
}
}
  PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList ,
                                                                   KPROCESSOR_MODE AccessMode ,
                                                                   MEMORY_CACHING_TYPE CacheType ,
                                                                   PVOID BaseAddress ,
                                                                   ULONG BugCheckOnFailure ,
                                                                   MM_PAGE_PRIORITY Priority ) ;
PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList , KPROCESSOR_MODE AccessMode ,
                                   MEMORY_CACHING_TYPE CacheType , PVOID BaseAddress ,
                                   ULONG BugCheckOnFailure , MM_PAGE_PRIORITY Priority ) 
{ 

  {
  return ((void *)0);
}
}
  PVOID MmPageEntireDriver(PVOID AddressWithinSection ) ;
PVOID MmPageEntireDriver(PVOID AddressWithinSection ) 
{ 

  {
  return ((void *)0);
}
}
  void MmResetDriverPaging(PVOID AddressWithinSection ) ;
void MmResetDriverPaging(PVOID AddressWithinSection ) 
{ 

  {
  return;
}
}
  void MmUnlockPages(PMDL MemoryDescriptorList ) ;
void MmUnlockPages(PMDL MemoryDescriptorList ) 
{ 

  {
  return;
}
}
  NTSTATUS ObReferenceObjectByHandle(HANDLE Handle ,
                                                                   ACCESS_MASK DesiredAccess ,
                                                                   POBJECT_TYPE ObjectType ,
                                                                   KPROCESSOR_MODE AccessMode ,
                                                                   PVOID *Object ,
                                                                   POBJECT_HANDLE_INFORMATION HandleInformation ) ;
NTSTATUS ObReferenceObjectByHandle(HANDLE Handle , ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType ,
                                   KPROCESSOR_MODE AccessMode , PVOID *Object , POBJECT_HANDLE_INFORMATION HandleInformation ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_205_0;
  } else {
    {
    goto switch_205_default;
    if (0) {
      switch_205_0: /* CIL Label */ ;
      return (0L);
      switch_205_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_205_break: /* CIL Label */ ;
    }
    }
  }
}
}
  void ObfDereferenceObject(PVOID Object ) ;
void ObfDereferenceObject(PVOID Object ) 
{ 

  {
  return;
}
}
  NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject ,
                                                      PIRP Irp ) ;
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;
  int compRetStatus ;
  NTSTATUS returnVal ;
  PVOID lcontext = __VERIFIER_nondet_pointer() ;
  NTSTATUS tmp ;

  {
  if (compRegistered) {
    {
    tmp = FloppyPnpComplete(DeviceObject, Irp, lcontext);
    compRetStatus = tmp;
    }
    if ((long )compRetStatus == -1073741802L) {
      {
      stubMoreProcessingRequired();
      }
    } else {

    }
  } else {

  }
  if (__BLAST_NONDET == 0) {
    goto switch_206_0;
  } else {
    if (__BLAST_NONDET == 1) {
      goto switch_206_1;
    } else {
      {
      goto switch_206_default;
      if (0) {
        switch_206_0: /* CIL Label */ 
        returnVal = 0L;
        goto switch_206_break;
        switch_206_1: /* CIL Label */ 
        returnVal = -1073741823L;
        goto switch_206_break;
        switch_206_default: /* CIL Label */ 
        returnVal = 259L;
        goto switch_206_break;
      } else {
        switch_206_break: /* CIL Label */ ;
      }
      }
    }
  }
  if (s == NP) {
    s = IPC;
    lowerDriverReturn = returnVal;
  } else {
    if (s == MPR1) {
      if (returnVal == 259L) {
        s = MPR3;
        lowerDriverReturn = returnVal;
      } else {
        s = NP;
        lowerDriverReturn = returnVal;
      }
    } else {
      if (s == SKIP1) {
        s = SKIP2;
        lowerDriverReturn = returnVal;
      } else {
        {
        errorFn();
        }
      }
    }
  }
  return (returnVal);
}
}
  void PoStartNextPowerIrp(PIRP Irp ) ;
void PoStartNextPowerIrp(PIRP Irp ) 
{ 

  {
  return;
}
}
  NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle ,
                                                              ULONG DesiredAccess ,
                                                              POBJECT_ATTRIBUTES ObjectAttributes ,
                                                              HANDLE ProcessHandle ,
                                                              PCLIENT_ID ClientId ,
                                                              void (*StartRoutine)(PVOID StartContext ) ,
                                                              PVOID StartContext ) ;
NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
                              HANDLE ProcessHandle , PCLIENT_ID ClientId , void (*StartRoutine)(PVOID StartContext ) ,
                              PVOID StartContext ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_207_0;
  } else {
    {
    goto switch_207_default;
    if (0) {
      switch_207_0: /* CIL Label */ ;
      return (0L);
      switch_207_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_207_break: /* CIL Label */ ;
    }
    }
  }
}
}
  NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) ;
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_208_0;
  } else {
    {
    goto switch_208_default;
    if (0) {
      switch_208_0: /* CIL Label */ ;
      return (0L);
      switch_208_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_208_break: /* CIL Label */ ;
    }
    }
  }
}
}
  NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString ,
                                                                                                      PANSI_STRING SourceString ,
                                                                                                      BOOLEAN AllocateDestinationString ) ;
NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString ,
                                                                      PANSI_STRING SourceString ,
                                                                      BOOLEAN AllocateDestinationString ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_209_0;
  } else {
    {
    goto switch_209_default;
    if (0) {
      switch_209_0: /* CIL Label */ ;
      return (0L);
      switch_209_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_209_break: /* CIL Label */ ;
    }
    }
  }
}
}
  SIZE_T RtlCompareMemory(void const   *Source1 ,
                                                                                        void const   *Source2 ,
                                                                                        SIZE_T Length ) ;
SIZE_T RtlCompareMemory(void const   *Source1 , void const   *Source2 ,
                                                        SIZE_T Length ) 
{ SIZE_T r = __VERIFIER_nondet_long() ;

  {
  return (r);
}
}
  void RtlCopyUnicodeString(PUNICODE_STRING DestinationString ,
                                                                                          PUNICODE_STRING SourceString ) ;
void RtlCopyUnicodeString(PUNICODE_STRING DestinationString ,
                                                          PUNICODE_STRING SourceString ) 
{ 

  {
  return;
}
}
  NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo ,
                                                                                                PCWSTR Path ,
                                                                                                PCWSTR ValueName ) ;
NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo ,
                                                                PCWSTR Path , PCWSTR ValueName ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_210_0;
  } else {
    {
    goto switch_210_default;
    if (0) {
      switch_210_0: /* CIL Label */ ;
      return (0L);
      switch_210_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_210_break: /* CIL Label */ ;
    }
    }
  }
}
}
  void RtlFreeUnicodeString(PUNICODE_STRING UnicodeString ) ;
void RtlFreeUnicodeString(PUNICODE_STRING UnicodeString ) 
{ 

  {
  return;
}
}
  void RtlInitString(PSTRING DestinationString ,
                                                                                   PCSZ SourceString ) ;
void RtlInitString(PSTRING DestinationString , PCSZ SourceString ) 
{ 

  {
  return;
}
}
  void RtlInitUnicodeString(PUNICODE_STRING DestinationString ,
                                                                                          PCWSTR SourceString ) ;
void RtlInitUnicodeString(PUNICODE_STRING DestinationString ,
                                                          PCWSTR SourceString ) 
{ 

  {
  return;
}
}
  NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo ,
                                                                                                PCWSTR Path ,
                                                                                                PRTL_QUERY_REGISTRY_TABLE QueryTable ,
                                                                                                PVOID Context ,
                                                                                                PVOID Environment ) ;
NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo ,
                                                                PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable ,
                                                                PVOID Context , PVOID Environment ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_211_0;
  } else {
    {
    goto switch_211_default;
    if (0) {
      switch_211_0: /* CIL Label */ ;
      return (0L);
      switch_211_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_211_break: /* CIL Label */ ;
    }
    }
  }
}
}
  NTSTATUS ZwClose(HANDLE Handle ) ;
NTSTATUS ZwClose(HANDLE Handle ) 
{ int __BLAST_NONDET = __VERIFIER_nondet_int() ;

  {
  if (__BLAST_NONDET == 0) {
    goto switch_212_0;
  } else {
    {
    goto switch_212_default;
    if (0) {
      switch_212_0: /* CIL Label */ ;
      return (0L);
      switch_212_default: /* CIL Label */ ;
      return (-1073741823L);
    } else {
      switch_212_break: /* CIL Label */ ;
    }
    }
  }
}
}
